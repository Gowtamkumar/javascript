"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minipass";
exports.ids = ["vendor-chunks/minipass"];
exports.modules = {

/***/ "(rsc)/./node_modules/minipass/dist/commonjs/index.js":
/*!******************************************************!*\
  !*** ./node_modules/minipass/dist/commonjs/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;\nconst proc = typeof process === \"object\" && process ? process : {\n    stdout: null,\n    stderr: null\n};\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst stream_1 = __importDefault(__webpack_require__(/*! stream */ \"stream\"));\nconst string_decoder_1 = __webpack_require__(/*! string_decoder */ \"string_decoder\");\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */ const isStream = (s)=>!!s && typeof s === \"object\" && (s instanceof Minipass || s instanceof stream_1.default || (0, exports.isReadable)(s) || (0, exports.isWritable)(s));\nexports.isStream = isStream;\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */ const isReadable = (s)=>!!s && typeof s === \"object\" && s instanceof events_1.EventEmitter && typeof s.pipe === \"function\" && // node core Writable streams have a pipe() method, but it throws\n    s.pipe !== stream_1.default.Writable.prototype.pipe;\nexports.isReadable = isReadable;\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */ const isWritable = (s)=>!!s && typeof s === \"object\" && s instanceof events_1.EventEmitter && typeof s.write === \"function\" && typeof s.end === \"function\";\nexports.isWritable = isWritable;\nconst EOF = Symbol(\"EOF\");\nconst MAYBE_EMIT_END = Symbol(\"maybeEmitEnd\");\nconst EMITTED_END = Symbol(\"emittedEnd\");\nconst EMITTING_END = Symbol(\"emittingEnd\");\nconst EMITTED_ERROR = Symbol(\"emittedError\");\nconst CLOSED = Symbol(\"closed\");\nconst READ = Symbol(\"read\");\nconst FLUSH = Symbol(\"flush\");\nconst FLUSHCHUNK = Symbol(\"flushChunk\");\nconst ENCODING = Symbol(\"encoding\");\nconst DECODER = Symbol(\"decoder\");\nconst FLOWING = Symbol(\"flowing\");\nconst PAUSED = Symbol(\"paused\");\nconst RESUME = Symbol(\"resume\");\nconst BUFFER = Symbol(\"buffer\");\nconst PIPES = Symbol(\"pipes\");\nconst BUFFERLENGTH = Symbol(\"bufferLength\");\nconst BUFFERPUSH = Symbol(\"bufferPush\");\nconst BUFFERSHIFT = Symbol(\"bufferShift\");\nconst OBJECTMODE = Symbol(\"objectMode\");\n// internal event when stream is destroyed\nconst DESTROYED = Symbol(\"destroyed\");\n// internal event when stream has an error\nconst ERROR = Symbol(\"error\");\nconst EMITDATA = Symbol(\"emitData\");\nconst EMITEND = Symbol(\"emitEnd\");\nconst EMITEND2 = Symbol(\"emitEnd2\");\nconst ASYNC = Symbol(\"async\");\nconst ABORT = Symbol(\"abort\");\nconst ABORTED = Symbol(\"aborted\");\nconst SIGNAL = Symbol(\"signal\");\nconst DATALISTENERS = Symbol(\"dataListeners\");\nconst DISCARDED = Symbol(\"discarded\");\nconst defer = (fn)=>Promise.resolve().then(fn);\nconst nodefer = (fn)=>fn();\nconst isEndish = (ev)=>ev === \"end\" || ev === \"finish\" || ev === \"prefinish\";\nconst isArrayBufferLike = (b)=>b instanceof ArrayBuffer || !!b && typeof b === \"object\" && b.constructor && b.constructor.name === \"ArrayBuffer\" && b.byteLength >= 0;\nconst isArrayBufferView = (b)=>!Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */ class Pipe {\n    constructor(src, dest, opts){\n        this.src = src;\n        this.dest = dest;\n        this.opts = opts;\n        this.ondrain = ()=>src[RESUME]();\n        this.dest.on(\"drain\", this.ondrain);\n    }\n    unpipe() {\n        this.dest.removeListener(\"drain\", this.ondrain);\n    }\n    // only here for the prototype\n    /* c8 ignore start */ proxyErrors(_er) {}\n    /* c8 ignore stop */ end() {\n        this.unpipe();\n        if (this.opts.end) this.dest.end();\n    }\n}\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */ class PipeProxyErrors extends Pipe {\n    unpipe() {\n        this.src.removeListener(\"error\", this.proxyErrors);\n        super.unpipe();\n    }\n    constructor(src, dest, opts){\n        super(src, dest, opts);\n        this.proxyErrors = (er)=>dest.emit(\"error\", er);\n        src.on(\"error\", this.proxyErrors);\n    }\n}\nconst isObjectModeOptions = (o)=>!!o.objectMode;\nconst isEncodingOptions = (o)=>!o.objectMode && !!o.encoding && o.encoding !== \"buffer\";\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */ class Minipass extends events_1.EventEmitter {\n    /**\n     * If `RType` is Buffer, then options do not need to be provided.\n     * Otherwise, an options object must be provided to specify either\n     * {@link Minipass.SharedOptions.objectMode} or\n     * {@link Minipass.SharedOptions.encoding}, as appropriate.\n     */ constructor(...args){\n        const options = args[0] || {};\n        super();\n        this[FLOWING] = false;\n        this[PAUSED] = false;\n        this[PIPES] = [];\n        this[BUFFER] = [];\n        this[EOF] = false;\n        this[EMITTED_END] = false;\n        this[EMITTING_END] = false;\n        this[CLOSED] = false;\n        this[EMITTED_ERROR] = null;\n        this[BUFFERLENGTH] = 0;\n        this[DESTROYED] = false;\n        this[ABORTED] = false;\n        this[DATALISTENERS] = 0;\n        this[DISCARDED] = false;\n        /**\n     * true if the stream can be written\n     */ this.writable = true;\n        /**\n     * true if the stream can be read\n     */ this.readable = true;\n        if (options.objectMode && typeof options.encoding === \"string\") {\n            throw new TypeError(\"Encoding and objectMode may not be used together\");\n        }\n        if (isObjectModeOptions(options)) {\n            this[OBJECTMODE] = true;\n            this[ENCODING] = null;\n        } else if (isEncodingOptions(options)) {\n            this[ENCODING] = options.encoding;\n            this[OBJECTMODE] = false;\n        } else {\n            this[OBJECTMODE] = false;\n            this[ENCODING] = null;\n        }\n        this[ASYNC] = !!options.async;\n        this[DECODER] = this[ENCODING] ? new string_decoder_1.StringDecoder(this[ENCODING]) : null;\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposeBuffer === true) {\n            Object.defineProperty(this, \"buffer\", {\n                get: ()=>this[BUFFER]\n            });\n        }\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposePipes === true) {\n            Object.defineProperty(this, \"pipes\", {\n                get: ()=>this[PIPES]\n            });\n        }\n        const { signal } = options;\n        if (signal) {\n            this[SIGNAL] = signal;\n            if (signal.aborted) {\n                this[ABORT]();\n            } else {\n                signal.addEventListener(\"abort\", ()=>this[ABORT]());\n            }\n        }\n    }\n    /**\n     * The amount of data stored in the buffer waiting to be read.\n     *\n     * For Buffer strings, this will be the total byte length.\n     * For string encoding streams, this will be the string character length,\n     * according to JavaScript's `string.length` logic.\n     * For objectMode streams, this is a count of the items waiting to be\n     * emitted.\n     */ get bufferLength() {\n        return this[BUFFERLENGTH];\n    }\n    /**\n     * The `BufferEncoding` currently in use, or `null`\n     */ get encoding() {\n        return this[ENCODING];\n    }\n    /**\n     * @deprecated - This is a read only property\n     */ set encoding(_enc) {\n        throw new Error(\"Encoding must be set at instantiation time\");\n    }\n    /**\n     * @deprecated - Encoding may only be set at instantiation time\n     */ setEncoding(_enc) {\n        throw new Error(\"Encoding must be set at instantiation time\");\n    }\n    /**\n     * True if this is an objectMode stream\n     */ get objectMode() {\n        return this[OBJECTMODE];\n    }\n    /**\n     * @deprecated - This is a read-only property\n     */ set objectMode(_om) {\n        throw new Error(\"objectMode must be set at instantiation time\");\n    }\n    /**\n     * true if this is an async stream\n     */ get [\"async\"]() {\n        return this[ASYNC];\n    }\n    /**\n     * Set to true to make this stream async.\n     *\n     * Once set, it cannot be unset, as this would potentially cause incorrect\n     * behavior.  Ie, a sync stream can be made async, but an async stream\n     * cannot be safely made sync.\n     */ set [\"async\"](a) {\n        this[ASYNC] = this[ASYNC] || !!a;\n    }\n    // drop everything and get out of the flow completely\n    [ABORT]() {\n        this[ABORTED] = true;\n        this.emit(\"abort\", this[SIGNAL]?.reason);\n        this.destroy(this[SIGNAL]?.reason);\n    }\n    /**\n     * True if the stream has been aborted.\n     */ get aborted() {\n        return this[ABORTED];\n    }\n    /**\n     * No-op setter. Stream aborted status is set via the AbortSignal provided\n     * in the constructor options.\n     */ set aborted(_) {}\n    write(chunk, encoding, cb) {\n        if (this[ABORTED]) return false;\n        if (this[EOF]) throw new Error(\"write after end\");\n        if (this[DESTROYED]) {\n            this.emit(\"error\", Object.assign(new Error(\"Cannot call write after a stream was destroyed\"), {\n                code: \"ERR_STREAM_DESTROYED\"\n            }));\n            return true;\n        }\n        if (typeof encoding === \"function\") {\n            cb = encoding;\n            encoding = \"utf8\";\n        }\n        if (!encoding) encoding = \"utf8\";\n        const fn = this[ASYNC] ? defer : nodefer;\n        // convert array buffers and typed array views into buffers\n        // at some point in the future, we may want to do the opposite!\n        // leave strings and buffers as-is\n        // anything is only allowed if in object mode, so throw\n        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n            if (isArrayBufferView(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n            } else if (isArrayBufferLike(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk);\n            } else if (typeof chunk !== \"string\") {\n                throw new Error(\"Non-contiguous data written to non-objectMode stream\");\n            }\n        }\n        // handle object mode up front, since it's simpler\n        // this yields better performance, fewer checks later.\n        if (this[OBJECTMODE]) {\n            // maybe impossible?\n            /* c8 ignore start */ if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n            /* c8 ignore stop */ if (this[FLOWING]) this.emit(\"data\", chunk);\n            else this[BUFFERPUSH](chunk);\n            if (this[BUFFERLENGTH] !== 0) this.emit(\"readable\");\n            if (cb) fn(cb);\n            return this[FLOWING];\n        }\n        // at this point the chunk is a buffer or string\n        // don't buffer it up or send it to the decoder\n        if (!chunk.length) {\n            if (this[BUFFERLENGTH] !== 0) this.emit(\"readable\");\n            if (cb) fn(cb);\n            return this[FLOWING];\n        }\n        // fast-path writing strings of same encoding to a stream with\n        // an empty buffer, skipping the buffer/decoder dance\n        if (typeof chunk === \"string\" && // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = this[DECODER].write(chunk);\n        }\n        // Note: flushing CAN potentially switch us into not-flowing mode\n        if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n        if (this[FLOWING]) this.emit(\"data\", chunk);\n        else this[BUFFERPUSH](chunk);\n        if (this[BUFFERLENGTH] !== 0) this.emit(\"readable\");\n        if (cb) fn(cb);\n        return this[FLOWING];\n    }\n    /**\n     * Low-level explicit read method.\n     *\n     * In objectMode, the argument is ignored, and one item is returned if\n     * available.\n     *\n     * `n` is the number of bytes (or in the case of encoding streams,\n     * characters) to consume. If `n` is not provided, then the entire buffer\n     * is returned, or `null` is returned if no data is available.\n     *\n     * If `n` is greater that the amount of data in the internal buffer,\n     * then `null` is returned.\n     */ read(n) {\n        if (this[DESTROYED]) return null;\n        this[DISCARDED] = false;\n        if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {\n            this[MAYBE_EMIT_END]();\n            return null;\n        }\n        if (this[OBJECTMODE]) n = null;\n        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n            // not object mode, so if we have an encoding, then RType is string\n            // otherwise, must be Buffer\n            this[BUFFER] = [\n                this[ENCODING] ? this[BUFFER].join(\"\") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])\n            ];\n        }\n        const ret = this[READ](n || null, this[BUFFER][0]);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [READ](n, chunk) {\n        if (this[OBJECTMODE]) this[BUFFERSHIFT]();\n        else {\n            const c = chunk;\n            if (n === c.length || n === null) this[BUFFERSHIFT]();\n            else if (typeof c === \"string\") {\n                this[BUFFER][0] = c.slice(n);\n                chunk = c.slice(0, n);\n                this[BUFFERLENGTH] -= n;\n            } else {\n                this[BUFFER][0] = c.subarray(n);\n                chunk = c.subarray(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n        }\n        this.emit(\"data\", chunk);\n        if (!this[BUFFER].length && !this[EOF]) this.emit(\"drain\");\n        return chunk;\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === \"function\") {\n            cb = chunk;\n            chunk = undefined;\n        }\n        if (typeof encoding === \"function\") {\n            cb = encoding;\n            encoding = \"utf8\";\n        }\n        if (chunk !== undefined) this.write(chunk, encoding);\n        if (cb) this.once(\"end\", cb);\n        this[EOF] = true;\n        this.writable = false;\n        // if we haven't written anything, then go ahead and emit,\n        // even if we're not reading.\n        // we'll re-emit if a new 'end' listener is added anyway.\n        // This makes MP more suitable to write-only use cases.\n        if (this[FLOWING] || !this[PAUSED]) this[MAYBE_EMIT_END]();\n        return this;\n    }\n    // don't let the internal resume be overwritten\n    [RESUME]() {\n        if (this[DESTROYED]) return;\n        if (!this[DATALISTENERS] && !this[PIPES].length) {\n            this[DISCARDED] = true;\n        }\n        this[PAUSED] = false;\n        this[FLOWING] = true;\n        this.emit(\"resume\");\n        if (this[BUFFER].length) this[FLUSH]();\n        else if (this[EOF]) this[MAYBE_EMIT_END]();\n        else this.emit(\"drain\");\n    }\n    /**\n     * Resume the stream if it is currently in a paused state\n     *\n     * If called when there are no pipe destinations or `data` event listeners,\n     * this will place the stream in a \"discarded\" state, where all data will\n     * be thrown away. The discarded state is removed if a pipe destination or\n     * data handler is added, if pause() is called, or if any synchronous or\n     * asynchronous iteration is started.\n     */ resume() {\n        return this[RESUME]();\n    }\n    /**\n     * Pause the stream\n     */ pause() {\n        this[FLOWING] = false;\n        this[PAUSED] = true;\n        this[DISCARDED] = false;\n    }\n    /**\n     * true if the stream has been forcibly destroyed\n     */ get destroyed() {\n        return this[DESTROYED];\n    }\n    /**\n     * true if the stream is currently in a flowing state, meaning that\n     * any writes will be immediately emitted.\n     */ get flowing() {\n        return this[FLOWING];\n    }\n    /**\n     * true if the stream is currently in a paused state\n     */ get paused() {\n        return this[PAUSED];\n    }\n    [BUFFERPUSH](chunk) {\n        if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;\n        else this[BUFFERLENGTH] += chunk.length;\n        this[BUFFER].push(chunk);\n    }\n    [BUFFERSHIFT]() {\n        if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;\n        else this[BUFFERLENGTH] -= this[BUFFER][0].length;\n        return this[BUFFER].shift();\n    }\n    [FLUSH](noDrain = false) {\n        do {}while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);\n        if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit(\"drain\");\n    }\n    [FLUSHCHUNK](chunk) {\n        this.emit(\"data\", chunk);\n        return this[FLOWING];\n    }\n    /**\n     * Pipe all data emitted by this stream into the destination provided.\n     *\n     * Triggers the flow of data.\n     */ pipe(dest, opts) {\n        if (this[DESTROYED]) return dest;\n        this[DISCARDED] = false;\n        const ended = this[EMITTED_END];\n        opts = opts || {};\n        if (dest === proc.stdout || dest === proc.stderr) opts.end = false;\n        else opts.end = opts.end !== false;\n        opts.proxyErrors = !!opts.proxyErrors;\n        // piping an ended stream ends immediately\n        if (ended) {\n            if (opts.end) dest.end();\n        } else {\n            // \"as\" here just ignores the WType, which pipes don't care about,\n            // since they're only consuming from us, and writing to the dest\n            this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));\n            if (this[ASYNC]) defer(()=>this[RESUME]());\n            else this[RESUME]();\n        }\n        return dest;\n    }\n    /**\n     * Fully unhook a piped destination stream.\n     *\n     * If the destination stream was the only consumer of this stream (ie,\n     * there are no other piped destinations or `'data'` event listeners)\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */ unpipe(dest) {\n        const p = this[PIPES].find((p)=>p.dest === dest);\n        if (p) {\n            if (this[PIPES].length === 1) {\n                if (this[FLOWING] && this[DATALISTENERS] === 0) {\n                    this[FLOWING] = false;\n                }\n                this[PIPES] = [];\n            } else this[PIPES].splice(this[PIPES].indexOf(p), 1);\n            p.unpipe();\n        }\n    }\n    /**\n     * Alias for {@link Minipass#on}\n     */ addListener(ev, handler) {\n        return this.on(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.on`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * - Adding a 'data' event handler will trigger the flow of data\n     *\n     * - Adding a 'readable' event handler when there is data waiting to be read\n     *   will cause 'readable' to be emitted immediately.\n     *\n     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n     *   already passed will cause the event to be emitted immediately and all\n     *   handlers removed.\n     *\n     * - Adding an 'error' event handler after an error has been emitted will\n     *   cause the event to be re-emitted immediately with the error previously\n     *   raised.\n     */ on(ev, handler) {\n        const ret = super.on(ev, handler);\n        if (ev === \"data\") {\n            this[DISCARDED] = false;\n            this[DATALISTENERS]++;\n            if (!this[PIPES].length && !this[FLOWING]) {\n                this[RESUME]();\n            }\n        } else if (ev === \"readable\" && this[BUFFERLENGTH] !== 0) {\n            super.emit(\"readable\");\n        } else if (isEndish(ev) && this[EMITTED_END]) {\n            super.emit(ev);\n            this.removeAllListeners(ev);\n        } else if (ev === \"error\" && this[EMITTED_ERROR]) {\n            const h = handler;\n            if (this[ASYNC]) defer(()=>h.call(this, this[EMITTED_ERROR]));\n            else h.call(this, this[EMITTED_ERROR]);\n        }\n        return ret;\n    }\n    /**\n     * Alias for {@link Minipass#off}\n     */ removeListener(ev, handler) {\n        return this.off(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.off`\n     *\n     * If a 'data' event handler is removed, and it was the last consumer\n     * (ie, there are no pipe destinations or other 'data' event listeners),\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */ off(ev, handler) {\n        const ret = super.off(ev, handler);\n        // if we previously had listeners, and now we don't, and we don't\n        // have any pipes, then stop the flow, unless it's been explicitly\n        // put in a discarded flowing state via stream.resume().\n        if (ev === \"data\") {\n            this[DATALISTENERS] = this.listeners(\"data\").length;\n            if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Mostly identical to `EventEmitter.removeAllListeners`\n     *\n     * If all 'data' event handlers are removed, and they were the last consumer\n     * (ie, there are no pipe destinations), then the flow of data will stop\n     * until there is another consumer or {@link Minipass#resume} is explicitly\n     * called.\n     */ removeAllListeners(ev) {\n        const ret = super.removeAllListeners(ev);\n        if (ev === \"data\" || ev === undefined) {\n            this[DATALISTENERS] = 0;\n            if (!this[DISCARDED] && !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * true if the 'end' event has been emitted\n     */ get emittedEnd() {\n        return this[EMITTED_END];\n    }\n    [MAYBE_EMIT_END]() {\n        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {\n            this[EMITTING_END] = true;\n            this.emit(\"end\");\n            this.emit(\"prefinish\");\n            this.emit(\"finish\");\n            if (this[CLOSED]) this.emit(\"close\");\n            this[EMITTING_END] = false;\n        }\n    }\n    /**\n     * Mostly identical to `EventEmitter.emit`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * If the stream has been destroyed, and the event is something other\n     * than 'close' or 'error', then `false` is returned and no handlers\n     * are called.\n     *\n     * If the event is 'end', and has already been emitted, then the event\n     * is ignored. If the stream is in a paused or non-flowing state, then\n     * the event will be deferred until data flow resumes. If the stream is\n     * async, then handlers will be called on the next tick rather than\n     * immediately.\n     *\n     * If the event is 'close', and 'end' has not yet been emitted, then\n     * the event will be deferred until after 'end' is emitted.\n     *\n     * If the event is 'error', and an AbortSignal was provided for the stream,\n     * and there are no listeners, then the event is ignored, matching the\n     * behavior of node core streams in the presense of an AbortSignal.\n     *\n     * If the event is 'finish' or 'prefinish', then all listeners will be\n     * removed after emitting the event, to prevent double-firing.\n     */ emit(ev, ...args) {\n        const data = args[0];\n        // error and close are only events allowed after calling destroy()\n        if (ev !== \"error\" && ev !== \"close\" && ev !== DESTROYED && this[DESTROYED]) {\n            return false;\n        } else if (ev === \"data\") {\n            return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(()=>this[EMITDATA](data)), true) : this[EMITDATA](data);\n        } else if (ev === \"end\") {\n            return this[EMITEND]();\n        } else if (ev === \"close\") {\n            this[CLOSED] = true;\n            // don't emit close before 'end' and 'finish'\n            if (!this[EMITTED_END] && !this[DESTROYED]) return false;\n            const ret = super.emit(\"close\");\n            this.removeAllListeners(\"close\");\n            return ret;\n        } else if (ev === \"error\") {\n            this[EMITTED_ERROR] = data;\n            super.emit(ERROR, data);\n            const ret = !this[SIGNAL] || this.listeners(\"error\").length ? super.emit(\"error\", data) : false;\n            this[MAYBE_EMIT_END]();\n            return ret;\n        } else if (ev === \"resume\") {\n            const ret = super.emit(\"resume\");\n            this[MAYBE_EMIT_END]();\n            return ret;\n        } else if (ev === \"finish\" || ev === \"prefinish\") {\n            const ret = super.emit(ev);\n            this.removeAllListeners(ev);\n            return ret;\n        }\n        // Some other unknown event\n        const ret = super.emit(ev, ...args);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITDATA](data) {\n        for (const p of this[PIPES]){\n            if (p.dest.write(data) === false) this.pause();\n        }\n        const ret = this[DISCARDED] ? false : super.emit(\"data\", data);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITEND]() {\n        if (this[EMITTED_END]) return false;\n        this[EMITTED_END] = true;\n        this.readable = false;\n        return this[ASYNC] ? (defer(()=>this[EMITEND2]()), true) : this[EMITEND2]();\n    }\n    [EMITEND2]() {\n        if (this[DECODER]) {\n            const data = this[DECODER].end();\n            if (data) {\n                for (const p of this[PIPES]){\n                    p.dest.write(data);\n                }\n                if (!this[DISCARDED]) super.emit(\"data\", data);\n            }\n        }\n        for (const p of this[PIPES]){\n            p.end();\n        }\n        const ret = super.emit(\"end\");\n        this.removeAllListeners(\"end\");\n        return ret;\n    }\n    /**\n     * Return a Promise that resolves to an array of all emitted data once\n     * the stream ends.\n     */ async collect() {\n        const buf = Object.assign([], {\n            dataLength: 0\n        });\n        if (!this[OBJECTMODE]) buf.dataLength = 0;\n        // set the promise first, in case an error is raised\n        // by triggering the flow here.\n        const p = this.promise();\n        this.on(\"data\", (c)=>{\n            buf.push(c);\n            if (!this[OBJECTMODE]) buf.dataLength += c.length;\n        });\n        await p;\n        return buf;\n    }\n    /**\n     * Return a Promise that resolves to the concatenation of all emitted data\n     * once the stream ends.\n     *\n     * Not allowed on objectMode streams.\n     */ async concat() {\n        if (this[OBJECTMODE]) {\n            throw new Error(\"cannot concat in objectMode\");\n        }\n        const buf = await this.collect();\n        return this[ENCODING] ? buf.join(\"\") : Buffer.concat(buf, buf.dataLength);\n    }\n    /**\n     * Return a void Promise that resolves once the stream ends.\n     */ async promise() {\n        return new Promise((resolve, reject)=>{\n            this.on(DESTROYED, ()=>reject(new Error(\"stream destroyed\")));\n            this.on(\"error\", (er)=>reject(er));\n            this.on(\"end\", ()=>resolve());\n        });\n    }\n    /**\n     * Asynchronous `for await of` iteration.\n     *\n     * This will continue emitting all chunks until the stream terminates.\n     */ [Symbol.asyncIterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = async ()=>{\n            this.pause();\n            stopped = true;\n            return {\n                value: undefined,\n                done: true\n            };\n        };\n        const next = ()=>{\n            if (stopped) return stop();\n            const res = this.read();\n            if (res !== null) return Promise.resolve({\n                done: false,\n                value: res\n            });\n            if (this[EOF]) return stop();\n            let resolve;\n            let reject;\n            const onerr = (er)=>{\n                this.off(\"data\", ondata);\n                this.off(\"end\", onend);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                reject(er);\n            };\n            const ondata = (value)=>{\n                this.off(\"error\", onerr);\n                this.off(\"end\", onend);\n                this.off(DESTROYED, ondestroy);\n                this.pause();\n                resolve({\n                    value,\n                    done: !!this[EOF]\n                });\n            };\n            const onend = ()=>{\n                this.off(\"error\", onerr);\n                this.off(\"data\", ondata);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                resolve({\n                    done: true,\n                    value: undefined\n                });\n            };\n            const ondestroy = ()=>onerr(new Error(\"stream destroyed\"));\n            return new Promise((res, rej)=>{\n                reject = rej;\n                resolve = res;\n                this.once(DESTROYED, ondestroy);\n                this.once(\"error\", onerr);\n                this.once(\"end\", onend);\n                this.once(\"data\", ondata);\n            });\n        };\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.asyncIterator] () {\n                return this;\n            }\n        };\n    }\n    /**\n     * Synchronous `for of` iteration.\n     *\n     * The iteration will terminate when the internal buffer runs out, even\n     * if the stream has not yet terminated.\n     */ [Symbol.iterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = ()=>{\n            this.pause();\n            this.off(ERROR, stop);\n            this.off(DESTROYED, stop);\n            this.off(\"end\", stop);\n            stopped = true;\n            return {\n                done: true,\n                value: undefined\n            };\n        };\n        const next = ()=>{\n            if (stopped) return stop();\n            const value = this.read();\n            return value === null ? stop() : {\n                done: false,\n                value\n            };\n        };\n        this.once(\"end\", stop);\n        this.once(ERROR, stop);\n        this.once(DESTROYED, stop);\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.iterator] () {\n                return this;\n            }\n        };\n    }\n    /**\n     * Destroy a stream, preventing it from being used for any further purpose.\n     *\n     * If the stream has a `close()` method, then it will be called on\n     * destruction.\n     *\n     * After destruction, any attempt to write data, read data, or emit most\n     * events will be ignored.\n     *\n     * If an error argument is provided, then it will be emitted in an\n     * 'error' event.\n     */ destroy(er) {\n        if (this[DESTROYED]) {\n            if (er) this.emit(\"error\", er);\n            else this.emit(DESTROYED);\n            return this;\n        }\n        this[DESTROYED] = true;\n        this[DISCARDED] = true;\n        // throw away all buffered data, it's never coming out\n        this[BUFFER].length = 0;\n        this[BUFFERLENGTH] = 0;\n        const wc = this;\n        if (typeof wc.close === \"function\" && !this[CLOSED]) wc.close();\n        if (er) this.emit(\"error\", er);\n        else this.emit(DESTROYED);\n        return this;\n    }\n    /**\n     * Alias for {@link isStream}\n     *\n     * Former export location, maintained for backwards compatibility.\n     *\n     * @deprecated\n     */ static get isStream() {\n        return exports.isStream;\n    }\n}\nexports.Minipass = Minipass; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaXBhc3MvZGlzdC9jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBSyxTQUFVQyxHQUFHO0lBQ2pFLE9BQU8sT0FBUUEsSUFBSUMsVUFBVSxHQUFJRCxNQUFNO1FBQUUsV0FBV0E7SUFBSTtBQUM1RDtBQUNBRSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUdBLGtCQUFrQixHQUFHQSxrQkFBa0IsR0FBR0EsZ0JBQWdCLEdBQUcsS0FBSztBQUNyRixNQUFNTSxPQUFPLE9BQU9DLFlBQVksWUFBWUEsVUFDdENBLFVBQ0E7SUFDRUMsUUFBUTtJQUNSQyxRQUFRO0FBQ1o7QUFDSixNQUFNQyxXQUFXQyxtQkFBT0EsQ0FBQyxzQkFBUTtBQUNqQyxNQUFNQyxXQUFXakIsZ0JBQWdCZ0IsbUJBQU9BLENBQUMsc0JBQVE7QUFDakQsTUFBTUUsbUJBQW1CRixtQkFBT0EsQ0FBQyxzQ0FBZ0I7QUFDakQ7OztDQUdDLEdBQ0QsTUFBTU4sV0FBVyxDQUFDUyxJQUFNLENBQUMsQ0FBQ0EsS0FDdEIsT0FBT0EsTUFBTSxZQUNaQSxDQUFBQSxhQUFhWixZQUNWWSxhQUFhRixTQUFTRyxPQUFPLElBQzdCLENBQUMsR0FBR2YsUUFBUUksVUFBVSxFQUFFVSxNQUN4QixDQUFDLEdBQUdkLFFBQVFHLFVBQVUsRUFBRVcsRUFBQztBQUNqQ2QsZ0JBQWdCLEdBQUdLO0FBQ25COztDQUVDLEdBQ0QsTUFBTUQsYUFBYSxDQUFDVSxJQUFNLENBQUMsQ0FBQ0EsS0FDeEIsT0FBT0EsTUFBTSxZQUNiQSxhQUFhSixTQUFTTSxZQUFZLElBQ2xDLE9BQU9GLEVBQUVHLElBQUksS0FBSyxjQUNsQixpRUFBaUU7SUFDakVILEVBQUVHLElBQUksS0FBS0wsU0FBU0csT0FBTyxDQUFDRyxRQUFRLENBQUNDLFNB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VSxFQUFFO1lBQ2pCLElBQUl3QyxJQUNBLElBQUksQ0FBQ0MsSUFBSSxDQUFDLFNBQVNEO2lCQUVuQixJQUFJLENBQUNDLElBQUksQ0FBQ3pDO1lBQ2QsT0FBTyxJQUFJO1FBQ2Y7UUFDQSxJQUFJLENBQUNBLFVBQVUsR0FBRztRQUNsQixJQUFJLENBQUNVLFVBQVUsR0FBRztRQUNsQixzREFBc0Q7UUFDdEQsSUFBSSxDQUFDaEIsT0FBTyxDQUFDa0YsTUFBTSxHQUFHO1FBQ3RCLElBQUksQ0FBQ2hGLGFBQWEsR0FBRztRQUNyQixNQUFNcUksS0FBSyxJQUFJO1FBQ2YsSUFBSSxPQUFPQSxHQUFHQyxLQUFLLEtBQUssY0FBYyxDQUFDLElBQUksQ0FBQ2pKLE9BQU8sRUFDL0NnSixHQUFHQyxLQUFLO1FBQ1osSUFBSTFGLElBQ0EsSUFBSSxDQUFDQyxJQUFJLENBQUMsU0FBU0Q7YUFHbkIsSUFBSSxDQUFDQyxJQUFJLENBQUN6QztRQUNkLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7OztLQU1DLEdBQ0QsV0FBV3RDLFdBQVc7UUFDbEIsT0FBT0wsUUFBUUssUUFBUTtJQUMzQjtBQUNKO0FBQ0FMLGdCQUFnQixHQUFHRSxVQUNuQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvbWluaXBhc3MvZGlzdC9jb21tb25qcy9pbmRleC5qcz8xNDk1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NaW5pcGFzcyA9IGV4cG9ydHMuaXNXcml0YWJsZSA9IGV4cG9ydHMuaXNSZWFkYWJsZSA9IGV4cG9ydHMuaXNTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBwcm9jID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3NcbiAgICA/IHByb2Nlc3NcbiAgICA6IHtcbiAgICAgICAgc3Rkb3V0OiBudWxsLFxuICAgICAgICBzdGRlcnI6IG51bGwsXG4gICAgfTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHN0cmVhbV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJzdHJlYW1cIikpO1xuY29uc3Qgc3RyaW5nX2RlY29kZXJfMSA9IHJlcXVpcmUoXCJzdHJpbmdfZGVjb2RlclwiKTtcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGEgTWluaXBhc3Mgc3RyZWFtLCBOb2RlIHN0cmVhbSwgb3Igc29tZXRoaW5nXG4gKiBlbHNlIHRoYXQgTWluaXBhc3MgY2FuIGludGVyYWN0IHdpdGguXG4gKi9cbmNvbnN0IGlzU3RyZWFtID0gKHMpID0+ICEhcyAmJlxuICAgIHR5cGVvZiBzID09PSAnb2JqZWN0JyAmJlxuICAgIChzIGluc3RhbmNlb2YgTWluaXBhc3MgfHxcbiAgICAgICAgcyBpbnN0YW5jZW9mIHN0cmVhbV8xLmRlZmF1bHQgfHxcbiAgICAgICAgKDAsIGV4cG9ydHMuaXNSZWFkYWJsZSkocykgfHxcbiAgICAgICAgKDAsIGV4cG9ydHMuaXNXcml0YWJsZSkocykpO1xuZXhwb3J0cy5pc1N0cmVhbSA9IGlzU3RyZWFtO1xuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYSB2YWxpZCB7QGxpbmsgTWluaXBhc3MuUmVhZGFibGV9XG4gKi9cbmNvbnN0IGlzUmVhZGFibGUgPSAocykgPT4gISFzICYmXG4gICAgdHlwZW9mIHMgPT09ICdvYmplY3QnICYmXG4gICAgcyBpbnN0YW5jZW9mIGV2ZW50c18xLkV2ZW50RW1pdHRlciAmJlxuICAgIHR5cGVvZiBzLnBpcGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAvLyBub2RlIGNvcmUgV3JpdGFibGUgc3RyZWFtcyBoYXZlIGEgcGlwZSgpIG1ldGhvZCwgYnV0IGl0IHRocm93c1xuICAgIHMucGlwZSAhPT0gc3RyZWFtXzEuZGVmYXVsdC5Xcml0YWJsZS5wcm90b3R5cGUucGlwZTtcbmV4cG9ydHMuaXNSZWFkYWJsZSA9IGlzUmVhZGFibGU7XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhIHZhbGlkIHtAbGluayBNaW5pcGFzcy5Xcml0YWJsZX1cbiAqL1xuY29uc3QgaXNXcml0YWJsZSA9IChzKSA9PiAhIXMgJiZcbiAgICB0eXBlb2YgcyA9PT0gJ29iamVjdCcgJiZcbiAgICBzIGluc3RhbmNlb2YgZXZlbnRzXzEuRXZlbnRFbWl0dGVyICYmXG4gICAgdHlwZW9mIHMud3JpdGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygcy5lbmQgPT09ICdmdW5jdGlvbic7XG5leHBvcnRzLmlzV3JpdGFibGUgPSBpc1dyaXRhYmxlO1xuY29uc3QgRU9GID0gU3ltYm9sKCdFT0YnKTtcbmNvbnN0IE1BWUJFX0VNSVRfRU5EID0gU3ltYm9sKCdtYXliZUVtaXRFbmQnKTtcbmNvbnN0IEVNSVRURURfRU5EID0gU3ltYm9sKCdlbWl0dGVkRW5kJyk7XG5jb25zdCBFTUlUVElOR19FTkQgPSBTeW1ib2woJ2VtaXR0aW5nRW5kJyk7XG5jb25zdCBFTUlUVEVEX0VSUk9SID0gU3ltYm9sKCdlbWl0dGVkRXJyb3InKTtcbmNvbnN0IENMT1NFRCA9IFN5bWJvbCgnY2xvc2VkJyk7XG5jb25zdCBSRUFEID0gU3ltYm9sKCdyZWFkJyk7XG5jb25zdCBGTFVTSCA9IFN5bWJvbCgnZmx1c2gnKTtcbmNvbnN0IEZMVVNIQ0hVTksgPSBTeW1ib2woJ2ZsdXNoQ2h1bmsnKTtcbmNvbnN0IEVOQ09ESU5HID0gU3ltYm9sKCdlbmNvZGluZycpO1xuY29uc3QgREVDT0RFUiA9IFN5bWJvbCgnZGVjb2RlcicpO1xuY29uc3QgRkxPV0lORyA9IFN5bWJvbCgnZmxvd2luZycpO1xuY29uc3QgUEFVU0VEID0gU3ltYm9sKCdwYXVzZWQnKTtcbmNvbnN0IFJFU1VNRSA9IFN5bWJvbCgncmVzdW1lJyk7XG5jb25zdCBCVUZGRVIgPSBTeW1ib2woJ2J1ZmZlcicpO1xuY29uc3QgUElQRVMgPSBTeW1ib2woJ3BpcGVzJyk7XG5jb25zdCBCVUZGRVJMRU5HVEggPSBTeW1ib2woJ2J1ZmZlckxlbmd0aCcpO1xuY29uc3QgQlVGRkVSUFVTSCA9IFN5bWJvbCgnYnVmZmVyUHVzaCcpO1xuY29uc3QgQlVGRkVSU0hJRlQgPSBTeW1ib2woJ2J1ZmZlclNoaWZ0Jyk7XG5jb25zdCBPQkpFQ1RNT0RFID0gU3ltYm9sKCdvYmplY3RNb2RlJyk7XG4vLyBpbnRlcm5hbCBldmVudCB3aGVuIHN0cmVhbSBpcyBkZXN0cm95ZWRcbmNvbnN0IERFU1RST1lFRCA9IFN5bWJvbCgnZGVzdHJveWVkJyk7XG4vLyBpbnRlcm5hbCBldmVudCB3aGVuIHN0cmVhbSBoYXMgYW4gZXJyb3JcbmNvbnN0IEVSUk9SID0gU3ltYm9sKCdlcnJvcicpO1xuY29uc3QgRU1JVERBVEEgPSBTeW1ib2woJ2VtaXREYXRhJyk7XG5jb25zdCBFTUlURU5EID0gU3ltYm9sKCdlbWl0RW5kJyk7XG5jb25zdCBFTUlURU5EMiA9IFN5bWJvbCgnZW1pdEVuZDInKTtcbmNvbnN0IEFTWU5DID0gU3ltYm9sKCdhc3luYycpO1xuY29uc3QgQUJPUlQgPSBTeW1ib2woJ2Fib3J0Jyk7XG5jb25zdCBBQk9SVEVEID0gU3ltYm9sKCdhYm9ydGVkJyk7XG5jb25zdCBTSUdOQUwgPSBTeW1ib2woJ3NpZ25hbCcpO1xuY29uc3QgREFUQUxJU1RFTkVSUyA9IFN5bWJvbCgnZGF0YUxpc3RlbmVycycpO1xuY29uc3QgRElTQ0FSREVEID0gU3ltYm9sKCdkaXNjYXJkZWQnKTtcbmNvbnN0IGRlZmVyID0gKGZuKSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZuKTtcbmNvbnN0IG5vZGVmZXIgPSAoZm4pID0+IGZuKCk7XG5jb25zdCBpc0VuZGlzaCA9IChldikgPT4gZXYgPT09ICdlbmQnIHx8IGV2ID09PSAnZmluaXNoJyB8fCBldiA9PT0gJ3ByZWZpbmlzaCc7XG5jb25zdCBpc0FycmF5QnVmZmVyTGlrZSA9IChiKSA9PiBiIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgICAoISFiICYmXG4gICAgICAgIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBiLmNvbnN0cnVjdG9yICYmXG4gICAgICAgIGIuY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxuICAgICAgICBiLmJ5dGVMZW5ndGggPj0gMCk7XG5jb25zdCBpc0FycmF5QnVmZmVyVmlldyA9IChiKSA9PiAhQnVmZmVyLmlzQnVmZmVyKGIpICYmIEFycmF5QnVmZmVyLmlzVmlldyhiKTtcbi8qKlxuICogSW50ZXJuYWwgY2xhc3MgcmVwcmVzZW50aW5nIGEgcGlwZSB0byBhIGRlc3RpbmF0aW9uIHN0cmVhbS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgUGlwZSB7XG4gICAgc3JjO1xuICAgIGRlc3Q7XG4gICAgb3B0cztcbiAgICBvbmRyYWluO1xuICAgIGNvbnN0cnVjdG9yKHNyYywgZGVzdCwgb3B0cykge1xuICAgICAgICB0aGlzLnNyYyA9IHNyYztcbiAgICAgICAgdGhpcy5kZXN0ID0gZGVzdDtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5vbmRyYWluID0gKCkgPT4gc3JjW1JFU1VNRV0oKTtcbiAgICAgICAgdGhpcy5kZXN0Lm9uKCdkcmFpbicsIHRoaXMub25kcmFpbik7XG4gICAgfVxuICAgIHVucGlwZSgpIHtcbiAgICAgICAgdGhpcy5kZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIHRoaXMub25kcmFpbik7XG4gICAgfVxuICAgIC8vIG9ubHkgaGVyZSBmb3IgdGhlIHByb3RvdHlwZVxuICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgIHByb3h5RXJyb3JzKF9lcikgeyB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMudW5waXBlKCk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZW5kKVxuICAgICAgICAgICAgdGhpcy5kZXN0LmVuZCgpO1xuICAgIH1cbn1cbi8qKlxuICogSW50ZXJuYWwgY2xhc3MgcmVwcmVzZW50aW5nIGEgcGlwZSB0byBhIGRlc3RpbmF0aW9uIHN0cmVhbSB3aGVyZVxuICogZXJyb3JzIGFyZSBwcm94aWVkLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBQaXBlUHJveHlFcnJvcnMgZXh0ZW5kcyBQaXBlIHtcbiAgICB1bnBpcGUoKSB7XG4gICAgICAgIHRoaXMuc3JjLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHRoaXMucHJveHlFcnJvcnMpO1xuICAgICAgICBzdXBlci51bnBpcGUoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3JjLCBkZXN0LCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKHNyYywgZGVzdCwgb3B0cyk7XG4gICAgICAgIHRoaXMucHJveHlFcnJvcnMgPSBlciA9PiBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICBzcmMub24oJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycyk7XG4gICAgfVxufVxuY29uc3QgaXNPYmplY3RNb2RlT3B0aW9ucyA9IChvKSA9PiAhIW8ub2JqZWN0TW9kZTtcbmNvbnN0IGlzRW5jb2RpbmdPcHRpb25zID0gKG8pID0+ICFvLm9iamVjdE1vZGUgJiYgISFvLmVuY29kaW5nICYmIG8uZW5jb2RpbmcgIT09ICdidWZmZXInO1xuLyoqXG4gKiBNYWluIGV4cG9ydCwgdGhlIE1pbmlwYXNzIGNsYXNzXG4gKlxuICogYFJUeXBlYCBpcyB0aGUgdHlwZSBvZiBkYXRhIGVtaXR0ZWQsIGRlZmF1bHRzIHRvIEJ1ZmZlclxuICpcbiAqIGBXVHlwZWAgaXMgdGhlIHR5cGUgb2YgZGF0YSB0byBiZSB3cml0dGVuLCBpZiBSVHlwZSBpcyBidWZmZXIgb3Igc3RyaW5nLFxuICogdGhlbiBhbnkge0BsaW5rIE1pbmlwYXNzLkNvbnRpZ3VvdXNEYXRhfSBpcyBhbGxvd2VkLlxuICpcbiAqIGBFdmVudHNgIGlzIHRoZSBzZXQgb2YgZXZlbnQgaGFuZGxlciBzaWduYXR1cmVzIHRoYXQgdGhpcyBvYmplY3RcbiAqIHdpbGwgZW1pdCwgc2VlIHtAbGluayBNaW5pcGFzcy5FdmVudHN9XG4gKi9cbmNsYXNzIE1pbmlwYXNzIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBbRkxPV0lOR10gPSBmYWxzZTtcbiAgICBbUEFVU0VEXSA9IGZhbHNlO1xuICAgIFtQSVBFU10gPSBbXTtcbiAgICBbQlVGRkVSXSA9IFtdO1xuICAgIFtPQkpFQ1RNT0RFXTtcbiAgICBbRU5DT0RJTkddO1xuICAgIFtBU1lOQ107XG4gICAgW0RFQ09ERVJdO1xuICAgIFtFT0ZdID0gZmFsc2U7XG4gICAgW0VNSVRURURfRU5EXSA9IGZhbHNlO1xuICAgIFtFTUlUVElOR19FTkRdID0gZmFsc2U7XG4gICAgW0NMT1NFRF0gPSBmYWxzZTtcbiAgICBbRU1JVFRFRF9FUlJPUl0gPSBudWxsO1xuICAgIFtCVUZGRVJMRU5HVEhdID0gMDtcbiAgICBbREVTVFJPWUVEXSA9IGZhbHNlO1xuICAgIFtTSUdOQUxdO1xuICAgIFtBQk9SVEVEXSA9IGZhbHNlO1xuICAgIFtEQVRBTElTVEVORVJTXSA9IDA7XG4gICAgW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBzdHJlYW0gY2FuIGJlIHdyaXR0ZW5cbiAgICAgKi9cbiAgICB3cml0YWJsZSA9IHRydWU7XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgc3RyZWFtIGNhbiBiZSByZWFkXG4gICAgICovXG4gICAgcmVhZGFibGUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIElmIGBSVHlwZWAgaXMgQnVmZmVyLCB0aGVuIG9wdGlvbnMgZG8gbm90IG5lZWQgdG8gYmUgcHJvdmlkZWQuXG4gICAgICogT3RoZXJ3aXNlLCBhbiBvcHRpb25zIG9iamVjdCBtdXN0IGJlIHByb3ZpZGVkIHRvIHNwZWNpZnkgZWl0aGVyXG4gICAgICoge0BsaW5rIE1pbmlwYXNzLlNoYXJlZE9wdGlvbnMub2JqZWN0TW9kZX0gb3JcbiAgICAgKiB7QGxpbmsgTWluaXBhc3MuU2hhcmVkT3B0aW9ucy5lbmNvZGluZ30sIGFzIGFwcHJvcHJpYXRlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IChhcmdzWzBdIHx8XG4gICAgICAgICAgICB7fSk7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChvcHRpb25zLm9iamVjdE1vZGUgJiYgdHlwZW9mIG9wdGlvbnMuZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmNvZGluZyBhbmQgb2JqZWN0TW9kZSBtYXkgbm90IGJlIHVzZWQgdG9nZXRoZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNPYmplY3RNb2RlT3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgICAgICAgdGhpc1tPQkpFQ1RNT0RFXSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzW0VOQ09ESU5HXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFbmNvZGluZ09wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXNbRU5DT0RJTkddID0gb3B0aW9ucy5lbmNvZGluZztcbiAgICAgICAgICAgIHRoaXNbT0JKRUNUTU9ERV0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbT0JKRUNUTU9ERV0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbRU5DT0RJTkddID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW0FTWU5DXSA9ICEhb3B0aW9ucy5hc3luYztcbiAgICAgICAgdGhpc1tERUNPREVSXSA9IHRoaXNbRU5DT0RJTkddXG4gICAgICAgICAgICA/IG5ldyBzdHJpbmdfZGVjb2Rlcl8xLlN0cmluZ0RlY29kZXIodGhpc1tFTkNPRElOR10pXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIC8vQHRzLWlnbm9yZSAtIHByaXZhdGUgb3B0aW9uIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmdcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1Z0V4cG9zZUJ1ZmZlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdidWZmZXInLCB7IGdldDogKCkgPT4gdGhpc1tCVUZGRVJdIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vQHRzLWlnbm9yZSAtIHByaXZhdGUgb3B0aW9uIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmdcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1Z0V4cG9zZVBpcGVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3BpcGVzJywgeyBnZXQ6ICgpID0+IHRoaXNbUElQRVNdIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2lnbmFsIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICB0aGlzW1NJR05BTF0gPSBzaWduYWw7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW0FCT1JUXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpc1tBQk9SVF0oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFtb3VudCBvZiBkYXRhIHN0b3JlZCBpbiB0aGUgYnVmZmVyIHdhaXRpbmcgdG8gYmUgcmVhZC5cbiAgICAgKlxuICAgICAqIEZvciBCdWZmZXIgc3RyaW5ncywgdGhpcyB3aWxsIGJlIHRoZSB0b3RhbCBieXRlIGxlbmd0aC5cbiAgICAgKiBGb3Igc3RyaW5nIGVuY29kaW5nIHN0cmVhbXMsIHRoaXMgd2lsbCBiZSB0aGUgc3RyaW5nIGNoYXJhY3RlciBsZW5ndGgsXG4gICAgICogYWNjb3JkaW5nIHRvIEphdmFTY3JpcHQncyBgc3RyaW5nLmxlbmd0aGAgbG9naWMuXG4gICAgICogRm9yIG9iamVjdE1vZGUgc3RyZWFtcywgdGhpcyBpcyBhIGNvdW50IG9mIHRoZSBpdGVtcyB3YWl0aW5nIHRvIGJlXG4gICAgICogZW1pdHRlZC5cbiAgICAgKi9cbiAgICBnZXQgYnVmZmVyTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tCVUZGRVJMRU5HVEhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYEJ1ZmZlckVuY29kaW5nYCBjdXJyZW50bHkgaW4gdXNlLCBvciBgbnVsbGBcbiAgICAgKi9cbiAgICBnZXQgZW5jb2RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0VOQ09ESU5HXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgLSBUaGlzIGlzIGEgcmVhZCBvbmx5IHByb3BlcnR5XG4gICAgICovXG4gICAgc2V0IGVuY29kaW5nKF9lbmMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGluZyBtdXN0IGJlIHNldCBhdCBpbnN0YW50aWF0aW9uIHRpbWUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgLSBFbmNvZGluZyBtYXkgb25seSBiZSBzZXQgYXQgaW5zdGFudGlhdGlvbiB0aW1lXG4gICAgICovXG4gICAgc2V0RW5jb2RpbmcoX2VuYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kaW5nIG11c3QgYmUgc2V0IGF0IGluc3RhbnRpYXRpb24gdGltZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoaXMgaXMgYW4gb2JqZWN0TW9kZSBzdHJlYW1cbiAgICAgKi9cbiAgICBnZXQgb2JqZWN0TW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbT0JKRUNUTU9ERV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIC0gVGhpcyBpcyBhIHJlYWQtb25seSBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHNldCBvYmplY3RNb2RlKF9vbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29iamVjdE1vZGUgbXVzdCBiZSBzZXQgYXQgaW5zdGFudGlhdGlvbiB0aW1lJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhpcyBpcyBhbiBhc3luYyBzdHJlYW1cbiAgICAgKi9cbiAgICBnZXQgWydhc3luYyddKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tBU1lOQ107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIG1ha2UgdGhpcyBzdHJlYW0gYXN5bmMuXG4gICAgICpcbiAgICAgKiBPbmNlIHNldCwgaXQgY2Fubm90IGJlIHVuc2V0LCBhcyB0aGlzIHdvdWxkIHBvdGVudGlhbGx5IGNhdXNlIGluY29ycmVjdFxuICAgICAqIGJlaGF2aW9yLiAgSWUsIGEgc3luYyBzdHJlYW0gY2FuIGJlIG1hZGUgYXN5bmMsIGJ1dCBhbiBhc3luYyBzdHJlYW1cbiAgICAgKiBjYW5ub3QgYmUgc2FmZWx5IG1hZGUgc3luYy5cbiAgICAgKi9cbiAgICBzZXQgWydhc3luYyddKGEpIHtcbiAgICAgICAgdGhpc1tBU1lOQ10gPSB0aGlzW0FTWU5DXSB8fCAhIWE7XG4gICAgfVxuICAgIC8vIGRyb3AgZXZlcnl0aGluZyBhbmQgZ2V0IG91dCBvZiB0aGUgZmxvdyBjb21wbGV0ZWx5XG4gICAgW0FCT1JUXSgpIHtcbiAgICAgICAgdGhpc1tBQk9SVEVEXSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnYWJvcnQnLCB0aGlzW1NJR05BTF0/LnJlYXNvbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSh0aGlzW1NJR05BTF0/LnJlYXNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIHN0cmVhbSBoYXMgYmVlbiBhYm9ydGVkLlxuICAgICAqL1xuICAgIGdldCBhYm9ydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tBQk9SVEVEXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm8tb3Agc2V0dGVyLiBTdHJlYW0gYWJvcnRlZCBzdGF0dXMgaXMgc2V0IHZpYSB0aGUgQWJvcnRTaWduYWwgcHJvdmlkZWRcbiAgICAgKiBpbiB0aGUgY29uc3RydWN0b3Igb3B0aW9ucy5cbiAgICAgKi9cbiAgICBzZXQgYWJvcnRlZChfKSB7IH1cbiAgICB3cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIGlmICh0aGlzW0FCT1JURURdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpc1tFT0ZdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgICAgICAgaWYgKHRoaXNbREVTVFJPWUVEXSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdDYW5ub3QgY2FsbCB3cml0ZSBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJyksIHsgY29kZTogJ0VSUl9TVFJFQU1fREVTVFJPWUVEJyB9KSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGVuY29kaW5nO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbmNvZGluZylcbiAgICAgICAgICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgICAgICBjb25zdCBmbiA9IHRoaXNbQVNZTkNdID8gZGVmZXIgOiBub2RlZmVyO1xuICAgICAgICAvLyBjb252ZXJ0IGFycmF5IGJ1ZmZlcnMgYW5kIHR5cGVkIGFycmF5IHZpZXdzIGludG8gYnVmZmVyc1xuICAgICAgICAvLyBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUsIHdlIG1heSB3YW50IHRvIGRvIHRoZSBvcHBvc2l0ZSFcbiAgICAgICAgLy8gbGVhdmUgc3RyaW5ncyBhbmQgYnVmZmVycyBhcy1pc1xuICAgICAgICAvLyBhbnl0aGluZyBpcyBvbmx5IGFsbG93ZWQgaWYgaW4gb2JqZWN0IG1vZGUsIHNvIHRocm93XG4gICAgICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KGNodW5rKSkge1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZSAtIHNpbmZ1bCB1bnNhZmUgdHlwZSBjaGFuZ2luZ1xuICAgICAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmsuYnVmZmVyLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlCdWZmZXJMaWtlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZSAtIHNpbmZ1bCB1bnNhZmUgdHlwZSBjaGFuZ2luZ1xuICAgICAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLWNvbnRpZ3VvdXMgZGF0YSB3cml0dGVuIHRvIG5vbi1vYmplY3RNb2RlIHN0cmVhbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBvYmplY3QgbW9kZSB1cCBmcm9udCwgc2luY2UgaXQncyBzaW1wbGVyXG4gICAgICAgIC8vIHRoaXMgeWllbGRzIGJldHRlciBwZXJmb3JtYW5jZSwgZmV3ZXIgY2hlY2tzIGxhdGVyLlxuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSkge1xuICAgICAgICAgICAgLy8gbWF5YmUgaW1wb3NzaWJsZT9cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHRoaXNbRkxPV0lOR10gJiYgdGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICAgICAgICAgIHRoaXNbRkxVU0hdKHRydWUpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIGlmICh0aGlzW0ZMT1dJTkddKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUlBVU0hdKGNodW5rKTtcbiAgICAgICAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgICAgICAgaWYgKGNiKVxuICAgICAgICAgICAgICAgIGZuKGNiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0ZMT1dJTkddO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIGNodW5rIGlzIGEgYnVmZmVyIG9yIHN0cmluZ1xuICAgICAgICAvLyBkb24ndCBidWZmZXIgaXQgdXAgb3Igc2VuZCBpdCB0byB0aGUgZGVjb2RlclxuICAgICAgICBpZiAoIWNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICAgICAgZm4oY2IpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbRkxPV0lOR107XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFzdC1wYXRoIHdyaXRpbmcgc3RyaW5ncyBvZiBzYW1lIGVuY29kaW5nIHRvIGEgc3RyZWFtIHdpdGhcbiAgICAgICAgLy8gYW4gZW1wdHkgYnVmZmVyLCBza2lwcGluZyB0aGUgYnVmZmVyL2RlY29kZXIgZGFuY2VcbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIC8vIHVubGVzcyBpdCBpcyBhIHN0cmluZyBhbHJlYWR5IHJlYWR5IGZvciB1cyB0byB1c2VcbiAgICAgICAgICAgICEoZW5jb2RpbmcgPT09IHRoaXNbRU5DT0RJTkddICYmICF0aGlzW0RFQ09ERVJdPy5sYXN0TmVlZCkpIHtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZSAtIHNpbmZ1bCB1bnNhZmUgdHlwZSBjaGFuZ2VcbiAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0aGlzW0VOQ09ESU5HXSkge1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlIC0gc2luZnVsIHVuc2FmZSB0eXBlIGNoYW5nZVxuICAgICAgICAgICAgY2h1bmsgPSB0aGlzW0RFQ09ERVJdLndyaXRlKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBmbHVzaGluZyBDQU4gcG90ZW50aWFsbHkgc3dpdGNoIHVzIGludG8gbm90LWZsb3dpbmcgbW9kZVxuICAgICAgICBpZiAodGhpc1tGTE9XSU5HXSAmJiB0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgICAgICB0aGlzW0ZMVVNIXSh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXNbRkxPV0lOR10pXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSUFVTSF0oY2h1bmspO1xuICAgICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICBmbihjYik7XG4gICAgICAgIHJldHVybiB0aGlzW0ZMT1dJTkddO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb3ctbGV2ZWwgZXhwbGljaXQgcmVhZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBJbiBvYmplY3RNb2RlLCB0aGUgYXJndW1lbnQgaXMgaWdub3JlZCwgYW5kIG9uZSBpdGVtIGlzIHJldHVybmVkIGlmXG4gICAgICogYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogYG5gIGlzIHRoZSBudW1iZXIgb2YgYnl0ZXMgKG9yIGluIHRoZSBjYXNlIG9mIGVuY29kaW5nIHN0cmVhbXMsXG4gICAgICogY2hhcmFjdGVycykgdG8gY29uc3VtZS4gSWYgYG5gIGlzIG5vdCBwcm92aWRlZCwgdGhlbiB0aGUgZW50aXJlIGJ1ZmZlclxuICAgICAqIGlzIHJldHVybmVkLCBvciBgbnVsbGAgaXMgcmV0dXJuZWQgaWYgbm8gZGF0YSBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBJZiBgbmAgaXMgZ3JlYXRlciB0aGF0IHRoZSBhbW91bnQgb2YgZGF0YSBpbiB0aGUgaW50ZXJuYWwgYnVmZmVyLFxuICAgICAqIHRoZW4gYG51bGxgIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIHJlYWQobikge1xuICAgICAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdID09PSAwIHx8XG4gICAgICAgICAgICBuID09PSAwIHx8XG4gICAgICAgICAgICAobiAmJiBuID4gdGhpc1tCVUZGRVJMRU5HVEhdKSkge1xuICAgICAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICAgICAgbiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzW0JVRkZFUl0ubGVuZ3RoID4gMSAmJiAhdGhpc1tPQkpFQ1RNT0RFXSkge1xuICAgICAgICAgICAgLy8gbm90IG9iamVjdCBtb2RlLCBzbyBpZiB3ZSBoYXZlIGFuIGVuY29kaW5nLCB0aGVuIFJUeXBlIGlzIHN0cmluZ1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBtdXN0IGJlIEJ1ZmZlclxuICAgICAgICAgICAgdGhpc1tCVUZGRVJdID0gW1xuICAgICAgICAgICAgICAgICh0aGlzW0VOQ09ESU5HXVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXNbQlVGRkVSXS5qb2luKCcnKVxuICAgICAgICAgICAgICAgICAgICA6IEJ1ZmZlci5jb25jYXQodGhpc1tCVUZGRVJdLCB0aGlzW0JVRkZFUkxFTkdUSF0pKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gdGhpc1tSRUFEXShuIHx8IG51bGwsIHRoaXNbQlVGRkVSXVswXSk7XG4gICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIFtSRUFEXShuLCBjaHVuaykge1xuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSU0hJRlRdKCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYyA9IGNodW5rO1xuICAgICAgICAgICAgaWYgKG4gPT09IGMubGVuZ3RoIHx8IG4gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJTSElGVF0oKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSXVswXSA9IGMuc2xpY2Uobik7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjLnNsaWNlKDAsIG4pO1xuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJdWzBdID0gYy5zdWJhcnJheShuKTtcbiAgICAgICAgICAgICAgICBjaHVuayA9IGMuc3ViYXJyYXkoMCwgbik7XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IG47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICBpZiAoIXRoaXNbQlVGRkVSXS5sZW5ndGggJiYgIXRoaXNbRU9GXSlcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cbiAgICBlbmQoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGNodW5rO1xuICAgICAgICAgICAgY2h1bmsgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBlbmNvZGluZztcbiAgICAgICAgICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVuayAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIGNiKTtcbiAgICAgICAgdGhpc1tFT0ZdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlbid0IHdyaXR0ZW4gYW55dGhpbmcsIHRoZW4gZ28gYWhlYWQgYW5kIGVtaXQsXG4gICAgICAgIC8vIGV2ZW4gaWYgd2UncmUgbm90IHJlYWRpbmcuXG4gICAgICAgIC8vIHdlJ2xsIHJlLWVtaXQgaWYgYSBuZXcgJ2VuZCcgbGlzdGVuZXIgaXMgYWRkZWQgYW55d2F5LlxuICAgICAgICAvLyBUaGlzIG1ha2VzIE1QIG1vcmUgc3VpdGFibGUgdG8gd3JpdGUtb25seSB1c2UgY2FzZXMuXG4gICAgICAgIGlmICh0aGlzW0ZMT1dJTkddIHx8ICF0aGlzW1BBVVNFRF0pXG4gICAgICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZG9uJ3QgbGV0IHRoZSBpbnRlcm5hbCByZXN1bWUgYmUgb3ZlcndyaXR0ZW5cbiAgICBbUkVTVU1FXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzW0RBVEFMSVNURU5FUlNdICYmICF0aGlzW1BJUEVTXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tQQVVTRURdID0gZmFsc2U7XG4gICAgICAgIHRoaXNbRkxPV0lOR10gPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xuICAgICAgICBpZiAodGhpc1tCVUZGRVJdLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXNbRkxVU0hdKCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXNbRU9GXSlcbiAgICAgICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdW1lIHRoZSBzdHJlYW0gaWYgaXQgaXMgY3VycmVudGx5IGluIGEgcGF1c2VkIHN0YXRlXG4gICAgICpcbiAgICAgKiBJZiBjYWxsZWQgd2hlbiB0aGVyZSBhcmUgbm8gcGlwZSBkZXN0aW5hdGlvbnMgb3IgYGRhdGFgIGV2ZW50IGxpc3RlbmVycyxcbiAgICAgKiB0aGlzIHdpbGwgcGxhY2UgdGhlIHN0cmVhbSBpbiBhIFwiZGlzY2FyZGVkXCIgc3RhdGUsIHdoZXJlIGFsbCBkYXRhIHdpbGxcbiAgICAgKiBiZSB0aHJvd24gYXdheS4gVGhlIGRpc2NhcmRlZCBzdGF0ZSBpcyByZW1vdmVkIGlmIGEgcGlwZSBkZXN0aW5hdGlvbiBvclxuICAgICAqIGRhdGEgaGFuZGxlciBpcyBhZGRlZCwgaWYgcGF1c2UoKSBpcyBjYWxsZWQsIG9yIGlmIGFueSBzeW5jaHJvbm91cyBvclxuICAgICAqIGFzeW5jaHJvbm91cyBpdGVyYXRpb24gaXMgc3RhcnRlZC5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW1JFU1VNRV0oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIHN0cmVhbVxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2U7XG4gICAgICAgIHRoaXNbUEFVU0VEXSA9IHRydWU7XG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBzdHJlYW0gaGFzIGJlZW4gZm9yY2libHkgZGVzdHJveWVkXG4gICAgICovXG4gICAgZ2V0IGRlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbREVTVFJPWUVEXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBpbiBhIGZsb3dpbmcgc3RhdGUsIG1lYW5pbmcgdGhhdFxuICAgICAqIGFueSB3cml0ZXMgd2lsbCBiZSBpbW1lZGlhdGVseSBlbWl0dGVkLlxuICAgICAqL1xuICAgIGdldCBmbG93aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tGTE9XSU5HXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBpbiBhIHBhdXNlZCBzdGF0ZVxuICAgICAqL1xuICAgIGdldCBwYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW1BBVVNFRF07XG4gICAgfVxuICAgIFtCVUZGRVJQVVNIXShjaHVuaykge1xuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSArPSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB0aGlzW0JVRkZFUl0ucHVzaChjaHVuayk7XG4gICAgfVxuICAgIFtCVUZGRVJTSElGVF0oKSB7XG4gICAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSB0aGlzW0JVRkZFUl1bMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpc1tCVUZGRVJdLnNoaWZ0KCk7XG4gICAgfVxuICAgIFtGTFVTSF0obm9EcmFpbiA9IGZhbHNlKSB7XG4gICAgICAgIGRvIHsgfSB3aGlsZSAodGhpc1tGTFVTSENIVU5LXSh0aGlzW0JVRkZFUlNISUZUXSgpKSAmJlxuICAgICAgICAgICAgdGhpc1tCVUZGRVJdLmxlbmd0aCk7XG4gICAgICAgIGlmICghbm9EcmFpbiAmJiAhdGhpc1tCVUZGRVJdLmxlbmd0aCAmJiAhdGhpc1tFT0ZdKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICAgIH1cbiAgICBbRkxVU0hDSFVOS10oY2h1bmspIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICByZXR1cm4gdGhpc1tGTE9XSU5HXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGlwZSBhbGwgZGF0YSBlbWl0dGVkIGJ5IHRoaXMgc3RyZWFtIGludG8gdGhlIGRlc3RpbmF0aW9uIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogVHJpZ2dlcnMgdGhlIGZsb3cgb2YgZGF0YS5cbiAgICAgKi9cbiAgICBwaXBlKGRlc3QsIG9wdHMpIHtcbiAgICAgICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZW5kZWQgPSB0aGlzW0VNSVRURURfRU5EXTtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIGlmIChkZXN0ID09PSBwcm9jLnN0ZG91dCB8fCBkZXN0ID09PSBwcm9jLnN0ZGVycilcbiAgICAgICAgICAgIG9wdHMuZW5kID0gZmFsc2U7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9wdHMuZW5kID0gb3B0cy5lbmQgIT09IGZhbHNlO1xuICAgICAgICBvcHRzLnByb3h5RXJyb3JzID0gISFvcHRzLnByb3h5RXJyb3JzO1xuICAgICAgICAvLyBwaXBpbmcgYW4gZW5kZWQgc3RyZWFtIGVuZHMgaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKGVuZGVkKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5lbmQpXG4gICAgICAgICAgICAgICAgZGVzdC5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFwiYXNcIiBoZXJlIGp1c3QgaWdub3JlcyB0aGUgV1R5cGUsIHdoaWNoIHBpcGVzIGRvbid0IGNhcmUgYWJvdXQsXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5J3JlIG9ubHkgY29uc3VtaW5nIGZyb20gdXMsIGFuZCB3cml0aW5nIHRvIHRoZSBkZXN0XG4gICAgICAgICAgICB0aGlzW1BJUEVTXS5wdXNoKCFvcHRzLnByb3h5RXJyb3JzXG4gICAgICAgICAgICAgICAgPyBuZXcgUGlwZSh0aGlzLCBkZXN0LCBvcHRzKVxuICAgICAgICAgICAgICAgIDogbmV3IFBpcGVQcm94eUVycm9ycyh0aGlzLCBkZXN0LCBvcHRzKSk7XG4gICAgICAgICAgICBpZiAodGhpc1tBU1lOQ10pXG4gICAgICAgICAgICAgICAgZGVmZXIoKCkgPT4gdGhpc1tSRVNVTUVdKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXNbUkVTVU1FXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdWxseSB1bmhvb2sgYSBwaXBlZCBkZXN0aW5hdGlvbiBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZGVzdGluYXRpb24gc3RyZWFtIHdhcyB0aGUgb25seSBjb25zdW1lciBvZiB0aGlzIHN0cmVhbSAoaWUsXG4gICAgICogdGhlcmUgYXJlIG5vIG90aGVyIHBpcGVkIGRlc3RpbmF0aW9ucyBvciBgJ2RhdGEnYCBldmVudCBsaXN0ZW5lcnMpXG4gICAgICogdGhlbiB0aGUgZmxvdyBvZiBkYXRhIHdpbGwgc3RvcCB1bnRpbCB0aGVyZSBpcyBhbm90aGVyIGNvbnN1bWVyIG9yXG4gICAgICoge0BsaW5rIE1pbmlwYXNzI3Jlc3VtZX0gaXMgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICovXG4gICAgdW5waXBlKGRlc3QpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXNbUElQRVNdLmZpbmQocCA9PiBwLmRlc3QgPT09IGRlc3QpO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbUElQRVNdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW0ZMT1dJTkddICYmIHRoaXNbREFUQUxJU1RFTkVSU10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW1BJUEVTXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXNbUElQRVNdLnNwbGljZSh0aGlzW1BJUEVTXS5pbmRleE9mKHApLCAxKTtcbiAgICAgICAgICAgIHAudW5waXBlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBNaW5pcGFzcyNvbn1cbiAgICAgKi9cbiAgICBhZGRMaXN0ZW5lcihldiwgaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vbihldiwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vc3RseSBpZGVudGljYWwgdG8gYEV2ZW50RW1pdHRlci5vbmAsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgICAqIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRvIHByZXZlbnQgZGF0YSBsb3NzIGFuZCB1bm5lY2Vzc2FyeSBoYW5nczpcbiAgICAgKlxuICAgICAqIC0gQWRkaW5nIGEgJ2RhdGEnIGV2ZW50IGhhbmRsZXIgd2lsbCB0cmlnZ2VyIHRoZSBmbG93IG9mIGRhdGFcbiAgICAgKlxuICAgICAqIC0gQWRkaW5nIGEgJ3JlYWRhYmxlJyBldmVudCBoYW5kbGVyIHdoZW4gdGhlcmUgaXMgZGF0YSB3YWl0aW5nIHRvIGJlIHJlYWRcbiAgICAgKiAgIHdpbGwgY2F1c2UgJ3JlYWRhYmxlJyB0byBiZSBlbWl0dGVkIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogLSBBZGRpbmcgYW4gJ2VuZGlzaCcgZXZlbnQgaGFuZGxlciAoJ2VuZCcsICdmaW5pc2gnLCBldGMuKSB3aGljaCBoYXNcbiAgICAgKiAgIGFscmVhZHkgcGFzc2VkIHdpbGwgY2F1c2UgdGhlIGV2ZW50IHRvIGJlIGVtaXR0ZWQgaW1tZWRpYXRlbHkgYW5kIGFsbFxuICAgICAqICAgaGFuZGxlcnMgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIC0gQWRkaW5nIGFuICdlcnJvcicgZXZlbnQgaGFuZGxlciBhZnRlciBhbiBlcnJvciBoYXMgYmVlbiBlbWl0dGVkIHdpbGxcbiAgICAgKiAgIGNhdXNlIHRoZSBldmVudCB0byBiZSByZS1lbWl0dGVkIGltbWVkaWF0ZWx5IHdpdGggdGhlIGVycm9yIHByZXZpb3VzbHlcbiAgICAgKiAgIHJhaXNlZC5cbiAgICAgKi9cbiAgICBvbihldiwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCByZXQgPSBzdXBlci5vbihldiwgaGFuZGxlcik7XG4gICAgICAgIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbREFUQUxJU1RFTkVSU10rKztcbiAgICAgICAgICAgIGlmICghdGhpc1tQSVBFU10ubGVuZ3RoICYmICF0aGlzW0ZMT1dJTkddKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tSRVNVTUVdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgdGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKSB7XG4gICAgICAgICAgICBzdXBlci5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRW5kaXNoKGV2KSAmJiB0aGlzW0VNSVRURURfRU5EXSkge1xuICAgICAgICAgICAgc3VwZXIuZW1pdChldik7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdlcnJvcicgJiYgdGhpc1tFTUlUVEVEX0VSUk9SXSkge1xuICAgICAgICAgICAgY29uc3QgaCA9IGhhbmRsZXI7XG4gICAgICAgICAgICBpZiAodGhpc1tBU1lOQ10pXG4gICAgICAgICAgICAgICAgZGVmZXIoKCkgPT4gaC5jYWxsKHRoaXMsIHRoaXNbRU1JVFRFRF9FUlJPUl0pKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBoLmNhbGwodGhpcywgdGhpc1tFTUlUVEVEX0VSUk9SXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBNaW5pcGFzcyNvZmZ9XG4gICAgICovXG4gICAgcmVtb3ZlTGlzdGVuZXIoZXYsIGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2LCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9zdGx5IGlkZW50aWNhbCB0byBgRXZlbnRFbWl0dGVyLm9mZmBcbiAgICAgKlxuICAgICAqIElmIGEgJ2RhdGEnIGV2ZW50IGhhbmRsZXIgaXMgcmVtb3ZlZCwgYW5kIGl0IHdhcyB0aGUgbGFzdCBjb25zdW1lclxuICAgICAqIChpZSwgdGhlcmUgYXJlIG5vIHBpcGUgZGVzdGluYXRpb25zIG9yIG90aGVyICdkYXRhJyBldmVudCBsaXN0ZW5lcnMpLFxuICAgICAqIHRoZW4gdGhlIGZsb3cgb2YgZGF0YSB3aWxsIHN0b3AgdW50aWwgdGhlcmUgaXMgYW5vdGhlciBjb25zdW1lciBvclxuICAgICAqIHtAbGluayBNaW5pcGFzcyNyZXN1bWV9IGlzIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqL1xuICAgIG9mZihldiwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCByZXQgPSBzdXBlci5vZmYoZXYsIGhhbmRsZXIpO1xuICAgICAgICAvLyBpZiB3ZSBwcmV2aW91c2x5IGhhZCBsaXN0ZW5lcnMsIGFuZCBub3cgd2UgZG9uJ3QsIGFuZCB3ZSBkb24ndFxuICAgICAgICAvLyBoYXZlIGFueSBwaXBlcywgdGhlbiBzdG9wIHRoZSBmbG93LCB1bmxlc3MgaXQncyBiZWVuIGV4cGxpY2l0bHlcbiAgICAgICAgLy8gcHV0IGluIGEgZGlzY2FyZGVkIGZsb3dpbmcgc3RhdGUgdmlhIHN0cmVhbS5yZXN1bWUoKS5cbiAgICAgICAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHRoaXNbREFUQUxJU1RFTkVSU10gPSB0aGlzLmxpc3RlbmVycygnZGF0YScpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzW0RBVEFMSVNURU5FUlNdID09PSAwICYmXG4gICAgICAgICAgICAgICAgIXRoaXNbRElTQ0FSREVEXSAmJlxuICAgICAgICAgICAgICAgICF0aGlzW1BJUEVTXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9zdGx5IGlkZW50aWNhbCB0byBgRXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVyc2BcbiAgICAgKlxuICAgICAqIElmIGFsbCAnZGF0YScgZXZlbnQgaGFuZGxlcnMgYXJlIHJlbW92ZWQsIGFuZCB0aGV5IHdlcmUgdGhlIGxhc3QgY29uc3VtZXJcbiAgICAgKiAoaWUsIHRoZXJlIGFyZSBubyBwaXBlIGRlc3RpbmF0aW9ucyksIHRoZW4gdGhlIGZsb3cgb2YgZGF0YSB3aWxsIHN0b3BcbiAgICAgKiB1bnRpbCB0aGVyZSBpcyBhbm90aGVyIGNvbnN1bWVyIG9yIHtAbGluayBNaW5pcGFzcyNyZXN1bWV9IGlzIGV4cGxpY2l0bHlcbiAgICAgKiBjYWxsZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2KSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycyhldik7XG4gICAgICAgIGlmIChldiA9PT0gJ2RhdGEnIHx8IGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXNbREFUQUxJU1RFTkVSU10gPSAwO1xuICAgICAgICAgICAgaWYgKCF0aGlzW0RJU0NBUkRFRF0gJiYgIXRoaXNbUElQRVNdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXNbRkxPV0lOR10gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSAnZW5kJyBldmVudCBoYXMgYmVlbiBlbWl0dGVkXG4gICAgICovXG4gICAgZ2V0IGVtaXR0ZWRFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0VNSVRURURfRU5EXTtcbiAgICB9XG4gICAgW01BWUJFX0VNSVRfRU5EXSgpIHtcbiAgICAgICAgaWYgKCF0aGlzW0VNSVRUSU5HX0VORF0gJiZcbiAgICAgICAgICAgICF0aGlzW0VNSVRURURfRU5EXSAmJlxuICAgICAgICAgICAgIXRoaXNbREVTVFJPWUVEXSAmJlxuICAgICAgICAgICAgdGhpc1tCVUZGRVJdLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpc1tFT0ZdKSB7XG4gICAgICAgICAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJlZmluaXNoJyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgICAgaWYgKHRoaXNbQ0xPU0VEXSlcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgICAgICAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3N0bHkgaWRlbnRpY2FsIHRvIGBFdmVudEVtaXR0ZXIuZW1pdGAsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgICAqIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRvIHByZXZlbnQgZGF0YSBsb3NzIGFuZCB1bm5lY2Vzc2FyeSBoYW5nczpcbiAgICAgKlxuICAgICAqIElmIHRoZSBzdHJlYW0gaGFzIGJlZW4gZGVzdHJveWVkLCBhbmQgdGhlIGV2ZW50IGlzIHNvbWV0aGluZyBvdGhlclxuICAgICAqIHRoYW4gJ2Nsb3NlJyBvciAnZXJyb3InLCB0aGVuIGBmYWxzZWAgaXMgcmV0dXJuZWQgYW5kIG5vIGhhbmRsZXJzXG4gICAgICogYXJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBldmVudCBpcyAnZW5kJywgYW5kIGhhcyBhbHJlYWR5IGJlZW4gZW1pdHRlZCwgdGhlbiB0aGUgZXZlbnRcbiAgICAgKiBpcyBpZ25vcmVkLiBJZiB0aGUgc3RyZWFtIGlzIGluIGEgcGF1c2VkIG9yIG5vbi1mbG93aW5nIHN0YXRlLCB0aGVuXG4gICAgICogdGhlIGV2ZW50IHdpbGwgYmUgZGVmZXJyZWQgdW50aWwgZGF0YSBmbG93IHJlc3VtZXMuIElmIHRoZSBzdHJlYW0gaXNcbiAgICAgKiBhc3luYywgdGhlbiBoYW5kbGVycyB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgbmV4dCB0aWNrIHJhdGhlciB0aGFuXG4gICAgICogaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgJ2Nsb3NlJywgYW5kICdlbmQnIGhhcyBub3QgeWV0IGJlZW4gZW1pdHRlZCwgdGhlblxuICAgICAqIHRoZSBldmVudCB3aWxsIGJlIGRlZmVycmVkIHVudGlsIGFmdGVyICdlbmQnIGlzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgJ2Vycm9yJywgYW5kIGFuIEFib3J0U2lnbmFsIHdhcyBwcm92aWRlZCBmb3IgdGhlIHN0cmVhbSxcbiAgICAgKiBhbmQgdGhlcmUgYXJlIG5vIGxpc3RlbmVycywgdGhlbiB0aGUgZXZlbnQgaXMgaWdub3JlZCwgbWF0Y2hpbmcgdGhlXG4gICAgICogYmVoYXZpb3Igb2Ygbm9kZSBjb3JlIHN0cmVhbXMgaW4gdGhlIHByZXNlbnNlIG9mIGFuIEFib3J0U2lnbmFsLlxuICAgICAqXG4gICAgICogSWYgdGhlIGV2ZW50IGlzICdmaW5pc2gnIG9yICdwcmVmaW5pc2gnLCB0aGVuIGFsbCBsaXN0ZW5lcnMgd2lsbCBiZVxuICAgICAqIHJlbW92ZWQgYWZ0ZXIgZW1pdHRpbmcgdGhlIGV2ZW50LCB0byBwcmV2ZW50IGRvdWJsZS1maXJpbmcuXG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBkYXRhID0gYXJnc1swXTtcbiAgICAgICAgLy8gZXJyb3IgYW5kIGNsb3NlIGFyZSBvbmx5IGV2ZW50cyBhbGxvd2VkIGFmdGVyIGNhbGxpbmcgZGVzdHJveSgpXG4gICAgICAgIGlmIChldiAhPT0gJ2Vycm9yJyAmJlxuICAgICAgICAgICAgZXYgIT09ICdjbG9zZScgJiZcbiAgICAgICAgICAgIGV2ICE9PSBERVNUUk9ZRUQgJiZcbiAgICAgICAgICAgIHRoaXNbREVTVFJPWUVEXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpc1tPQkpFQ1RNT0RFXSAmJiAhZGF0YVxuICAgICAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXNbQVNZTkNdXG4gICAgICAgICAgICAgICAgICAgID8gKGRlZmVyKCgpID0+IHRoaXNbRU1JVERBVEFdKGRhdGEpKSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzW0VNSVREQVRBXShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0VNSVRFTkRdKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdjbG9zZScpIHtcbiAgICAgICAgICAgIHRoaXNbQ0xPU0VEXSA9IHRydWU7XG4gICAgICAgICAgICAvLyBkb24ndCBlbWl0IGNsb3NlIGJlZm9yZSAnZW5kJyBhbmQgJ2ZpbmlzaCdcbiAgICAgICAgICAgIGlmICghdGhpc1tFTUlUVEVEX0VORF0gJiYgIXRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdjbG9zZScpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICB0aGlzW0VNSVRURURfRVJST1JdID0gZGF0YTtcbiAgICAgICAgICAgIHN1cGVyLmVtaXQoRVJST1IsIGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gIXRoaXNbU0lHTkFMXSB8fCB0aGlzLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IHN1cGVyLmVtaXQoJ2Vycm9yJywgZGF0YSlcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdyZXN1bWUnKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdyZXN1bWUnKTtcbiAgICAgICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnZmluaXNoJyB8fCBldiA9PT0gJ3ByZWZpbmlzaCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoZXYpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIG90aGVyIHVua25vd24gZXZlbnRcbiAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIFtFTUlUREFUQV0oZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpc1tQSVBFU10pIHtcbiAgICAgICAgICAgIGlmIChwLmRlc3Qud3JpdGUoZGF0YSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB0aGlzW0RJU0NBUkRFRF0gPyBmYWxzZSA6IHN1cGVyLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgW0VNSVRFTkRdKCkge1xuICAgICAgICBpZiAodGhpc1tFTUlUVEVEX0VORF0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXNbRU1JVFRFRF9FTkRdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpc1tBU1lOQ11cbiAgICAgICAgICAgID8gKGRlZmVyKCgpID0+IHRoaXNbRU1JVEVORDJdKCkpLCB0cnVlKVxuICAgICAgICAgICAgOiB0aGlzW0VNSVRFTkQyXSgpO1xuICAgIH1cbiAgICBbRU1JVEVORDJdKCkge1xuICAgICAgICBpZiAodGhpc1tERUNPREVSXSkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXNbREVDT0RFUl0uZW5kKCk7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzW1BJUEVTXSkge1xuICAgICAgICAgICAgICAgICAgICBwLmRlc3Qud3JpdGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpc1tESVNDQVJERURdKVxuICAgICAgICAgICAgICAgICAgICBzdXBlci5lbWl0KCdkYXRhJywgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXNbUElQRVNdKSB7XG4gICAgICAgICAgICBwLmVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ2VuZCcpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnZW5kJyk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBhbGwgZW1pdHRlZCBkYXRhIG9uY2VcbiAgICAgKiB0aGUgc3RyZWFtIGVuZHMuXG4gICAgICovXG4gICAgYXN5bmMgY29sbGVjdCgpIHtcbiAgICAgICAgY29uc3QgYnVmID0gT2JqZWN0LmFzc2lnbihbXSwge1xuICAgICAgICAgICAgZGF0YUxlbmd0aDogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgIGJ1Zi5kYXRhTGVuZ3RoID0gMDtcbiAgICAgICAgLy8gc2V0IHRoZSBwcm9taXNlIGZpcnN0LCBpbiBjYXNlIGFuIGVycm9yIGlzIHJhaXNlZFxuICAgICAgICAvLyBieSB0cmlnZ2VyaW5nIHRoZSBmbG93IGhlcmUuXG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnByb21pc2UoKTtcbiAgICAgICAgdGhpcy5vbignZGF0YScsIGMgPT4ge1xuICAgICAgICAgICAgYnVmLnB1c2goYyk7XG4gICAgICAgICAgICBpZiAoIXRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgICAgICAgICAgYnVmLmRhdGFMZW5ndGggKz0gYy5sZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBwO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGVtaXR0ZWQgZGF0YVxuICAgICAqIG9uY2UgdGhlIHN0cmVhbSBlbmRzLlxuICAgICAqXG4gICAgICogTm90IGFsbG93ZWQgb24gb2JqZWN0TW9kZSBzdHJlYW1zLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbmNhdCgpIHtcbiAgICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNvbmNhdCBpbiBvYmplY3RNb2RlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmID0gYXdhaXQgdGhpcy5jb2xsZWN0KCk7XG4gICAgICAgIHJldHVybiAodGhpc1tFTkNPRElOR11cbiAgICAgICAgICAgID8gYnVmLmpvaW4oJycpXG4gICAgICAgICAgICA6IEJ1ZmZlci5jb25jYXQoYnVmLCBidWYuZGF0YUxlbmd0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB2b2lkIFByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIHRoZSBzdHJlYW0gZW5kcy5cbiAgICAgKi9cbiAgICBhc3luYyBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbihERVNUUk9ZRUQsICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ3N0cmVhbSBkZXN0cm95ZWQnKSkpO1xuICAgICAgICAgICAgdGhpcy5vbignZXJyb3InLCBlciA9PiByZWplY3QoZXIpKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2VuZCcsICgpID0+IHJlc29sdmUoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXMgYGZvciBhd2FpdCBvZmAgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGNvbnRpbnVlIGVtaXR0aW5nIGFsbCBjaHVua3MgdW50aWwgdGhlIHN0cmVhbSB0ZXJtaW5hdGVzLlxuICAgICAqL1xuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIC8vIHNldCB0aGlzIHVwIGZyb250LCBpbiBjYXNlIHRoZSBjb25zdW1lciBkb2Vzbid0IGNhbGwgbmV4dCgpXG4gICAgICAgIC8vIHJpZ2h0IGF3YXkuXG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzdG9wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RvcHBlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcCgpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gdGhpcy5yZWFkKCk7XG4gICAgICAgICAgICBpZiAocmVzICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiBmYWxzZSwgdmFsdWU6IHJlcyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzW0VPRl0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICAgICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICAgICAgbGV0IHJlamVjdDtcbiAgICAgICAgICAgIGNvbnN0IG9uZXJyID0gKGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2RhdGEnLCBvbmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoREVTVFJPWUVELCBvbmRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9uZGF0YSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdlcnJvcicsIG9uZXJyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZW5kJywgb25lbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKERFU1RST1lFRCwgb25kZXN0cm95KTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHZhbHVlLCBkb25lOiAhIXRoaXNbRU9GXSB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvbmVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZXJyb3InLCBvbmVycik7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2RhdGEnLCBvbmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKERFU1RST1lFRCwgb25kZXN0cm95KTtcbiAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb25kZXN0cm95ID0gKCkgPT4gb25lcnIobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCA9IHJlajtcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShERVNUUk9ZRUQsIG9uZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKCdlcnJvcicsIG9uZXJyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2RhdGEnLCBvbmRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgdGhyb3c6IHN0b3AsXG4gICAgICAgICAgICByZXR1cm46IHN0b3AsXG4gICAgICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXMgYGZvciBvZmAgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGl0ZXJhdGlvbiB3aWxsIHRlcm1pbmF0ZSB3aGVuIHRoZSBpbnRlcm5hbCBidWZmZXIgcnVucyBvdXQsIGV2ZW5cbiAgICAgKiBpZiB0aGUgc3RyZWFtIGhhcyBub3QgeWV0IHRlcm1pbmF0ZWQuXG4gICAgICovXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIC8vIHNldCB0aGlzIHVwIGZyb250LCBpbiBjYXNlIHRoZSBjb25zdW1lciBkb2Vzbid0IGNhbGwgbmV4dCgpXG4gICAgICAgIC8vIHJpZ2h0IGF3YXkuXG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5vZmYoRVJST1IsIHN0b3ApO1xuICAgICAgICAgICAgdGhpcy5vZmYoREVTVFJPWUVELCBzdG9wKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdlbmQnLCBzdG9wKTtcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0b3BwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWFkKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBzdG9wKCkgOiB7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIHN0b3ApO1xuICAgICAgICB0aGlzLm9uY2UoRVJST1IsIHN0b3ApO1xuICAgICAgICB0aGlzLm9uY2UoREVTVFJPWUVELCBzdG9wKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICB0aHJvdzogc3RvcCxcbiAgICAgICAgICAgIHJldHVybjogc3RvcCxcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBhIHN0cmVhbSwgcHJldmVudGluZyBpdCBmcm9tIGJlaW5nIHVzZWQgZm9yIGFueSBmdXJ0aGVyIHB1cnBvc2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc3RyZWFtIGhhcyBhIGBjbG9zZSgpYCBtZXRob2QsIHRoZW4gaXQgd2lsbCBiZSBjYWxsZWQgb25cbiAgICAgKiBkZXN0cnVjdGlvbi5cbiAgICAgKlxuICAgICAqIEFmdGVyIGRlc3RydWN0aW9uLCBhbnkgYXR0ZW1wdCB0byB3cml0ZSBkYXRhLCByZWFkIGRhdGEsIG9yIGVtaXQgbW9zdFxuICAgICAqIGV2ZW50cyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBlcnJvciBhcmd1bWVudCBpcyBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIGJlIGVtaXR0ZWQgaW4gYW5cbiAgICAgKiAnZXJyb3InIGV2ZW50LlxuICAgICAqL1xuICAgIGRlc3Ryb3koZXIpIHtcbiAgICAgICAgaWYgKHRoaXNbREVTVFJPWUVEXSkge1xuICAgICAgICAgICAgaWYgKGVyKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KERFU1RST1lFRCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzW0RFU1RST1lFRF0gPSB0cnVlO1xuICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSB0cnVlO1xuICAgICAgICAvLyB0aHJvdyBhd2F5IGFsbCBidWZmZXJlZCBkYXRhLCBpdCdzIG5ldmVyIGNvbWluZyBvdXRcbiAgICAgICAgdGhpc1tCVUZGRVJdLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSA9IDA7XG4gICAgICAgIGNvbnN0IHdjID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiB3Yy5jbG9zZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpc1tDTE9TRURdKVxuICAgICAgICAgICAgd2MuY2xvc2UoKTtcbiAgICAgICAgaWYgKGVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgLy8gaWYgbm8gZXJyb3IgdG8gZW1pdCwgc3RpbGwgcmVqZWN0IHBlbmRpbmcgcHJvbWlzZXNcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lbWl0KERFU1RST1lFRCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIGlzU3RyZWFtfVxuICAgICAqXG4gICAgICogRm9ybWVyIGV4cG9ydCBsb2NhdGlvbiwgbWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgaXNTdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmlzU3RyZWFtO1xuICAgIH1cbn1cbmV4cG9ydHMuTWluaXBhc3MgPSBNaW5pcGFzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJNaW5pcGFzcyIsImlzV3JpdGFibGUiLCJpc1JlYWRhYmxlIiwiaXNTdHJlYW0iLCJwcm9jIiwicHJvY2VzcyIsInN0ZG91dCIsInN0ZGVyciIsImV2ZW50c18xIiwicmVxdWlyZSIsInN0cmVhbV8xIiwic3RyaW5nX2RlY29kZXJfMSIsInMiLCJkZWZhdWx0IiwiRXZlbnRFbWl0dGVyIiwicGlwZSIsIldyaXRhYmxlIiwicHJvdG90eXBlIiwid3JpdGUiLCJlbmQiLCJFT0YiLCJTeW1ib2wiLCJNQVlCRV9FTUlUX0VORCIsIkVNSVRURURfRU5EIiwiRU1JVFRJTkdfRU5EIiwiRU1JVFRFRF9FUlJPUiIsIkNMT1NFRCIsIlJFQUQiLCJGTFVTSCIsIkZMVVNIQ0hVTksiLCJFTkNPRElORyIsIkRFQ09ERVIiLCJGTE9XSU5HIiwiUEFVU0VEIiwiUkVTVU1FIiwiQlVGRkVSIiwiUElQRVMiLCJCVUZGRVJMRU5HVEgiLCJCVUZGRVJQVVNIIiwiQlVGRkVSU0hJRlQiLCJPQkpFQ1RNT0RFIiwiREVTVFJPWUVEIiwiRVJST1IiLCJFTUlUREFUQSIsIkVNSVRFTkQiLCJFTUlURU5EMiIsIkFTWU5DIiwiQUJPUlQiLCJBQk9SVEVEIiwiU0lHTkFMIiwiREFUQUxJU1RFTkVSUyIsIkRJU0NBUkRFRCIsImRlZmVyIiwiZm4iLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJub2RlZmVyIiwiaXNFbmRpc2giLCJldiIsImlzQXJyYXlCdWZmZXJMaWtlIiwiYiIsIkFycmF5QnVmZmVyIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiYnl0ZUxlbmd0aCIsImlzQXJyYXlCdWZmZXJWaWV3IiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJpc1ZpZXciLCJQaXBlIiwic3JjIiwiZGVzdCIsIm9wdHMiLCJvbmRyYWluIiwib24iLCJ1bnBpcGUiLCJyZW1vdmVMaXN0ZW5lciIsInByb3h5RXJyb3JzIiwiX2VyIiwiUGlwZVByb3h5RXJyb3JzIiwiZXIiLCJlbWl0IiwiaXNPYmplY3RNb2RlT3B0aW9ucyIsIm8iLCJvYmplY3RNb2RlIiwiaXNFbmNvZGluZ09wdGlvbnMiLCJlbmNvZGluZyIsImFyZ3MiLCJvcHRpb25zIiwid3JpdGFibGUiLCJyZWFkYWJsZSIsIlR5cGVFcnJvciIsImFzeW5jIiwiU3RyaW5nRGVjb2RlciIsImRlYnVnRXhwb3NlQnVmZmVyIiwiZ2V0IiwiZGVidWdFeHBvc2VQaXBlcyIsInNpZ25hbCIsImFib3J0ZWQiLCJhZGRFdmVudExpc3RlbmVyIiwiYnVmZmVyTGVuZ3RoIiwiX2VuYyIsIkVycm9yIiwic2V0RW5jb2RpbmciLCJfb20iLCJhIiwicmVhc29uIiwiZGVzdHJveSIsIl8iLCJjaHVuayIsImNiIiwiYXNzaWduIiwiY29kZSIsImZyb20iLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwibGVuZ3RoIiwibGFzdE5lZWQiLCJyZWFkIiwibiIsImpvaW4iLCJjb25jYXQiLCJyZXQiLCJjIiwic2xpY2UiLCJzdWJhcnJheSIsInVuZGVmaW5lZCIsIm9uY2UiLCJyZXN1bWUiLCJwYXVzZSIsImRlc3Ryb3llZCIsImZsb3dpbmciLCJwYXVzZWQiLCJwdXNoIiwic2hpZnQiLCJub0RyYWluIiwiZW5kZWQiLCJwIiwiZmluZCIsInNwbGljZSIsImluZGV4T2YiLCJhZGRMaXN0ZW5lciIsImhhbmRsZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJoIiwiY2FsbCIsIm9mZiIsImxpc3RlbmVycyIsImVtaXR0ZWRFbmQiLCJkYXRhIiwiY29sbGVjdCIsImJ1ZiIsImRhdGFMZW5ndGgiLCJwcm9taXNlIiwicmVqZWN0IiwiYXN5bmNJdGVyYXRvciIsInN0b3BwZWQiLCJzdG9wIiwiZG9uZSIsIm5leHQiLCJyZXMiLCJvbmVyciIsIm9uZGF0YSIsIm9uZW5kIiwib25kZXN0cm95IiwicmVqIiwidGhyb3ciLCJyZXR1cm4iLCJpdGVyYXRvciIsIndjIiwiY2xvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/minipass/dist/commonjs/index.js\n");

/***/ })

};
;