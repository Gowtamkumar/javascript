"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/path-scurry";
exports.ids = ["vendor-chunks/path-scurry"];
exports.modules = {

/***/ "(rsc)/./node_modules/path-scurry/dist/cjs/index.js":
/*!****************************************************!*\
  !*** ./node_modules/path-scurry/dist/cjs/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n        desc = {\n            enumerable: true,\n            get: function() {\n                return m[k];\n            }\n        };\n    }\n    Object.defineProperty(o, k2, desc);\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = void 0;\nconst lru_cache_1 = __webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/lru-cache/dist/commonjs/index.js\");\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst actualFS = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst realpathSync = fs_1.realpathSync.native;\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nconst promises_1 = __webpack_require__(/*! fs/promises */ \"fs/promises\");\nconst minipass_1 = __webpack_require__(/*! minipass */ \"(rsc)/./node_modules/minipass/dist/commonjs/index.js\");\nconst defaultFS = {\n    lstatSync: fs_1.lstatSync,\n    readdir: fs_1.readdir,\n    readdirSync: fs_1.readdirSync,\n    readlinkSync: fs_1.readlinkSync,\n    realpathSync,\n    promises: {\n        lstat: promises_1.lstat,\n        readdir: promises_1.readdir,\n        readlink: promises_1.readlink,\n        realpath: promises_1.realpath\n    }\n};\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption)=>!fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {\n        ...defaultFS,\n        ...fsOption,\n        promises: {\n            ...defaultFS.promises,\n            ...fsOption.promises || {}\n        }\n    };\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i;\nconst uncToDrive = (rootPath)=>rootPath.replace(/\\//g, \"\\\\\").replace(uncDriveRegexp, \"$1\\\\\");\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/;\nconst UNKNOWN = 0; // may not even exist, for all we know\nconst IFIFO = 1;\nconst IFCHR = 2;\nconst IFDIR = 4;\nconst IFBLK = 6;\nconst IFREG = 8;\nconst IFLNK = 10;\nconst IFSOCK = 12;\nconst IFMT = 15;\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT;\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 16;\n// set after a successful lstat()\nconst LSTAT_CALLED = 32;\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 64;\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 128;\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 256;\n// set if we know realpath() will fail\nconst ENOREALPATH = 512;\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;\nconst TYPEMASK = 1023;\nconst entToType = (s)=>s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;\n// normalize unicode path names\nconst normalizeCache = new Map();\nconst normalize = (s)=>{\n    const c = normalizeCache.get(s);\n    if (c) return c;\n    const n = s.normalize(\"NFKD\");\n    normalizeCache.set(s, n);\n    return n;\n};\nconst normalizeNocaseCache = new Map();\nconst normalizeNocase = (s)=>{\n    const c = normalizeNocaseCache.get(s);\n    if (c) return c;\n    const n = normalize(s.toLowerCase());\n    normalizeNocaseCache.set(s, n);\n    return n;\n};\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */ class ResolveCache extends lru_cache_1.LRUCache {\n    constructor(){\n        super({\n            max: 256\n        });\n    }\n}\nexports.ResolveCache = ResolveCache;\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n/**\n * an LRUCache for storing child entries.\n * @internal\n */ class ChildrenCache extends lru_cache_1.LRUCache {\n    constructor(maxSize = 16 * 1024){\n        super({\n            maxSize,\n            // parent + children\n            sizeCalculation: (a)=>a.length + 1\n        });\n    }\n}\nexports.ChildrenCache = ChildrenCache;\nconst setAsCwd = Symbol(\"PathScurry setAsCwd\");\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */ class PathBase {\n    // potential default fs override\n    #fs;\n    // Stats fields\n    #dev;\n    get dev() {\n        return this.#dev;\n    }\n    #mode;\n    get mode() {\n        return this.#mode;\n    }\n    #nlink;\n    get nlink() {\n        return this.#nlink;\n    }\n    #uid;\n    get uid() {\n        return this.#uid;\n    }\n    #gid;\n    get gid() {\n        return this.#gid;\n    }\n    #rdev;\n    get rdev() {\n        return this.#rdev;\n    }\n    #blksize;\n    get blksize() {\n        return this.#blksize;\n    }\n    #ino;\n    get ino() {\n        return this.#ino;\n    }\n    #size;\n    get size() {\n        return this.#size;\n    }\n    #blocks;\n    get blocks() {\n        return this.#blocks;\n    }\n    #atimeMs;\n    get atimeMs() {\n        return this.#atimeMs;\n    }\n    #mtimeMs;\n    get mtimeMs() {\n        return this.#mtimeMs;\n    }\n    #ctimeMs;\n    get ctimeMs() {\n        return this.#ctimeMs;\n    }\n    #birthtimeMs;\n    get birthtimeMs() {\n        return this.#birthtimeMs;\n    }\n    #atime;\n    get atime() {\n        return this.#atime;\n    }\n    #mtime;\n    get mtime() {\n        return this.#mtime;\n    }\n    #ctime;\n    get ctime() {\n        return this.#ctime;\n    }\n    #birthtime;\n    get birthtime() {\n        return this.#birthtime;\n    }\n    #matchName;\n    #depth;\n    #fullpath;\n    #fullpathPosix;\n    #relative;\n    #relativePosix;\n    #type;\n    #children;\n    #linkTarget;\n    #realpath;\n    /**\n     * This property is for compatibility with the Dirent class as of\n     * Node v20, where Dirent['path'] refers to the path of the directory\n     * that was passed to readdir.  So, somewhat counterintuitively, this\n     * property refers to the *parent* path, not the path object itself.\n     * For root entries, it's the path to the entry itself.\n     */ get path() {\n        return (this.parent || this).fullpath();\n    }\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */ constructor(name, type = UNKNOWN, root, roots, nocase, children, opts){\n        this.#onReaddirCB = [];\n        this.#readdirCBInFlight = false;\n        this.name = name;\n        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);\n        this.#type = type & TYPEMASK;\n        this.nocase = nocase;\n        this.roots = roots;\n        this.root = root || this;\n        this.#children = children;\n        this.#fullpath = opts.fullpath;\n        this.#relative = opts.relative;\n        this.#relativePosix = opts.relativePosix;\n        this.parent = opts.parent;\n        if (this.parent) {\n            this.#fs = this.parent.#fs;\n        } else {\n            this.#fs = fsFromOption(opts.fs);\n        }\n    }\n    /**\n     * Returns the depth of the Path object from its root.\n     *\n     * For example, a path at `/foo/bar` would have a depth of 2.\n     */ depth() {\n        if (this.#depth !== undefined) return this.#depth;\n        if (!this.parent) return this.#depth = 0;\n        return this.#depth = this.parent.depth() + 1;\n    }\n    /**\n     * @internal\n     */ childrenCache() {\n        return this.#children;\n    }\n    /**\n     * Get the Path object referenced by the string path, resolved from this Path\n     */ resolve(path) {\n        if (!path) {\n            return this;\n        }\n        const rootPath = this.getRootString(path);\n        const dir = path.substring(rootPath.length);\n        const dirParts = dir.split(this.splitSep);\n        const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);\n        return result;\n    }\n    #resolveParts(dirParts) {\n        let p = this;\n        for (const part of dirParts){\n            p = p.child(part);\n        }\n        return p;\n    }\n    /**\n     * Returns the cached children Path objects, if still available.  If they\n     * have fallen out of the cache, then returns an empty array, and resets the\n     * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n     * lookup.\n     *\n     * @internal\n     */ children() {\n        const cached = this.#children.get(this);\n        if (cached) {\n            return cached;\n        }\n        const children = Object.assign([], {\n            provisional: 0\n        });\n        this.#children.set(this, children);\n        this.#type &= ~READDIR_CALLED;\n        return children;\n    }\n    /**\n     * Resolves a path portion and returns or creates the child Path.\n     *\n     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n     * `'..'`.\n     *\n     * This should not be called directly.  If `pathPart` contains any path\n     * separators, it will lead to unsafe undefined behavior.\n     *\n     * Use `Path.resolve()` instead.\n     *\n     * @internal\n     */ child(pathPart, opts) {\n        if (pathPart === \"\" || pathPart === \".\") {\n            return this;\n        }\n        if (pathPart === \"..\") {\n            return this.parent || this;\n        }\n        // find the child\n        const children = this.children();\n        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);\n        for (const p of children){\n            if (p.#matchName === name) {\n                return p;\n            }\n        }\n        // didn't find it, create provisional child, since it might not\n        // actually exist.  If we know the parent isn't a dir, then\n        // in fact it CAN'T exist.\n        const s = this.parent ? this.sep : \"\";\n        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;\n        const pchild = this.newChild(pathPart, UNKNOWN, {\n            ...opts,\n            parent: this,\n            fullpath\n        });\n        if (!this.canReaddir()) {\n            pchild.#type |= ENOENT;\n        }\n        // don't have to update provisional, because if we have real children,\n        // then provisional is set to children.length, otherwise a lower number\n        children.push(pchild);\n        return pchild;\n    }\n    /**\n     * The relative path from the cwd. If it does not share an ancestor with\n     * the cwd, then this ends up being equivalent to the fullpath()\n     */ relative() {\n        if (this.#relative !== undefined) {\n            return this.#relative;\n        }\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return this.#relative = this.name;\n        }\n        const pv = p.relative();\n        return pv + (!pv || !p.parent ? \"\" : this.sep) + name;\n    }\n    /**\n     * The relative path from the cwd, using / as the path separator.\n     * If it does not share an ancestor with\n     * the cwd, then this ends up being equivalent to the fullpathPosix()\n     * On posix systems, this is identical to relative().\n     */ relativePosix() {\n        if (this.sep === \"/\") return this.relative();\n        if (this.#relativePosix !== undefined) return this.#relativePosix;\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return this.#relativePosix = this.fullpathPosix();\n        }\n        const pv = p.relativePosix();\n        return pv + (!pv || !p.parent ? \"\" : \"/\") + name;\n    }\n    /**\n     * The fully resolved path string for this Path entry\n     */ fullpath() {\n        if (this.#fullpath !== undefined) {\n            return this.#fullpath;\n        }\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return this.#fullpath = this.name;\n        }\n        const pv = p.fullpath();\n        const fp = pv + (!p.parent ? \"\" : this.sep) + name;\n        return this.#fullpath = fp;\n    }\n    /**\n     * On platforms other than windows, this is identical to fullpath.\n     *\n     * On windows, this is overridden to return the forward-slash form of the\n     * full UNC path.\n     */ fullpathPosix() {\n        if (this.#fullpathPosix !== undefined) return this.#fullpathPosix;\n        if (this.sep === \"/\") return this.#fullpathPosix = this.fullpath();\n        if (!this.parent) {\n            const p = this.fullpath().replace(/\\\\/g, \"/\");\n            if (/^[a-z]:\\//i.test(p)) {\n                return this.#fullpathPosix = `//?/${p}`;\n            } else {\n                return this.#fullpathPosix = p;\n            }\n        }\n        const p = this.parent;\n        const pfpp = p.fullpathPosix();\n        const fpp = pfpp + (!pfpp || !p.parent ? \"\" : \"/\") + this.name;\n        return this.#fullpathPosix = fpp;\n    }\n    /**\n     * Is the Path of an unknown type?\n     *\n     * Note that we might know *something* about it if there has been a previous\n     * filesystem operation, for example that it does not exist, or is not a\n     * link, or whether it has child entries.\n     */ isUnknown() {\n        return (this.#type & IFMT) === UNKNOWN;\n    }\n    isType(type) {\n        return this[`is${type}`]();\n    }\n    getType() {\n        return this.isUnknown() ? \"Unknown\" : this.isDirectory() ? \"Directory\" : this.isFile() ? \"File\" : this.isSymbolicLink() ? \"SymbolicLink\" : this.isFIFO() ? \"FIFO\" : this.isCharacterDevice() ? \"CharacterDevice\" : this.isBlockDevice() ? \"BlockDevice\" : /* c8 ignore start */ this.isSocket() ? \"Socket\" : \"Unknown\";\n    /* c8 ignore stop */ }\n    /**\n     * Is the Path a regular file?\n     */ isFile() {\n        return (this.#type & IFMT) === IFREG;\n    }\n    /**\n     * Is the Path a directory?\n     */ isDirectory() {\n        return (this.#type & IFMT) === IFDIR;\n    }\n    /**\n     * Is the path a character device?\n     */ isCharacterDevice() {\n        return (this.#type & IFMT) === IFCHR;\n    }\n    /**\n     * Is the path a block device?\n     */ isBlockDevice() {\n        return (this.#type & IFMT) === IFBLK;\n    }\n    /**\n     * Is the path a FIFO pipe?\n     */ isFIFO() {\n        return (this.#type & IFMT) === IFIFO;\n    }\n    /**\n     * Is the path a socket?\n     */ isSocket() {\n        return (this.#type & IFMT) === IFSOCK;\n    }\n    /**\n     * Is the path a symbolic link?\n     */ isSymbolicLink() {\n        return (this.#type & IFLNK) === IFLNK;\n    }\n    /**\n     * Return the entry if it has been subject of a successful lstat, or\n     * undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* simply\n     * mean that we haven't called lstat on it.\n     */ lstatCached() {\n        return this.#type & LSTAT_CALLED ? this : undefined;\n    }\n    /**\n     * Return the cached link target if the entry has been the subject of a\n     * successful readlink, or undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * readlink() has been called at some point.\n     */ readlinkCached() {\n        return this.#linkTarget;\n    }\n    /**\n     * Returns the cached realpath target if the entry has been the subject\n     * of a successful realpath, or undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * realpath() has been called at some point.\n     */ realpathCached() {\n        return this.#realpath;\n    }\n    /**\n     * Returns the cached child Path entries array if the entry has been the\n     * subject of a successful readdir(), or [] otherwise.\n     *\n     * Does not read the filesystem, so an empty array *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * readdir() has been called recently enough to still be valid.\n     */ readdirCached() {\n        const children = this.children();\n        return children.slice(0, children.provisional);\n    }\n    /**\n     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n     * any indication that readlink will definitely fail.\n     *\n     * Returns false if the path is known to not be a symlink, if a previous\n     * readlink failed, or if the entry does not exist.\n     */ canReadlink() {\n        if (this.#linkTarget) return true;\n        if (!this.parent) return false;\n        // cases where it cannot possibly succeed\n        const ifmt = this.#type & IFMT;\n        return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);\n    }\n    /**\n     * Return true if readdir has previously been successfully called on this\n     * path, indicating that cachedReaddir() is likely valid.\n     */ calledReaddir() {\n        return !!(this.#type & READDIR_CALLED);\n    }\n    /**\n     * Returns true if the path is known to not exist. That is, a previous lstat\n     * or readdir failed to verify its existence when that would have been\n     * expected, or a parent entry was marked either enoent or enotdir.\n     */ isENOENT() {\n        return !!(this.#type & ENOENT);\n    }\n    /**\n     * Return true if the path is a match for the given path name.  This handles\n     * case sensitivity and unicode normalization.\n     *\n     * Note: even on case-sensitive systems, it is **not** safe to test the\n     * equality of the `.name` property to determine whether a given pathname\n     * matches, due to unicode normalization mismatches.\n     *\n     * Always use this method instead of testing the `path.name` property\n     * directly.\n     */ isNamed(n) {\n        return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);\n    }\n    /**\n     * Return the Path object corresponding to the target of a symbolic link.\n     *\n     * If the Path is not a symbolic link, or if the readlink call fails for any\n     * reason, `undefined` is returned.\n     *\n     * Result is cached, and thus may be outdated if the filesystem is mutated.\n     */ async readlink() {\n        const target = this.#linkTarget;\n        if (target) {\n            return target;\n        }\n        if (!this.canReadlink()) {\n            return undefined;\n        }\n        /* c8 ignore start */ // already covered by the canReadlink test, here for ts grumples\n        if (!this.parent) {\n            return undefined;\n        }\n        /* c8 ignore stop */ try {\n            const read = await this.#fs.promises.readlink(this.fullpath());\n            const linkTarget = this.parent.resolve(read);\n            if (linkTarget) {\n                return this.#linkTarget = linkTarget;\n            }\n        } catch (er) {\n            this.#readlinkFail(er.code);\n            return undefined;\n        }\n    }\n    /**\n     * Synchronous {@link PathBase.readlink}\n     */ readlinkSync() {\n        const target = this.#linkTarget;\n        if (target) {\n            return target;\n        }\n        if (!this.canReadlink()) {\n            return undefined;\n        }\n        /* c8 ignore start */ // already covered by the canReadlink test, here for ts grumples\n        if (!this.parent) {\n            return undefined;\n        }\n        /* c8 ignore stop */ try {\n            const read = this.#fs.readlinkSync(this.fullpath());\n            const linkTarget = this.parent.resolve(read);\n            if (linkTarget) {\n                return this.#linkTarget = linkTarget;\n            }\n        } catch (er) {\n            this.#readlinkFail(er.code);\n            return undefined;\n        }\n    }\n    #readdirSuccess(children) {\n        // succeeded, mark readdir called bit\n        this.#type |= READDIR_CALLED;\n        // mark all remaining provisional children as ENOENT\n        for(let p = children.provisional; p < children.length; p++){\n            children[p].#markENOENT();\n        }\n    }\n    #markENOENT() {\n        // mark as UNKNOWN and ENOENT\n        if (this.#type & ENOENT) return;\n        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;\n        this.#markChildrenENOENT();\n    }\n    #markChildrenENOENT() {\n        // all children are provisional and do not exist\n        const children = this.children();\n        children.provisional = 0;\n        for (const p of children){\n            p.#markENOENT();\n        }\n    }\n    #markENOREALPATH() {\n        this.#type |= ENOREALPATH;\n        this.#markENOTDIR();\n    }\n    // save the information when we know the entry is not a dir\n    #markENOTDIR() {\n        // entry is not a directory, so any children can't exist.\n        // this *should* be impossible, since any children created\n        // after it's been marked ENOTDIR should be marked ENOENT,\n        // so it won't even get to this point.\n        /* c8 ignore start */ if (this.#type & ENOTDIR) return;\n        /* c8 ignore stop */ let t = this.#type;\n        // this could happen if we stat a dir, then delete it,\n        // then try to read it or one of its children.\n        if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN;\n        this.#type = t | ENOTDIR;\n        this.#markChildrenENOENT();\n    }\n    #readdirFail(code = \"\") {\n        // markENOTDIR and markENOENT also set provisional=0\n        if (code === \"ENOTDIR\" || code === \"EPERM\") {\n            this.#markENOTDIR();\n        } else if (code === \"ENOENT\") {\n            this.#markENOENT();\n        } else {\n            this.children().provisional = 0;\n        }\n    }\n    #lstatFail(code = \"\") {\n        // Windows just raises ENOENT in this case, disable for win CI\n        /* c8 ignore start */ if (code === \"ENOTDIR\") {\n            // already know it has a parent by this point\n            const p = this.parent;\n            p.#markENOTDIR();\n        } else if (code === \"ENOENT\") {\n            /* c8 ignore stop */ this.#markENOENT();\n        }\n    }\n    #readlinkFail(code = \"\") {\n        let ter = this.#type;\n        ter |= ENOREADLINK;\n        if (code === \"ENOENT\") ter |= ENOENT;\n        // windows gets a weird error when you try to readlink a file\n        if (code === \"EINVAL\" || code === \"UNKNOWN\") {\n            // exists, but not a symlink, we don't know WHAT it is, so remove\n            // all IFMT bits.\n            ter &= IFMT_UNKNOWN;\n        }\n        this.#type = ter;\n        // windows just gets ENOENT in this case.  We do cover the case,\n        // just disabled because it's impossible on Windows CI\n        /* c8 ignore start */ if (code === \"ENOTDIR\" && this.parent) {\n            this.parent.#markENOTDIR();\n        }\n    /* c8 ignore stop */ }\n    #readdirAddChild(e, c) {\n        return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);\n    }\n    #readdirAddNewChild(e, c) {\n        // alloc new entry at head, so it's never provisional\n        const type = entToType(e);\n        const child = this.newChild(e.name, type, {\n            parent: this\n        });\n        const ifmt = child.#type & IFMT;\n        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n            child.#type |= ENOTDIR;\n        }\n        c.unshift(child);\n        c.provisional++;\n        return child;\n    }\n    #readdirMaybePromoteChild(e, c) {\n        for(let p = c.provisional; p < c.length; p++){\n            const pchild = c[p];\n            const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);\n            if (name !== pchild.#matchName) {\n                continue;\n            }\n            return this.#readdirPromoteChild(e, pchild, p, c);\n        }\n    }\n    #readdirPromoteChild(e, p, index, c) {\n        const v = p.name;\n        // retain any other flags, but set ifmt from dirent\n        p.#type = p.#type & IFMT_UNKNOWN | entToType(e);\n        // case sensitivity fixing when we learn the true name.\n        if (v !== e.name) p.name = e.name;\n        // just advance provisional index (potentially off the list),\n        // otherwise we have to splice/pop it out and re-insert at head\n        if (index !== c.provisional) {\n            if (index === c.length - 1) c.pop();\n            else c.splice(index, 1);\n            c.unshift(p);\n        }\n        c.provisional++;\n        return p;\n    }\n    /**\n     * Call lstat() on this Path, and update all known information that can be\n     * determined.\n     *\n     * Note that unlike `fs.lstat()`, the returned value does not contain some\n     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n     * information is required, you will need to call `fs.lstat` yourself.\n     *\n     * If the Path refers to a nonexistent file, or if the lstat call fails for\n     * any reason, `undefined` is returned.  Otherwise the updated Path object is\n     * returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */ async lstat() {\n        if ((this.#type & ENOENT) === 0) {\n            try {\n                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));\n                return this;\n            } catch (er) {\n                this.#lstatFail(er.code);\n            }\n        }\n    }\n    /**\n     * synchronous {@link PathBase.lstat}\n     */ lstatSync() {\n        if ((this.#type & ENOENT) === 0) {\n            try {\n                this.#applyStat(this.#fs.lstatSync(this.fullpath()));\n                return this;\n            } catch (er) {\n                this.#lstatFail(er.code);\n            }\n        }\n    }\n    #applyStat(st) {\n        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;\n        this.#atime = atime;\n        this.#atimeMs = atimeMs;\n        this.#birthtime = birthtime;\n        this.#birthtimeMs = birthtimeMs;\n        this.#blksize = blksize;\n        this.#blocks = blocks;\n        this.#ctime = ctime;\n        this.#ctimeMs = ctimeMs;\n        this.#dev = dev;\n        this.#gid = gid;\n        this.#ino = ino;\n        this.#mode = mode;\n        this.#mtime = mtime;\n        this.#mtimeMs = mtimeMs;\n        this.#nlink = nlink;\n        this.#rdev = rdev;\n        this.#size = size;\n        this.#uid = uid;\n        const ifmt = entToType(st);\n        // retain any other flags, but set the ifmt\n        this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;\n        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n            this.#type |= ENOTDIR;\n        }\n    }\n    #onReaddirCB;\n    #readdirCBInFlight;\n    #callOnReaddirCB(children) {\n        this.#readdirCBInFlight = false;\n        const cbs = this.#onReaddirCB.slice();\n        this.#onReaddirCB.length = 0;\n        cbs.forEach((cb)=>cb(null, children));\n    }\n    /**\n     * Standard node-style callback interface to get list of directory entries.\n     *\n     * If the Path cannot or does not contain any children, then an empty array\n     * is returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     *\n     * @param cb The callback called with (er, entries).  Note that the `er`\n     * param is somewhat extraneous, as all readdir() errors are handled and\n     * simply result in an empty set of entries being returned.\n     * @param allowZalgo Boolean indicating that immediately known results should\n     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n     * zalgo at your peril, the dark pony lord is devious and unforgiving.\n     */ readdirCB(cb, allowZalgo = false) {\n        if (!this.canReaddir()) {\n            if (allowZalgo) cb(null, []);\n            else queueMicrotask(()=>cb(null, []));\n            return;\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            const c = children.slice(0, children.provisional);\n            if (allowZalgo) cb(null, c);\n            else queueMicrotask(()=>cb(null, c));\n            return;\n        }\n        // don't have to worry about zalgo at this point.\n        this.#onReaddirCB.push(cb);\n        if (this.#readdirCBInFlight) {\n            return;\n        }\n        this.#readdirCBInFlight = true;\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        this.#fs.readdir(fullpath, {\n            withFileTypes: true\n        }, (er, entries)=>{\n            if (er) {\n                this.#readdirFail(er.code);\n                children.provisional = 0;\n            } else {\n                // if we didn't get an error, we always get entries.\n                //@ts-ignore\n                for (const e of entries){\n                    this.#readdirAddChild(e, children);\n                }\n                this.#readdirSuccess(children);\n            }\n            this.#callOnReaddirCB(children.slice(0, children.provisional));\n            return;\n        });\n    }\n    #asyncReaddirInFlight;\n    /**\n     * Return an array of known child entries.\n     *\n     * If the Path cannot or does not contain any children, then an empty array\n     * is returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */ async readdir() {\n        if (!this.canReaddir()) {\n            return [];\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            return children.slice(0, children.provisional);\n        }\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        if (this.#asyncReaddirInFlight) {\n            await this.#asyncReaddirInFlight;\n        } else {\n            /* c8 ignore start */ let resolve = ()=>{};\n            /* c8 ignore stop */ this.#asyncReaddirInFlight = new Promise((res)=>resolve = res);\n            try {\n                for (const e of (await this.#fs.promises.readdir(fullpath, {\n                    withFileTypes: true\n                }))){\n                    this.#readdirAddChild(e, children);\n                }\n                this.#readdirSuccess(children);\n            } catch (er) {\n                this.#readdirFail(er.code);\n                children.provisional = 0;\n            }\n            this.#asyncReaddirInFlight = undefined;\n            resolve();\n        }\n        return children.slice(0, children.provisional);\n    }\n    /**\n     * synchronous {@link PathBase.readdir}\n     */ readdirSync() {\n        if (!this.canReaddir()) {\n            return [];\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            return children.slice(0, children.provisional);\n        }\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        try {\n            for (const e of this.#fs.readdirSync(fullpath, {\n                withFileTypes: true\n            })){\n                this.#readdirAddChild(e, children);\n            }\n            this.#readdirSuccess(children);\n        } catch (er) {\n            this.#readdirFail(er.code);\n            children.provisional = 0;\n        }\n        return children.slice(0, children.provisional);\n    }\n    canReaddir() {\n        if (this.#type & ENOCHILD) return false;\n        const ifmt = IFMT & this.#type;\n        // we always set ENOTDIR when setting IFMT, so should be impossible\n        /* c8 ignore start */ if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n            return false;\n        }\n        /* c8 ignore stop */ return true;\n    }\n    shouldWalk(dirs, walkFilter) {\n        return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));\n    }\n    /**\n     * Return the Path object corresponding to path as resolved\n     * by realpath(3).\n     *\n     * If the realpath call fails for any reason, `undefined` is returned.\n     *\n     * Result is cached, and thus may be outdated if the filesystem is mutated.\n     * On success, returns a Path object.\n     */ async realpath() {\n        if (this.#realpath) return this.#realpath;\n        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined;\n        try {\n            const rp = await this.#fs.promises.realpath(this.fullpath());\n            return this.#realpath = this.resolve(rp);\n        } catch (_) {\n            this.#markENOREALPATH();\n        }\n    }\n    /**\n     * Synchronous {@link realpath}\n     */ realpathSync() {\n        if (this.#realpath) return this.#realpath;\n        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined;\n        try {\n            const rp = this.#fs.realpathSync(this.fullpath());\n            return this.#realpath = this.resolve(rp);\n        } catch (_) {\n            this.#markENOREALPATH();\n        }\n    }\n    /**\n     * Internal method to mark this Path object as the scurry cwd,\n     * called by {@link PathScurry#chdir}\n     *\n     * @internal\n     */ [setAsCwd](oldCwd) {\n        if (oldCwd === this) return;\n        const changed = new Set([]);\n        let rp = [];\n        let p = this;\n        while(p && p.parent){\n            changed.add(p);\n            p.#relative = rp.join(this.sep);\n            p.#relativePosix = rp.join(\"/\");\n            p = p.parent;\n            rp.push(\"..\");\n        }\n        // now un-memoize parents of old cwd\n        p = oldCwd;\n        while(p && p.parent && !changed.has(p)){\n            p.#relative = undefined;\n            p.#relativePosix = undefined;\n            p = p.parent;\n        }\n    }\n}\nexports.PathBase = PathBase;\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */ class PathWin32 extends PathBase {\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */ constructor(name, type = UNKNOWN, root, roots, nocase, children, opts){\n        super(name, type, root, roots, nocase, children, opts);\n        /**\n     * Separator for generating path strings.\n     */ this.sep = \"\\\\\";\n        /**\n     * Separator for parsing path strings.\n     */ this.splitSep = eitherSep;\n    }\n    /**\n     * @internal\n     */ newChild(name, type = UNKNOWN, opts = {}) {\n        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n    }\n    /**\n     * @internal\n     */ getRootString(path) {\n        return path_1.win32.parse(path).root;\n    }\n    /**\n     * @internal\n     */ getRoot(rootPath) {\n        rootPath = uncToDrive(rootPath.toUpperCase());\n        if (rootPath === this.root.name) {\n            return this.root;\n        }\n        // ok, not that one, check if it matches another we know about\n        for (const [compare, root] of Object.entries(this.roots)){\n            if (this.sameRoot(rootPath, compare)) {\n                return this.roots[rootPath] = root;\n            }\n        }\n        // otherwise, have to create a new one.\n        return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;\n    }\n    /**\n     * @internal\n     */ sameRoot(rootPath, compare = this.root.name) {\n        // windows can (rarely) have case-sensitive filesystem, but\n        // UNC and drive letters are always case-insensitive, and canonically\n        // represented uppercase.\n        rootPath = rootPath.toUpperCase().replace(/\\//g, \"\\\\\").replace(uncDriveRegexp, \"$1\\\\\");\n        return rootPath === compare;\n    }\n}\nexports.PathWin32 = PathWin32;\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */ class PathPosix extends PathBase {\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */ constructor(name, type = UNKNOWN, root, roots, nocase, children, opts){\n        super(name, type, root, roots, nocase, children, opts);\n        /**\n     * separator for parsing path strings\n     */ this.splitSep = \"/\";\n        /**\n     * separator for generating path strings\n     */ this.sep = \"/\";\n    }\n    /**\n     * @internal\n     */ getRootString(path) {\n        return path.startsWith(\"/\") ? \"/\" : \"\";\n    }\n    /**\n     * @internal\n     */ getRoot(_rootPath) {\n        return this.root;\n    }\n    /**\n     * @internal\n     */ newChild(name, type = UNKNOWN, opts = {}) {\n        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n    }\n}\nexports.PathPosix = PathPosix;\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */ class PathScurryBase {\n    #resolveCache;\n    #resolvePosixCache;\n    #children;\n    #fs;\n    /**\n     * This class should not be instantiated directly.\n     *\n     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n     *\n     * @internal\n     */ constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS } = {}){\n        this.#fs = fsFromOption(fs);\n        if (cwd instanceof URL || cwd.startsWith(\"file://\")) {\n            cwd = (0, url_1.fileURLToPath)(cwd);\n        }\n        // resolve and split root, and then add to the store.\n        // this is the only time we call path.resolve()\n        const cwdPath = pathImpl.resolve(cwd);\n        this.roots = Object.create(null);\n        this.rootPath = this.parseRootPath(cwdPath);\n        this.#resolveCache = new ResolveCache();\n        this.#resolvePosixCache = new ResolveCache();\n        this.#children = new ChildrenCache(childrenCacheSize);\n        const split = cwdPath.substring(this.rootPath.length).split(sep);\n        // resolve('/') leaves '', splits to [''], we don't want that.\n        if (split.length === 1 && !split[0]) {\n            split.pop();\n        }\n        /* c8 ignore start */ if (nocase === undefined) {\n            throw new TypeError(\"must provide nocase setting to PathScurryBase ctor\");\n        }\n        /* c8 ignore stop */ this.nocase = nocase;\n        this.root = this.newRoot(this.#fs);\n        this.roots[this.rootPath] = this.root;\n        let prev = this.root;\n        let len = split.length - 1;\n        const joinSep = pathImpl.sep;\n        let abs = this.rootPath;\n        let sawFirst = false;\n        for (const part of split){\n            const l = len--;\n            prev = prev.child(part, {\n                relative: new Array(l).fill(\"..\").join(joinSep),\n                relativePosix: new Array(l).fill(\"..\").join(\"/\"),\n                fullpath: abs += (sawFirst ? \"\" : joinSep) + part\n            });\n            sawFirst = true;\n        }\n        this.cwd = prev;\n    }\n    /**\n     * Get the depth of a provided path, string, or the cwd\n     */ depth(path = this.cwd) {\n        if (typeof path === \"string\") {\n            path = this.cwd.resolve(path);\n        }\n        return path.depth();\n    }\n    /**\n     * Return the cache of child entries.  Exposed so subclasses can create\n     * child Path objects in a platform-specific way.\n     *\n     * @internal\n     */ childrenCache() {\n        return this.#children;\n    }\n    /**\n     * Resolve one or more path strings to a resolved string\n     *\n     * Same interface as require('path').resolve.\n     *\n     * Much faster than path.resolve() when called multiple times for the same\n     * path, because the resolved Path objects are cached.  Much slower\n     * otherwise.\n     */ resolve(...paths) {\n        // first figure out the minimum number of paths we have to test\n        // we always start at cwd, but any absolutes will bump the start\n        let r = \"\";\n        for(let i = paths.length - 1; i >= 0; i--){\n            const p = paths[i];\n            if (!p || p === \".\") continue;\n            r = r ? `${p}/${r}` : p;\n            if (this.isAbsolute(p)) {\n                break;\n            }\n        }\n        const cached = this.#resolveCache.get(r);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const result = this.cwd.resolve(r).fullpath();\n        this.#resolveCache.set(r, result);\n        return result;\n    }\n    /**\n     * Resolve one or more path strings to a resolved string, returning\n     * the posix path.  Identical to .resolve() on posix systems, but on\n     * windows will return a forward-slash separated UNC path.\n     *\n     * Same interface as require('path').resolve.\n     *\n     * Much faster than path.resolve() when called multiple times for the same\n     * path, because the resolved Path objects are cached.  Much slower\n     * otherwise.\n     */ resolvePosix(...paths) {\n        // first figure out the minimum number of paths we have to test\n        // we always start at cwd, but any absolutes will bump the start\n        let r = \"\";\n        for(let i = paths.length - 1; i >= 0; i--){\n            const p = paths[i];\n            if (!p || p === \".\") continue;\n            r = r ? `${p}/${r}` : p;\n            if (this.isAbsolute(p)) {\n                break;\n            }\n        }\n        const cached = this.#resolvePosixCache.get(r);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const result = this.cwd.resolve(r).fullpathPosix();\n        this.#resolvePosixCache.set(r, result);\n        return result;\n    }\n    /**\n     * find the relative path from the cwd to the supplied path string or entry\n     */ relative(entry = this.cwd) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.relative();\n    }\n    /**\n     * find the relative path from the cwd to the supplied path string or\n     * entry, using / as the path delimiter, even on Windows.\n     */ relativePosix(entry = this.cwd) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.relativePosix();\n    }\n    /**\n     * Return the basename for the provided string or Path object\n     */ basename(entry = this.cwd) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.name;\n    }\n    /**\n     * Return the dirname for the provided string or Path object\n     */ dirname(entry = this.cwd) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        }\n        return (entry.parent || entry).fullpath();\n    }\n    async readdir(entry = this.cwd, opts = {\n        withFileTypes: true\n    }) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes } = opts;\n        if (!entry.canReaddir()) {\n            return [];\n        } else {\n            const p = await entry.readdir();\n            return withFileTypes ? p : p.map((e)=>e.name);\n        }\n    }\n    readdirSync(entry = this.cwd, opts = {\n        withFileTypes: true\n    }) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true } = opts;\n        if (!entry.canReaddir()) {\n            return [];\n        } else if (withFileTypes) {\n            return entry.readdirSync();\n        } else {\n            return entry.readdirSync().map((e)=>e.name);\n        }\n    }\n    /**\n     * Call lstat() on the string or Path object, and update all known\n     * information that can be determined.\n     *\n     * Note that unlike `fs.lstat()`, the returned value does not contain some\n     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n     * information is required, you will need to call `fs.lstat` yourself.\n     *\n     * If the Path refers to a nonexistent file, or if the lstat call fails for\n     * any reason, `undefined` is returned.  Otherwise the updated Path object is\n     * returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */ async lstat(entry = this.cwd) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.lstat();\n    }\n    /**\n     * synchronous {@link PathScurryBase.lstat}\n     */ lstatSync(entry = this.cwd) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.lstatSync();\n    }\n    async readlink(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false\n    }) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = await entry.readlink();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    readlinkSync(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false\n    }) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = entry.readlinkSync();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    async realpath(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false\n    }) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = await entry.realpath();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    realpathSync(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false\n    }) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = entry.realpathSync();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    async walk(entry = this.cwd, opts = {}) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;\n        const results = [];\n        if (!filter || filter(entry)) {\n            results.push(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set();\n        const walk = (dir, cb)=>{\n            dirs.add(dir);\n            dir.readdirCB((er, entries)=>{\n                /* c8 ignore start */ if (er) {\n                    return cb(er);\n                }\n                /* c8 ignore stop */ let len = entries.length;\n                if (!len) return cb();\n                const next = ()=>{\n                    if (--len === 0) {\n                        cb();\n                    }\n                };\n                for (const e of entries){\n                    if (!filter || filter(e)) {\n                        results.push(withFileTypes ? e : e.fullpath());\n                    }\n                    if (follow && e.isSymbolicLink()) {\n                        e.realpath().then((r)=>r?.isUnknown() ? r.lstat() : r).then((r)=>r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());\n                    } else {\n                        if (e.shouldWalk(dirs, walkFilter)) {\n                            walk(e, next);\n                        } else {\n                            next();\n                        }\n                    }\n                }\n            }, true); // zalgooooooo\n        };\n        const start = entry;\n        return new Promise((res, rej)=>{\n            walk(start, (er)=>{\n                /* c8 ignore start */ if (er) return rej(er);\n                /* c8 ignore stop */ res(results);\n            });\n        });\n    }\n    walkSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;\n        const results = [];\n        if (!filter || filter(entry)) {\n            results.push(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set([\n            entry\n        ]);\n        for (const dir of dirs){\n            const entries = dir.readdirSync();\n            for (const e of entries){\n                if (!filter || filter(e)) {\n                    results.push(withFileTypes ? e : e.fullpath());\n                }\n                let r = e;\n                if (e.isSymbolicLink()) {\n                    if (!(follow && (r = e.realpathSync()))) continue;\n                    if (r.isUnknown()) r.lstatSync();\n                }\n                if (r.shouldWalk(dirs, walkFilter)) {\n                    dirs.add(r);\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * Support for `for await`\n     *\n     * Alias for {@link PathScurryBase.iterate}\n     *\n     * Note: As of Node 19, this is very slow, compared to other methods of\n     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n     */ [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    iterate(entry = this.cwd, options = {}) {\n        // iterating async over the stream is significantly more performant,\n        // especially in the warm-cache scenario, because it buffers up directory\n        // entries in the background instead of waiting for a yield for each one.\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            options = entry;\n            entry = this.cwd;\n        }\n        return this.stream(entry, options)[Symbol.asyncIterator]();\n    }\n    /**\n     * Iterating over a PathScurry performs a synchronous walk.\n     *\n     * Alias for {@link PathScurryBase.iterateSync}\n     */ [Symbol.iterator]() {\n        return this.iterateSync();\n    }\n    *iterateSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;\n        if (!filter || filter(entry)) {\n            yield withFileTypes ? entry : entry.fullpath();\n        }\n        const dirs = new Set([\n            entry\n        ]);\n        for (const dir of dirs){\n            const entries = dir.readdirSync();\n            for (const e of entries){\n                if (!filter || filter(e)) {\n                    yield withFileTypes ? e : e.fullpath();\n                }\n                let r = e;\n                if (e.isSymbolicLink()) {\n                    if (!(follow && (r = e.realpathSync()))) continue;\n                    if (r.isUnknown()) r.lstatSync();\n                }\n                if (r.shouldWalk(dirs, walkFilter)) {\n                    dirs.add(r);\n                }\n            }\n        }\n    }\n    stream(entry = this.cwd, opts = {}) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;\n        const results = new minipass_1.Minipass({\n            objectMode: true\n        });\n        if (!filter || filter(entry)) {\n            results.write(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set();\n        const queue = [\n            entry\n        ];\n        let processing = 0;\n        const process1 = ()=>{\n            let paused = false;\n            while(!paused){\n                const dir = queue.shift();\n                if (!dir) {\n                    if (processing === 0) results.end();\n                    return;\n                }\n                processing++;\n                dirs.add(dir);\n                const onReaddir = (er, entries, didRealpaths = false)=>{\n                    /* c8 ignore start */ if (er) return results.emit(\"error\", er);\n                    /* c8 ignore stop */ if (follow && !didRealpaths) {\n                        const promises = [];\n                        for (const e of entries){\n                            if (e.isSymbolicLink()) {\n                                promises.push(e.realpath().then((r)=>r?.isUnknown() ? r.lstat() : r));\n                            }\n                        }\n                        if (promises.length) {\n                            Promise.all(promises).then(()=>onReaddir(null, entries, true));\n                            return;\n                        }\n                    }\n                    for (const e of entries){\n                        if (e && (!filter || filter(e))) {\n                            if (!results.write(withFileTypes ? e : e.fullpath())) {\n                                paused = true;\n                            }\n                        }\n                    }\n                    processing--;\n                    for (const e of entries){\n                        const r = e.realpathCached() || e;\n                        if (r.shouldWalk(dirs, walkFilter)) {\n                            queue.push(r);\n                        }\n                    }\n                    if (paused && !results.flowing) {\n                        results.once(\"drain\", process1);\n                    } else if (!sync) {\n                        process1();\n                    }\n                };\n                // zalgo containment\n                let sync = true;\n                dir.readdirCB(onReaddir, true);\n                sync = false;\n            }\n        };\n        process1();\n        return results;\n    }\n    streamSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === \"string\") {\n            entry = this.cwd.resolve(entry);\n        } else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter } = opts;\n        const results = new minipass_1.Minipass({\n            objectMode: true\n        });\n        const dirs = new Set();\n        if (!filter || filter(entry)) {\n            results.write(withFileTypes ? entry : entry.fullpath());\n        }\n        const queue = [\n            entry\n        ];\n        let processing = 0;\n        const process1 = ()=>{\n            let paused = false;\n            while(!paused){\n                const dir = queue.shift();\n                if (!dir) {\n                    if (processing === 0) results.end();\n                    return;\n                }\n                processing++;\n                dirs.add(dir);\n                const entries = dir.readdirSync();\n                for (const e of entries){\n                    if (!filter || filter(e)) {\n                        if (!results.write(withFileTypes ? e : e.fullpath())) {\n                            paused = true;\n                        }\n                    }\n                }\n                processing--;\n                for (const e of entries){\n                    let r = e;\n                    if (e.isSymbolicLink()) {\n                        if (!(follow && (r = e.realpathSync()))) continue;\n                        if (r.isUnknown()) r.lstatSync();\n                    }\n                    if (r.shouldWalk(dirs, walkFilter)) {\n                        queue.push(r);\n                    }\n                }\n            }\n            if (paused && !results.flowing) results.once(\"drain\", process1);\n        };\n        process1();\n        return results;\n    }\n    chdir(path = this.cwd) {\n        const oldCwd = this.cwd;\n        this.cwd = typeof path === \"string\" ? this.cwd.resolve(path) : path;\n        this.cwd[setAsCwd](oldCwd);\n    }\n}\nexports.PathScurryBase = PathScurryBase;\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */ class PathScurryWin32 extends PathScurryBase {\n    constructor(cwd = process.cwd(), opts = {}){\n        const { nocase = true } = opts;\n        super(cwd, path_1.win32, \"\\\\\", {\n            ...opts,\n            nocase\n        });\n        /**\n     * separator for generating path strings\n     */ this.sep = \"\\\\\";\n        this.nocase = nocase;\n        for(let p = this.cwd; p; p = p.parent){\n            p.nocase = this.nocase;\n        }\n    }\n    /**\n     * @internal\n     */ parseRootPath(dir) {\n        // if the path starts with a single separator, it's not a UNC, and we'll\n        // just get separator as the root, and driveFromUNC will return \\\n        // In that case, mount \\ on the root from the cwd.\n        return path_1.win32.parse(dir).root.toUpperCase();\n    }\n    /**\n     * @internal\n     */ newRoot(fs) {\n        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), {\n            fs\n        });\n    }\n    /**\n     * Return true if the provided path string is an absolute path\n     */ isAbsolute(p) {\n        return p.startsWith(\"/\") || p.startsWith(\"\\\\\") || /^[a-z]:(\\/|\\\\)/i.test(p);\n    }\n}\nexports.PathScurryWin32 = PathScurryWin32;\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */ class PathScurryPosix extends PathScurryBase {\n    constructor(cwd = process.cwd(), opts = {}){\n        const { nocase = false } = opts;\n        super(cwd, path_1.posix, \"/\", {\n            ...opts,\n            nocase\n        });\n        /**\n     * separator for generating path strings\n     */ this.sep = \"/\";\n        this.nocase = nocase;\n    }\n    /**\n     * @internal\n     */ parseRootPath(_dir) {\n        return \"/\";\n    }\n    /**\n     * @internal\n     */ newRoot(fs) {\n        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), {\n            fs\n        });\n    }\n    /**\n     * Return true if the provided path string is an absolute path\n     */ isAbsolute(p) {\n        return p.startsWith(\"/\");\n    }\n}\nexports.PathScurryPosix = PathScurryPosix;\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */ class PathScurryDarwin extends PathScurryPosix {\n    constructor(cwd = process.cwd(), opts = {}){\n        const { nocase = true } = opts;\n        super(cwd, {\n            ...opts,\n            nocase\n        });\n    }\n}\nexports.PathScurryDarwin = PathScurryDarwin;\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */ exports.Path = process.platform === \"win32\" ? PathWin32 : PathPosix;\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */ exports.PathScurry = process.platform === \"win32\" ? PathScurryWin32 : process.platform === \"darwin\" ? PathScurryDarwin : PathScurryPosix; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGF0aC1zY3VycnkvZGlzdC9janMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxrQkFBa0IsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxlQUFlLElBQU1DLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQzFGLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCLElBQUlHLE9BQU9QLE9BQU9RLHdCQUF3QixDQUFDTCxHQUFHQztJQUM5QyxJQUFJLENBQUNHLFFBQVMsVUFBU0EsT0FBTyxDQUFDSixFQUFFTSxVQUFVLEdBQUdGLEtBQUtHLFFBQVEsSUFBSUgsS0FBS0ksWUFBWSxHQUFHO1FBQ2pGSixPQUFPO1lBQUVLLFlBQVk7WUFBTUMsS0FBSztnQkFBYSxPQUFPVixDQUFDLENBQUNDLEVBQUU7WUFBRTtRQUFFO0lBQzlEO0lBQ0FKLE9BQU9jLGNBQWMsQ0FBQ1osR0FBR0csSUFBSUU7QUFDakMsSUFBTSxTQUFTTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxFQUFFO0lBQ3RCLElBQUlBLE9BQU9DLFdBQVdELEtBQUtEO0lBQzNCRixDQUFDLENBQUNHLEdBQUcsR0FBR0YsQ0FBQyxDQUFDQyxFQUFFO0FBQ2hCLENBQUM7QUFDRCxJQUFJVyxxQkFBcUIsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxrQkFBa0IsSUFBTWYsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRWMsQ0FBQztJQUN6RmhCLE9BQU9jLGNBQWMsQ0FBQ1osR0FBRyxXQUFXO1FBQUVVLFlBQVk7UUFBTUssT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNkLENBQUMsRUFBRWMsQ0FBQztJQUNkZCxDQUFDLENBQUMsVUFBVSxHQUFHYztBQUNuQjtBQUNBLElBQUlFLGVBQWUsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxZ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UUFJRixJQUFJLENBQUNyQixNQUFNLEdBQUdBO0lBQ2xCO0lBQ0E7O0tBRUMsR0FDRDRHLGNBQWNxRCxJQUFJLEVBQUU7UUFDaEIsT0FBTztJQUNYO0lBQ0E7O0tBRUMsR0FDRG5ELFFBQVEvSSxFQUFFLEVBQUU7UUFDUixPQUFPLElBQUk1RSxVQUFVLElBQUksQ0FBQzRCLFFBQVEsRUFBRU0sT0FBTzNELFdBQVcsSUFBSSxDQUFDcUksS0FBSyxFQUFFLElBQUksQ0FBQ0MsTUFBTSxFQUFFLElBQUksQ0FBQ0ksYUFBYSxJQUFJO1lBQUVyQztRQUFHO0lBQzlHO0lBQ0E7O0tBRUMsR0FDRDJKLFdBQVc1RyxDQUFDLEVBQUU7UUFDVixPQUFPQSxFQUFFbUYsVUFBVSxDQUFDO0lBQ3hCO0FBQ0o7QUFDQXJOLHVCQUF1QixHQUFHSTtBQUMxQjs7Ozs7OztDQU9DLEdBQ0QsTUFBTUQseUJBQXlCQztJQUMzQnVFLFlBQVk4SSxNQUFNQyxRQUFRRCxHQUFHLEVBQUUsRUFBRXBHLE9BQU8sQ0FBQyxDQUFDLENBQUU7UUFDeEMsTUFBTSxFQUFFRCxTQUFTLElBQUksRUFBRSxHQUFHQztRQUMxQixLQUFLLENBQUNvRyxLQUFLO1lBQUUsR0FBR3BHLElBQUk7WUFBRUQ7UUFBTztJQUNqQztBQUNKO0FBQ0FwSCx3QkFBd0IsR0FBR0c7QUFDM0I7Ozs7Q0FJQyxHQUNESCxZQUFZLEdBQUcwTixRQUFRNEQsUUFBUSxLQUFLLFVBQVU5USxZQUFZRDtBQUMxRDs7Ozs7Q0FLQyxHQUNEUCxrQkFBa0IsR0FBRzBOLFFBQVE0RCxRQUFRLEtBQUssVUFDcENqUixrQkFDQXFOLFFBQVE0RCxRQUFRLEtBQUssV0FDakJuUixtQkFDQUMsaUJBQ1YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL3BhdGgtc2N1cnJ5L2Rpc3QvY2pzL2luZGV4LmpzPzU4OGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGF0aFNjdXJyeSA9IGV4cG9ydHMuUGF0aCA9IGV4cG9ydHMuUGF0aFNjdXJyeURhcndpbiA9IGV4cG9ydHMuUGF0aFNjdXJyeVBvc2l4ID0gZXhwb3J0cy5QYXRoU2N1cnJ5V2luMzIgPSBleHBvcnRzLlBhdGhTY3VycnlCYXNlID0gZXhwb3J0cy5QYXRoUG9zaXggPSBleHBvcnRzLlBhdGhXaW4zMiA9IGV4cG9ydHMuUGF0aEJhc2UgPSBleHBvcnRzLkNoaWxkcmVuQ2FjaGUgPSBleHBvcnRzLlJlc29sdmVDYWNoZSA9IHZvaWQgMDtcbmNvbnN0IGxydV9jYWNoZV8xID0gcmVxdWlyZShcImxydS1jYWNoZVwiKTtcbmNvbnN0IHBhdGhfMSA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgYWN0dWFsRlMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImZzXCIpKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCByZWFscGF0aFN5bmMgPSBmc18xLnJlYWxwYXRoU3luYy5uYXRpdmU7XG4vLyBUT0RPOiB0ZXN0IHBlcmYgb2YgZnMvcHJvbWlzZXMgcmVhbHBhdGggdnMgcmVhbHBhdGhDQixcbi8vIHNpbmNlIHRoZSBwcm9taXNlcyBvbmUgdXNlcyByZWFscGF0aC5uYXRpdmVcbmNvbnN0IHByb21pc2VzXzEgPSByZXF1aXJlKFwiZnMvcHJvbWlzZXNcIik7XG5jb25zdCBtaW5pcGFzc18xID0gcmVxdWlyZShcIm1pbmlwYXNzXCIpO1xuY29uc3QgZGVmYXVsdEZTID0ge1xuICAgIGxzdGF0U3luYzogZnNfMS5sc3RhdFN5bmMsXG4gICAgcmVhZGRpcjogZnNfMS5yZWFkZGlyLFxuICAgIHJlYWRkaXJTeW5jOiBmc18xLnJlYWRkaXJTeW5jLFxuICAgIHJlYWRsaW5rU3luYzogZnNfMS5yZWFkbGlua1N5bmMsXG4gICAgcmVhbHBhdGhTeW5jLFxuICAgIHByb21pc2VzOiB7XG4gICAgICAgIGxzdGF0OiBwcm9taXNlc18xLmxzdGF0LFxuICAgICAgICByZWFkZGlyOiBwcm9taXNlc18xLnJlYWRkaXIsXG4gICAgICAgIHJlYWRsaW5rOiBwcm9taXNlc18xLnJlYWRsaW5rLFxuICAgICAgICByZWFscGF0aDogcHJvbWlzZXNfMS5yZWFscGF0aCxcbiAgICB9LFxufTtcbi8vIGlmIHRoZXkganVzdCBnYXZlIHVzIHJlcXVpcmUoJ2ZzJykgdGhlbiB1c2Ugb3VyIGRlZmF1bHRcbmNvbnN0IGZzRnJvbU9wdGlvbiA9IChmc09wdGlvbikgPT4gIWZzT3B0aW9uIHx8IGZzT3B0aW9uID09PSBkZWZhdWx0RlMgfHwgZnNPcHRpb24gPT09IGFjdHVhbEZTXG4gICAgPyBkZWZhdWx0RlNcbiAgICA6IHtcbiAgICAgICAgLi4uZGVmYXVsdEZTLFxuICAgICAgICAuLi5mc09wdGlvbixcbiAgICAgICAgcHJvbWlzZXM6IHtcbiAgICAgICAgICAgIC4uLmRlZmF1bHRGUy5wcm9taXNlcyxcbiAgICAgICAgICAgIC4uLihmc09wdGlvbi5wcm9taXNlcyB8fCB7fSksXG4gICAgICAgIH0sXG4gICAgfTtcbi8vIHR1cm4gc29tZXRoaW5nIGxpa2UgLy8/L2M6LyBpbnRvIGM6XFxcbmNvbnN0IHVuY0RyaXZlUmVnZXhwID0gL15cXFxcXFxcXFxcP1xcXFwoW2Etel06KVxcXFw/JC9pO1xuY29uc3QgdW5jVG9Ecml2ZSA9IChyb290UGF0aCkgPT4gcm9vdFBhdGgucmVwbGFjZSgvXFwvL2csICdcXFxcJykucmVwbGFjZSh1bmNEcml2ZVJlZ2V4cCwgJyQxXFxcXCcpO1xuLy8gd2luZG93cyBwYXRocyBhcmUgc2VwYXJhdGVkIGJ5IGVpdGhlciAvIG9yIFxcXG5jb25zdCBlaXRoZXJTZXAgPSAvW1xcXFxcXC9dLztcbmNvbnN0IFVOS05PV04gPSAwOyAvLyBtYXkgbm90IGV2ZW4gZXhpc3QsIGZvciBhbGwgd2Uga25vd1xuY29uc3QgSUZJRk8gPSAwYjAwMDE7XG5jb25zdCBJRkNIUiA9IDBiMDAxMDtcbmNvbnN0IElGRElSID0gMGIwMTAwO1xuY29uc3QgSUZCTEsgPSAwYjAxMTA7XG5jb25zdCBJRlJFRyA9IDBiMTAwMDtcbmNvbnN0IElGTE5LID0gMGIxMDEwO1xuY29uc3QgSUZTT0NLID0gMGIxMTAwO1xuY29uc3QgSUZNVCA9IDBiMTExMTtcbi8vIG1hc2sgdG8gdW5zZXQgbG93IDQgYml0c1xuY29uc3QgSUZNVF9VTktOT1dOID0gfklGTVQ7XG4vLyBzZXQgYWZ0ZXIgc3VjY2Vzc2Z1bGx5IGNhbGxpbmcgcmVhZGRpcigpIGFuZCBnZXR0aW5nIGVudHJpZXMuXG5jb25zdCBSRUFERElSX0NBTExFRCA9IDE2O1xuLy8gc2V0IGFmdGVyIGEgc3VjY2Vzc2Z1bCBsc3RhdCgpXG5jb25zdCBMU1RBVF9DQUxMRUQgPSAzMjtcbi8vIHNldCBpZiBhbiBlbnRyeSAob3Igb25lIG9mIGl0cyBwYXJlbnRzKSBpcyBkZWZpbml0ZWx5IG5vdCBhIGRpclxuY29uc3QgRU5PVERJUiA9IDY0O1xuLy8gc2V0IGlmIGFuIGVudHJ5IChvciBvbmUgb2YgaXRzIHBhcmVudHMpIGRvZXMgbm90IGV4aXN0XG4vLyAoY2FuIGFsc28gYmUgc2V0IG9uIGxzdGF0IGVycm9ycyBsaWtlIEVBQ0NFUyBvciBFTkFNRVRPT0xPTkcpXG5jb25zdCBFTk9FTlQgPSAxMjg7XG4vLyBjYW5ub3QgaGF2ZSBjaGlsZCBlbnRyaWVzIC0tIGFsc28gdmVyaWZ5ICZJRk1UIGlzIGVpdGhlciBJRkRJUiBvciBJRkxOS1xuLy8gc2V0IGlmIHdlIGZhaWwgdG8gcmVhZGxpbmtcbmNvbnN0IEVOT1JFQURMSU5LID0gMjU2O1xuLy8gc2V0IGlmIHdlIGtub3cgcmVhbHBhdGgoKSB3aWxsIGZhaWxcbmNvbnN0IEVOT1JFQUxQQVRIID0gNTEyO1xuY29uc3QgRU5PQ0hJTEQgPSBFTk9URElSIHwgRU5PRU5UIHwgRU5PUkVBTFBBVEg7XG5jb25zdCBUWVBFTUFTSyA9IDEwMjM7XG5jb25zdCBlbnRUb1R5cGUgPSAocykgPT4gcy5pc0ZpbGUoKVxuICAgID8gSUZSRUdcbiAgICA6IHMuaXNEaXJlY3RvcnkoKVxuICAgICAgICA/IElGRElSXG4gICAgICAgIDogcy5pc1N5bWJvbGljTGluaygpXG4gICAgICAgICAgICA/IElGTE5LXG4gICAgICAgICAgICA6IHMuaXNDaGFyYWN0ZXJEZXZpY2UoKVxuICAgICAgICAgICAgICAgID8gSUZDSFJcbiAgICAgICAgICAgICAgICA6IHMuaXNCbG9ja0RldmljZSgpXG4gICAgICAgICAgICAgICAgICAgID8gSUZCTEtcbiAgICAgICAgICAgICAgICAgICAgOiBzLmlzU29ja2V0KClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gSUZTT0NLXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHMuaXNGSUZPKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IElGSUZPXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBVTktOT1dOO1xuLy8gbm9ybWFsaXplIHVuaWNvZGUgcGF0aCBuYW1lc1xuY29uc3Qgbm9ybWFsaXplQ2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBub3JtYWxpemUgPSAocykgPT4ge1xuICAgIGNvbnN0IGMgPSBub3JtYWxpemVDYWNoZS5nZXQocyk7XG4gICAgaWYgKGMpXG4gICAgICAgIHJldHVybiBjO1xuICAgIGNvbnN0IG4gPSBzLm5vcm1hbGl6ZSgnTkZLRCcpO1xuICAgIG5vcm1hbGl6ZUNhY2hlLnNldChzLCBuKTtcbiAgICByZXR1cm4gbjtcbn07XG5jb25zdCBub3JtYWxpemVOb2Nhc2VDYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IG5vcm1hbGl6ZU5vY2FzZSA9IChzKSA9PiB7XG4gICAgY29uc3QgYyA9IG5vcm1hbGl6ZU5vY2FzZUNhY2hlLmdldChzKTtcbiAgICBpZiAoYylcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgY29uc3QgbiA9IG5vcm1hbGl6ZShzLnRvTG93ZXJDYXNlKCkpO1xuICAgIG5vcm1hbGl6ZU5vY2FzZUNhY2hlLnNldChzLCBuKTtcbiAgICByZXR1cm4gbjtcbn07XG4vKipcbiAqIEFuIExSVUNhY2hlIGZvciBzdG9yaW5nIHJlc29sdmVkIHBhdGggc3RyaW5ncyBvciBQYXRoIG9iamVjdHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgUmVzb2x2ZUNhY2hlIGV4dGVuZHMgbHJ1X2NhY2hlXzEuTFJVQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcih7IG1heDogMjU2IH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzb2x2ZUNhY2hlID0gUmVzb2x2ZUNhY2hlO1xuLy8gSW4gb3JkZXIgdG8gcHJldmVudCBibG93aW5nIG91dCB0aGUganMgaGVhcCBieSBhbGxvY2F0aW5nIGh1bmRyZWRzIG9mXG4vLyB0aG91c2FuZHMgb2YgUGF0aCBlbnRyaWVzIHdoZW4gd2Fsa2luZyBleHRyZW1lbHkgbGFyZ2UgdHJlZXMsIHRoZSBcImNoaWxkcmVuXCJcbi8vIGluIHRoaXMgdHJlZSBhcmUgcmVwcmVzZW50ZWQgYnkgc3RvcmluZyBhbiBhcnJheSBvZiBQYXRoIGVudHJpZXMgaW4gYW5cbi8vIExSVUNhY2hlLCBpbmRleGVkIGJ5IHRoZSBwYXJlbnQuICBBdCBhbnkgdGltZSwgUGF0aC5jaGlsZHJlbigpIG1heSByZXR1cm4gYW5cbi8vIGVtcHR5IGFycmF5LCBpbmRpY2F0aW5nIHRoYXQgaXQgZG9lc24ndCBrbm93IGFib3V0IGFueSBvZiBpdHMgY2hpbGRyZW4sIGFuZFxuLy8gdGh1cyBoYXMgdG8gcmVidWlsZCB0aGF0IGNhY2hlLiAgVGhpcyBpcyBmaW5lLCBpdCBqdXN0IG1lYW5zIHRoYXQgd2UgZG9uJ3Rcbi8vIGJlbmVmaXQgYXMgbXVjaCBmcm9tIGhhdmluZyB0aGUgY2FjaGVkIGVudHJpZXMsIGJ1dCBodWdlIGRpcmVjdG9yeSB3YWxrc1xuLy8gZG9uJ3QgYmxvdyBvdXQgdGhlIHN0YWNrLCBhbmQgc21hbGxlciBvbmVzIGFyZSBzdGlsbCBhcyBmYXN0IGFzIHBvc3NpYmxlLlxuLy9cbi8vSXQgZG9lcyBpbXBvc2Ugc29tZSBjb21wbGV4aXR5IHdoZW4gYnVpbGRpbmcgdXAgdGhlIHJlYWRkaXIgZGF0YSwgYmVjYXVzZSB3ZVxuLy9uZWVkIHRvIHBhc3MgYSByZWZlcmVuY2UgdG8gdGhlIGNoaWxkcmVuIGFycmF5IHRoYXQgd2Ugc3RhcnRlZCB3aXRoLlxuLyoqXG4gKiBhbiBMUlVDYWNoZSBmb3Igc3RvcmluZyBjaGlsZCBlbnRyaWVzLlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIENoaWxkcmVuQ2FjaGUgZXh0ZW5kcyBscnVfY2FjaGVfMS5MUlVDYWNoZSB7XG4gICAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDE2ICogMTAyNCkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBtYXhTaXplLFxuICAgICAgICAgICAgLy8gcGFyZW50ICsgY2hpbGRyZW5cbiAgICAgICAgICAgIHNpemVDYWxjdWxhdGlvbjogYSA9PiBhLmxlbmd0aCArIDEsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hpbGRyZW5DYWNoZSA9IENoaWxkcmVuQ2FjaGU7XG5jb25zdCBzZXRBc0N3ZCA9IFN5bWJvbCgnUGF0aFNjdXJyeSBzZXRBc0N3ZCcpO1xuLyoqXG4gKiBQYXRoIG9iamVjdHMgYXJlIHNvcnQgb2YgbGlrZSBhIHN1cGVyLXBvd2VyZWRcbiAqIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvZG9jcy9sYXRlc3QvYXBpL2ZzLmh0bWwjY2xhc3MtZnNkaXJlbnQgZnMuRGlyZW50fVxuICpcbiAqIEVhY2ggb25lIHJlcHJlc2VudHMgYSBzaW5nbGUgZmlsZXN5c3RlbSBlbnRyeSBvbiBkaXNrLCB3aGljaCBtYXkgb3IgbWF5IG5vdFxuICogZXhpc3QuIEl0IGluY2x1ZGVzIG1ldGhvZHMgZm9yIHJlYWRpbmcgdmFyaW91cyB0eXBlcyBvZiBpbmZvcm1hdGlvbiB2aWFcbiAqIGxzdGF0LCByZWFkbGluaywgYW5kIHJlYWRkaXIsIGFuZCBjYWNoZXMgYWxsIGluZm9ybWF0aW9uIHRvIHRoZSBncmVhdGVzdFxuICogZGVncmVlIHBvc3NpYmxlLlxuICpcbiAqIE5vdGUgdGhhdCBmcyBvcGVyYXRpb25zIHRoYXQgd291bGQgbm9ybWFsbHkgdGhyb3cgd2lsbCBpbnN0ZWFkIHJldHVybiBhblxuICogXCJlbXB0eVwiIHZhbHVlLiBUaGlzIGlzIGluIG9yZGVyIHRvIHByZXZlbnQgZXhjZXNzaXZlIG92ZXJoZWFkIGZyb20gZXJyb3JcbiAqIHN0YWNrIHRyYWNlcy5cbiAqL1xuY2xhc3MgUGF0aEJhc2Uge1xuICAgIC8qKlxuICAgICAqIHRoZSBiYXNlbmFtZSBvZiB0aGlzIHBhdGhcbiAgICAgKlxuICAgICAqICoqSW1wb3J0YW50Kio6ICphbHdheXMqIHRlc3QgdGhlIHBhdGggbmFtZSBhZ2FpbnN0IGFueSB0ZXN0IHN0cmluZ1xuICAgICAqIHVzaW5ndGhlIHtAbGluayBpc05hbWVkfSBtZXRob2QsIGFuZCBub3QgYnkgZGlyZWN0bHkgY29tcGFyaW5nIHRoaXNcbiAgICAgKiBzdHJpbmcuIE90aGVyd2lzZSwgdW5pY29kZSBwYXRoIHN0cmluZ3MgdGhhdCB0aGUgc3lzdGVtIHNlZXMgYXMgaWRlbnRpY2FsXG4gICAgICogd2lsbCBub3QgYmUgcHJvcGVybHkgdHJlYXRlZCBhcyB0aGUgc2FtZSBwYXRoLCBsZWFkaW5nIHRvIGluY29ycmVjdFxuICAgICAqIGJlaGF2aW9yIGFuZCBwb3NzaWJsZSBzZWN1cml0eSBpc3N1ZXMuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiB0aGUgUGF0aCBlbnRyeSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwYXRoIHJvb3QuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByb290O1xuICAgIC8qKlxuICAgICAqIEFsbCByb290cyBmb3VuZCB3aXRoaW4gdGhlIGN1cnJlbnQgUGF0aFNjdXJyeSBmYW1pbHlcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHJvb3RzO1xuICAgIC8qKlxuICAgICAqIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgcGF0aCwgb3IgdW5kZWZpbmVkIGluIHRoZSBjYXNlIG9mIHJvb3QgZW50cmllc1xuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcGFyZW50O1xuICAgIC8qKlxuICAgICAqIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHBhdGhzIGFyZSBjb21wYXJlZCBjYXNlLWluc2Vuc2l0aXZlbHlcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBub2Nhc2U7XG4gICAgLy8gcG90ZW50aWFsIGRlZmF1bHQgZnMgb3ZlcnJpZGVcbiAgICAjZnM7XG4gICAgLy8gU3RhdHMgZmllbGRzXG4gICAgI2RldjtcbiAgICBnZXQgZGV2KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGV2O1xuICAgIH1cbiAgICAjbW9kZTtcbiAgICBnZXQgbW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI21vZGU7XG4gICAgfVxuICAgICNubGluaztcbiAgICBnZXQgbmxpbmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNubGluaztcbiAgICB9XG4gICAgI3VpZDtcbiAgICBnZXQgdWlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdWlkO1xuICAgIH1cbiAgICAjZ2lkO1xuICAgIGdldCBnaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnaWQ7XG4gICAgfVxuICAgICNyZGV2O1xuICAgIGdldCByZGV2KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmRldjtcbiAgICB9XG4gICAgI2Jsa3NpemU7XG4gICAgZ2V0IGJsa3NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNibGtzaXplO1xuICAgIH1cbiAgICAjaW5vO1xuICAgIGdldCBpbm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpbm87XG4gICAgfVxuICAgICNzaXplO1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jc2l6ZTtcbiAgICB9XG4gICAgI2Jsb2NrcztcbiAgICBnZXQgYmxvY2tzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYmxvY2tzO1xuICAgIH1cbiAgICAjYXRpbWVNcztcbiAgICBnZXQgYXRpbWVNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2F0aW1lTXM7XG4gICAgfVxuICAgICNtdGltZU1zO1xuICAgIGdldCBtdGltZU1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbXRpbWVNcztcbiAgICB9XG4gICAgI2N0aW1lTXM7XG4gICAgZ2V0IGN0aW1lTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjdGltZU1zO1xuICAgIH1cbiAgICAjYmlydGh0aW1lTXM7XG4gICAgZ2V0IGJpcnRodGltZU1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYmlydGh0aW1lTXM7XG4gICAgfVxuICAgICNhdGltZTtcbiAgICBnZXQgYXRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhdGltZTtcbiAgICB9XG4gICAgI210aW1lO1xuICAgIGdldCBtdGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI210aW1lO1xuICAgIH1cbiAgICAjY3RpbWU7XG4gICAgZ2V0IGN0aW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY3RpbWU7XG4gICAgfVxuICAgICNiaXJ0aHRpbWU7XG4gICAgZ2V0IGJpcnRodGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2JpcnRodGltZTtcbiAgICB9XG4gICAgI21hdGNoTmFtZTtcbiAgICAjZGVwdGg7XG4gICAgI2Z1bGxwYXRoO1xuICAgICNmdWxscGF0aFBvc2l4O1xuICAgICNyZWxhdGl2ZTtcbiAgICAjcmVsYXRpdmVQb3NpeDtcbiAgICAjdHlwZTtcbiAgICAjY2hpbGRyZW47XG4gICAgI2xpbmtUYXJnZXQ7XG4gICAgI3JlYWxwYXRoO1xuICAgIC8qKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgRGlyZW50IGNsYXNzIGFzIG9mXG4gICAgICogTm9kZSB2MjAsIHdoZXJlIERpcmVudFsncGF0aCddIHJlZmVycyB0byB0aGUgcGF0aCBvZiB0aGUgZGlyZWN0b3J5XG4gICAgICogdGhhdCB3YXMgcGFzc2VkIHRvIHJlYWRkaXIuICBTbywgc29tZXdoYXQgY291bnRlcmludHVpdGl2ZWx5LCB0aGlzXG4gICAgICogcHJvcGVydHkgcmVmZXJzIHRvIHRoZSAqcGFyZW50KiBwYXRoLCBub3QgdGhlIHBhdGggb2JqZWN0IGl0c2VsZi5cbiAgICAgKiBGb3Igcm9vdCBlbnRyaWVzLCBpdCdzIHRoZSBwYXRoIHRvIHRoZSBlbnRyeSBpdHNlbGYuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5wYXJlbnQgfHwgdGhpcykuZnVsbHBhdGgoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG8gbm90IGNyZWF0ZSBuZXcgUGF0aCBvYmplY3RzIGRpcmVjdGx5LiAgVGhleSBzaG91bGQgYWx3YXlzIGJlIGFjY2Vzc2VkXG4gICAgICogdmlhIHRoZSBQYXRoU2N1cnJ5IGNsYXNzIG9yIG90aGVyIG1ldGhvZHMgb24gdGhlIFBhdGggY2xhc3MuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlID0gVU5LTk9XTiwgcm9vdCwgcm9vdHMsIG5vY2FzZSwgY2hpbGRyZW4sIG9wdHMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy4jbWF0Y2hOYW1lID0gbm9jYXNlID8gbm9ybWFsaXplTm9jYXNlKG5hbWUpIDogbm9ybWFsaXplKG5hbWUpO1xuICAgICAgICB0aGlzLiN0eXBlID0gdHlwZSAmIFRZUEVNQVNLO1xuICAgICAgICB0aGlzLm5vY2FzZSA9IG5vY2FzZTtcbiAgICAgICAgdGhpcy5yb290cyA9IHJvb3RzO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290IHx8IHRoaXM7XG4gICAgICAgIHRoaXMuI2NoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuI2Z1bGxwYXRoID0gb3B0cy5mdWxscGF0aDtcbiAgICAgICAgdGhpcy4jcmVsYXRpdmUgPSBvcHRzLnJlbGF0aXZlO1xuICAgICAgICB0aGlzLiNyZWxhdGl2ZVBvc2l4ID0gb3B0cy5yZWxhdGl2ZVBvc2l4O1xuICAgICAgICB0aGlzLnBhcmVudCA9IG9wdHMucGFyZW50O1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuI2ZzID0gdGhpcy5wYXJlbnQuI2ZzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jZnMgPSBmc0Zyb21PcHRpb24ob3B0cy5mcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVwdGggb2YgdGhlIFBhdGggb2JqZWN0IGZyb20gaXRzIHJvb3QuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgYSBwYXRoIGF0IGAvZm9vL2JhcmAgd291bGQgaGF2ZSBhIGRlcHRoIG9mIDIuXG4gICAgICovXG4gICAgZGVwdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLiNkZXB0aCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2RlcHRoO1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNkZXB0aCA9IDApO1xuICAgICAgICByZXR1cm4gKHRoaXMuI2RlcHRoID0gdGhpcy5wYXJlbnQuZGVwdGgoKSArIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjaGlsZHJlbkNhY2hlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2hpbGRyZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgUGF0aCBvYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgc3RyaW5nIHBhdGgsIHJlc29sdmVkIGZyb20gdGhpcyBQYXRoXG4gICAgICovXG4gICAgcmVzb2x2ZShwYXRoKSB7XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm9vdFBhdGggPSB0aGlzLmdldFJvb3RTdHJpbmcocGF0aCk7XG4gICAgICAgIGNvbnN0IGRpciA9IHBhdGguc3Vic3RyaW5nKHJvb3RQYXRoLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGRpclBhcnRzID0gZGlyLnNwbGl0KHRoaXMuc3BsaXRTZXApO1xuICAgICAgICBjb25zdCByZXN1bHQgPSByb290UGF0aFxuICAgICAgICAgICAgPyB0aGlzLmdldFJvb3Qocm9vdFBhdGgpLiNyZXNvbHZlUGFydHMoZGlyUGFydHMpXG4gICAgICAgICAgICA6IHRoaXMuI3Jlc29sdmVQYXJ0cyhkaXJQYXJ0cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgICNyZXNvbHZlUGFydHMoZGlyUGFydHMpIHtcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgZGlyUGFydHMpIHtcbiAgICAgICAgICAgIHAgPSBwLmNoaWxkKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjYWNoZWQgY2hpbGRyZW4gUGF0aCBvYmplY3RzLCBpZiBzdGlsbCBhdmFpbGFibGUuICBJZiB0aGV5XG4gICAgICogaGF2ZSBmYWxsZW4gb3V0IG9mIHRoZSBjYWNoZSwgdGhlbiByZXR1cm5zIGFuIGVtcHR5IGFycmF5LCBhbmQgcmVzZXRzIHRoZVxuICAgICAqIFJFQURESVJfQ0FMTEVEIGJpdCwgc28gdGhhdCBmdXR1cmUgY2FsbHMgdG8gcmVhZGRpcigpIHdpbGwgcmVxdWlyZSBhbiBmc1xuICAgICAqIGxvb2t1cC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLiNjaGlsZHJlbi5nZXQodGhpcyk7XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBPYmplY3QuYXNzaWduKFtdLCB7IHByb3Zpc2lvbmFsOiAwIH0pO1xuICAgICAgICB0aGlzLiNjaGlsZHJlbi5zZXQodGhpcywgY2hpbGRyZW4pO1xuICAgICAgICB0aGlzLiN0eXBlICY9IH5SRUFERElSX0NBTExFRDtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhIHBhdGggcG9ydGlvbiBhbmQgcmV0dXJucyBvciBjcmVhdGVzIHRoZSBjaGlsZCBQYXRoLlxuICAgICAqXG4gICAgICogUmV0dXJucyBgdGhpc2AgaWYgcGF0aFBhcnQgaXMgYCcnYCBvciBgJy4nYCwgb3IgYHBhcmVudGAgaWYgcGF0aFBhcnQgaXNcbiAgICAgKiBgJy4uJ2AuXG4gICAgICpcbiAgICAgKiBUaGlzIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LiAgSWYgYHBhdGhQYXJ0YCBjb250YWlucyBhbnkgcGF0aFxuICAgICAqIHNlcGFyYXRvcnMsIGl0IHdpbGwgbGVhZCB0byB1bnNhZmUgdW5kZWZpbmVkIGJlaGF2aW9yLlxuICAgICAqXG4gICAgICogVXNlIGBQYXRoLnJlc29sdmUoKWAgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNoaWxkKHBhdGhQYXJ0LCBvcHRzKSB7XG4gICAgICAgIGlmIChwYXRoUGFydCA9PT0gJycgfHwgcGF0aFBhcnQgPT09ICcuJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGhQYXJ0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5kIHRoZSBjaGlsZFxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubm9jYXNlXG4gICAgICAgICAgICA/IG5vcm1hbGl6ZU5vY2FzZShwYXRoUGFydClcbiAgICAgICAgICAgIDogbm9ybWFsaXplKHBhdGhQYXJ0KTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAocC4jbWF0Y2hOYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlkbid0IGZpbmQgaXQsIGNyZWF0ZSBwcm92aXNpb25hbCBjaGlsZCwgc2luY2UgaXQgbWlnaHQgbm90XG4gICAgICAgIC8vIGFjdHVhbGx5IGV4aXN0LiAgSWYgd2Uga25vdyB0aGUgcGFyZW50IGlzbid0IGEgZGlyLCB0aGVuXG4gICAgICAgIC8vIGluIGZhY3QgaXQgQ0FOJ1QgZXhpc3QuXG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLnBhcmVudCA/IHRoaXMuc2VwIDogJyc7XG4gICAgICAgIGNvbnN0IGZ1bGxwYXRoID0gdGhpcy4jZnVsbHBhdGhcbiAgICAgICAgICAgID8gdGhpcy4jZnVsbHBhdGggKyBzICsgcGF0aFBhcnRcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwY2hpbGQgPSB0aGlzLm5ld0NoaWxkKHBhdGhQYXJ0LCBVTktOT1dOLCB7XG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgICAgZnVsbHBhdGgsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuY2FuUmVhZGRpcigpKSB7XG4gICAgICAgICAgICBwY2hpbGQuI3R5cGUgfD0gRU5PRU5UO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbid0IGhhdmUgdG8gdXBkYXRlIHByb3Zpc2lvbmFsLCBiZWNhdXNlIGlmIHdlIGhhdmUgcmVhbCBjaGlsZHJlbixcbiAgICAgICAgLy8gdGhlbiBwcm92aXNpb25hbCBpcyBzZXQgdG8gY2hpbGRyZW4ubGVuZ3RoLCBvdGhlcndpc2UgYSBsb3dlciBudW1iZXJcbiAgICAgICAgY2hpbGRyZW4ucHVzaChwY2hpbGQpO1xuICAgICAgICByZXR1cm4gcGNoaWxkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVsYXRpdmUgcGF0aCBmcm9tIHRoZSBjd2QuIElmIGl0IGRvZXMgbm90IHNoYXJlIGFuIGFuY2VzdG9yIHdpdGhcbiAgICAgKiB0aGUgY3dkLCB0aGVuIHRoaXMgZW5kcyB1cCBiZWluZyBlcXVpdmFsZW50IHRvIHRoZSBmdWxscGF0aCgpXG4gICAgICovXG4gICAgcmVsYXRpdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLiNyZWxhdGl2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVsYXRpdmU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jcmVsYXRpdmUgPSB0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB2ID0gcC5yZWxhdGl2ZSgpO1xuICAgICAgICByZXR1cm4gcHYgKyAoIXB2IHx8ICFwLnBhcmVudCA/ICcnIDogdGhpcy5zZXApICsgbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJlbGF0aXZlIHBhdGggZnJvbSB0aGUgY3dkLCB1c2luZyAvIGFzIHRoZSBwYXRoIHNlcGFyYXRvci5cbiAgICAgKiBJZiBpdCBkb2VzIG5vdCBzaGFyZSBhbiBhbmNlc3RvciB3aXRoXG4gICAgICogdGhlIGN3ZCwgdGhlbiB0aGlzIGVuZHMgdXAgYmVpbmcgZXF1aXZhbGVudCB0byB0aGUgZnVsbHBhdGhQb3NpeCgpXG4gICAgICogT24gcG9zaXggc3lzdGVtcywgdGhpcyBpcyBpZGVudGljYWwgdG8gcmVsYXRpdmUoKS5cbiAgICAgKi9cbiAgICByZWxhdGl2ZVBvc2l4KCkge1xuICAgICAgICBpZiAodGhpcy5zZXAgPT09ICcvJylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbGF0aXZlKCk7XG4gICAgICAgIGlmICh0aGlzLiNyZWxhdGl2ZVBvc2l4ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVsYXRpdmVQb3NpeDtcbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jcmVsYXRpdmVQb3NpeCA9IHRoaXMuZnVsbHBhdGhQb3NpeCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdiA9IHAucmVsYXRpdmVQb3NpeCgpO1xuICAgICAgICByZXR1cm4gcHYgKyAoIXB2IHx8ICFwLnBhcmVudCA/ICcnIDogJy8nKSArIG5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBmdWxseSByZXNvbHZlZCBwYXRoIHN0cmluZyBmb3IgdGhpcyBQYXRoIGVudHJ5XG4gICAgICovXG4gICAgZnVsbHBhdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLiNmdWxscGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZnVsbHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMucGFyZW50O1xuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jZnVsbHBhdGggPSB0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB2ID0gcC5mdWxscGF0aCgpO1xuICAgICAgICBjb25zdCBmcCA9IHB2ICsgKCFwLnBhcmVudCA/ICcnIDogdGhpcy5zZXApICsgbmFtZTtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNmdWxscGF0aCA9IGZwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT24gcGxhdGZvcm1zIG90aGVyIHRoYW4gd2luZG93cywgdGhpcyBpcyBpZGVudGljYWwgdG8gZnVsbHBhdGguXG4gICAgICpcbiAgICAgKiBPbiB3aW5kb3dzLCB0aGlzIGlzIG92ZXJyaWRkZW4gdG8gcmV0dXJuIHRoZSBmb3J3YXJkLXNsYXNoIGZvcm0gb2YgdGhlXG4gICAgICogZnVsbCBVTkMgcGF0aC5cbiAgICAgKi9cbiAgICBmdWxscGF0aFBvc2l4KCkge1xuICAgICAgICBpZiAodGhpcy4jZnVsbHBhdGhQb3NpeCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI2Z1bGxwYXRoUG9zaXg7XG4gICAgICAgIGlmICh0aGlzLnNlcCA9PT0gJy8nKVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNmdWxscGF0aFBvc2l4ID0gdGhpcy5mdWxscGF0aCgpKTtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuZnVsbHBhdGgoKS5yZXBsYWNlKC9cXFxcL2csICcvJyk7XG4gICAgICAgICAgICBpZiAoL15bYS16XTpcXC8vaS50ZXN0KHApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNmdWxscGF0aFBvc2l4ID0gYC8vPy8ke3B9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuI2Z1bGxwYXRoUG9zaXggPSBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGNvbnN0IHBmcHAgPSBwLmZ1bGxwYXRoUG9zaXgoKTtcbiAgICAgICAgY29uc3QgZnBwID0gcGZwcCArICghcGZwcCB8fCAhcC5wYXJlbnQgPyAnJyA6ICcvJykgKyB0aGlzLm5hbWU7XG4gICAgICAgIHJldHVybiAodGhpcy4jZnVsbHBhdGhQb3NpeCA9IGZwcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBQYXRoIG9mIGFuIHVua25vd24gdHlwZT9cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3ZSBtaWdodCBrbm93ICpzb21ldGhpbmcqIGFib3V0IGl0IGlmIHRoZXJlIGhhcyBiZWVuIGEgcHJldmlvdXNcbiAgICAgKiBmaWxlc3lzdGVtIG9wZXJhdGlvbiwgZm9yIGV4YW1wbGUgdGhhdCBpdCBkb2VzIG5vdCBleGlzdCwgb3IgaXMgbm90IGFcbiAgICAgKiBsaW5rLCBvciB3aGV0aGVyIGl0IGhhcyBjaGlsZCBlbnRyaWVzLlxuICAgICAqL1xuICAgIGlzVW5rbm93bigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiN0eXBlICYgSUZNVCkgPT09IFVOS05PV047XG4gICAgfVxuICAgIGlzVHlwZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzW2BpcyR7dHlwZX1gXSgpO1xuICAgIH1cbiAgICBnZXRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1Vua25vd24oKVxuICAgICAgICAgICAgPyAnVW5rbm93bidcbiAgICAgICAgICAgIDogdGhpcy5pc0RpcmVjdG9yeSgpXG4gICAgICAgICAgICAgICAgPyAnRGlyZWN0b3J5J1xuICAgICAgICAgICAgICAgIDogdGhpcy5pc0ZpbGUoKVxuICAgICAgICAgICAgICAgICAgICA/ICdGaWxlJ1xuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuaXNTeW1ib2xpY0xpbmsoKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnU3ltYm9saWNMaW5rJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmlzRklGTygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnRklGTydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuaXNDaGFyYWN0ZXJEZXZpY2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdDaGFyYWN0ZXJEZXZpY2UnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5pc0Jsb2NrRGV2aWNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ0Jsb2NrRGV2aWNlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAvKiBjOCBpZ25vcmUgc3RhcnQgKi8gdGhpcy5pc1NvY2tldCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnU29ja2V0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ1Vua25vd24nO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgUGF0aCBhIHJlZ3VsYXIgZmlsZT9cbiAgICAgKi9cbiAgICBpc0ZpbGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jdHlwZSAmIElGTVQpID09PSBJRlJFRztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIFBhdGggYSBkaXJlY3Rvcnk/XG4gICAgICovXG4gICAgaXNEaXJlY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jdHlwZSAmIElGTVQpID09PSBJRkRJUjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIHBhdGggYSBjaGFyYWN0ZXIgZGV2aWNlP1xuICAgICAqL1xuICAgIGlzQ2hhcmFjdGVyRGV2aWNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgJiBJRk1UKSA9PT0gSUZDSFI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBwYXRoIGEgYmxvY2sgZGV2aWNlP1xuICAgICAqL1xuICAgIGlzQmxvY2tEZXZpY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jdHlwZSAmIElGTVQpID09PSBJRkJMSztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIHBhdGggYSBGSUZPIHBpcGU/XG4gICAgICovXG4gICAgaXNGSUZPKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgJiBJRk1UKSA9PT0gSUZJRk87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBwYXRoIGEgc29ja2V0P1xuICAgICAqL1xuICAgIGlzU29ja2V0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgJiBJRk1UKSA9PT0gSUZTT0NLO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgcGF0aCBhIHN5bWJvbGljIGxpbms/XG4gICAgICovXG4gICAgaXNTeW1ib2xpY0xpbmsoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy4jdHlwZSAmIElGTE5LKSA9PT0gSUZMTks7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZW50cnkgaWYgaXQgaGFzIGJlZW4gc3ViamVjdCBvZiBhIHN1Y2Nlc3NmdWwgbHN0YXQsIG9yXG4gICAgICogdW5kZWZpbmVkIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIERvZXMgbm90IHJlYWQgdGhlIGZpbGVzeXN0ZW0sIHNvIGFuIHVuZGVmaW5lZCByZXN1bHQgKmNvdWxkKiBzaW1wbHlcbiAgICAgKiBtZWFuIHRoYXQgd2UgaGF2ZW4ndCBjYWxsZWQgbHN0YXQgb24gaXQuXG4gICAgICovXG4gICAgbHN0YXRDYWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN0eXBlICYgTFNUQVRfQ0FMTEVEID8gdGhpcyA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjYWNoZWQgbGluayB0YXJnZXQgaWYgdGhlIGVudHJ5IGhhcyBiZWVuIHRoZSBzdWJqZWN0IG9mIGFcbiAgICAgKiBzdWNjZXNzZnVsIHJlYWRsaW5rLCBvciB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogRG9lcyBub3QgcmVhZCB0aGUgZmlsZXN5c3RlbSwgc28gYW4gdW5kZWZpbmVkIHJlc3VsdCAqY291bGQqIGp1c3QgbWVhbiB3ZVxuICAgICAqIGRvbid0IGhhdmUgYW55IGNhY2hlZCBkYXRhLiBPbmx5IHVzZSBpdCBpZiB5b3UgYXJlIHZlcnkgc3VyZSB0aGF0IGFcbiAgICAgKiByZWFkbGluaygpIGhhcyBiZWVuIGNhbGxlZCBhdCBzb21lIHBvaW50LlxuICAgICAqL1xuICAgIHJlYWRsaW5rQ2FjaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbGlua1RhcmdldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FjaGVkIHJlYWxwYXRoIHRhcmdldCBpZiB0aGUgZW50cnkgaGFzIGJlZW4gdGhlIHN1YmplY3RcbiAgICAgKiBvZiBhIHN1Y2Nlc3NmdWwgcmVhbHBhdGgsIG9yIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBEb2VzIG5vdCByZWFkIHRoZSBmaWxlc3lzdGVtLCBzbyBhbiB1bmRlZmluZWQgcmVzdWx0ICpjb3VsZCoganVzdCBtZWFuIHdlXG4gICAgICogZG9uJ3QgaGF2ZSBhbnkgY2FjaGVkIGRhdGEuIE9ubHkgdXNlIGl0IGlmIHlvdSBhcmUgdmVyeSBzdXJlIHRoYXQgYVxuICAgICAqIHJlYWxwYXRoKCkgaGFzIGJlZW4gY2FsbGVkIGF0IHNvbWUgcG9pbnQuXG4gICAgICovXG4gICAgcmVhbHBhdGhDYWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNyZWFscGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FjaGVkIGNoaWxkIFBhdGggZW50cmllcyBhcnJheSBpZiB0aGUgZW50cnkgaGFzIGJlZW4gdGhlXG4gICAgICogc3ViamVjdCBvZiBhIHN1Y2Nlc3NmdWwgcmVhZGRpcigpLCBvciBbXSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBEb2VzIG5vdCByZWFkIHRoZSBmaWxlc3lzdGVtLCBzbyBhbiBlbXB0eSBhcnJheSAqY291bGQqIGp1c3QgbWVhbiB3ZVxuICAgICAqIGRvbid0IGhhdmUgYW55IGNhY2hlZCBkYXRhLiBPbmx5IHVzZSBpdCBpZiB5b3UgYXJlIHZlcnkgc3VyZSB0aGF0IGFcbiAgICAgKiByZWFkZGlyKCkgaGFzIGJlZW4gY2FsbGVkIHJlY2VudGx5IGVub3VnaCB0byBzdGlsbCBiZSB2YWxpZC5cbiAgICAgKi9cbiAgICByZWFkZGlyQ2FjaGVkKCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuLnNsaWNlKDAsIGNoaWxkcmVuLnByb3Zpc2lvbmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgaXQncyB3b3J0aCB0cnlpbmcgdG8gcmVhZGxpbmsuICBJZSwgd2UgZG9uJ3QgKHlldCkgaGF2ZVxuICAgICAqIGFueSBpbmRpY2F0aW9uIHRoYXQgcmVhZGxpbmsgd2lsbCBkZWZpbml0ZWx5IGZhaWwuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGZhbHNlIGlmIHRoZSBwYXRoIGlzIGtub3duIHRvIG5vdCBiZSBhIHN5bWxpbmssIGlmIGEgcHJldmlvdXNcbiAgICAgKiByZWFkbGluayBmYWlsZWQsIG9yIGlmIHRoZSBlbnRyeSBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cbiAgICBjYW5SZWFkbGluaygpIHtcbiAgICAgICAgaWYgKHRoaXMuI2xpbmtUYXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gY2FzZXMgd2hlcmUgaXQgY2Fubm90IHBvc3NpYmx5IHN1Y2NlZWRcbiAgICAgICAgY29uc3QgaWZtdCA9IHRoaXMuI3R5cGUgJiBJRk1UO1xuICAgICAgICByZXR1cm4gISgoaWZtdCAhPT0gVU5LTk9XTiAmJiBpZm10ICE9PSBJRkxOSykgfHxcbiAgICAgICAgICAgIHRoaXMuI3R5cGUgJiBFTk9SRUFETElOSyB8fFxuICAgICAgICAgICAgdGhpcy4jdHlwZSAmIEVOT0VOVCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHJlYWRkaXIgaGFzIHByZXZpb3VzbHkgYmVlbiBzdWNjZXNzZnVsbHkgY2FsbGVkIG9uIHRoaXNcbiAgICAgKiBwYXRoLCBpbmRpY2F0aW5nIHRoYXQgY2FjaGVkUmVhZGRpcigpIGlzIGxpa2VseSB2YWxpZC5cbiAgICAgKi9cbiAgICBjYWxsZWRSZWFkZGlyKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy4jdHlwZSAmIFJFQURESVJfQ0FMTEVEKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXRoIGlzIGtub3duIHRvIG5vdCBleGlzdC4gVGhhdCBpcywgYSBwcmV2aW91cyBsc3RhdFxuICAgICAqIG9yIHJlYWRkaXIgZmFpbGVkIHRvIHZlcmlmeSBpdHMgZXhpc3RlbmNlIHdoZW4gdGhhdCB3b3VsZCBoYXZlIGJlZW5cbiAgICAgKiBleHBlY3RlZCwgb3IgYSBwYXJlbnQgZW50cnkgd2FzIG1hcmtlZCBlaXRoZXIgZW5vZW50IG9yIGVub3RkaXIuXG4gICAgICovXG4gICAgaXNFTk9FTlQoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLiN0eXBlICYgRU5PRU5UKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHBhdGggaXMgYSBtYXRjaCBmb3IgdGhlIGdpdmVuIHBhdGggbmFtZS4gIFRoaXMgaGFuZGxlc1xuICAgICAqIGNhc2Ugc2Vuc2l0aXZpdHkgYW5kIHVuaWNvZGUgbm9ybWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIE5vdGU6IGV2ZW4gb24gY2FzZS1zZW5zaXRpdmUgc3lzdGVtcywgaXQgaXMgKipub3QqKiBzYWZlIHRvIHRlc3QgdGhlXG4gICAgICogZXF1YWxpdHkgb2YgdGhlIGAubmFtZWAgcHJvcGVydHkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBnaXZlbiBwYXRobmFtZVxuICAgICAqIG1hdGNoZXMsIGR1ZSB0byB1bmljb2RlIG5vcm1hbGl6YXRpb24gbWlzbWF0Y2hlcy5cbiAgICAgKlxuICAgICAqIEFsd2F5cyB1c2UgdGhpcyBtZXRob2QgaW5zdGVhZCBvZiB0ZXN0aW5nIHRoZSBgcGF0aC5uYW1lYCBwcm9wZXJ0eVxuICAgICAqIGRpcmVjdGx5LlxuICAgICAqL1xuICAgIGlzTmFtZWQobikge1xuICAgICAgICByZXR1cm4gIXRoaXMubm9jYXNlXG4gICAgICAgICAgICA/IHRoaXMuI21hdGNoTmFtZSA9PT0gbm9ybWFsaXplKG4pXG4gICAgICAgICAgICA6IHRoaXMuI21hdGNoTmFtZSA9PT0gbm9ybWFsaXplTm9jYXNlKG4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIFBhdGggb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHRhcmdldCBvZiBhIHN5bWJvbGljIGxpbmsuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgUGF0aCBpcyBub3QgYSBzeW1ib2xpYyBsaW5rLCBvciBpZiB0aGUgcmVhZGxpbmsgY2FsbCBmYWlscyBmb3IgYW55XG4gICAgICogcmVhc29uLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIFJlc3VsdCBpcyBjYWNoZWQsIGFuZCB0aHVzIG1heSBiZSBvdXRkYXRlZCBpZiB0aGUgZmlsZXN5c3RlbSBpcyBtdXRhdGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRsaW5rKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLiNsaW5rVGFyZ2V0O1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jYW5SZWFkbGluaygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAvLyBhbHJlYWR5IGNvdmVyZWQgYnkgdGhlIGNhblJlYWRsaW5rIHRlc3QsIGhlcmUgZm9yIHRzIGdydW1wbGVzXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWQgPSBhd2FpdCB0aGlzLiNmcy5wcm9taXNlcy5yZWFkbGluayh0aGlzLmZ1bGxwYXRoKCkpO1xuICAgICAgICAgICAgY29uc3QgbGlua1RhcmdldCA9IHRoaXMucGFyZW50LnJlc29sdmUocmVhZCk7XG4gICAgICAgICAgICBpZiAobGlua1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jbGlua1RhcmdldCA9IGxpbmtUYXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgdGhpcy4jcmVhZGxpbmtGYWlsKGVyLmNvZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91cyB7QGxpbmsgUGF0aEJhc2UucmVhZGxpbmt9XG4gICAgICovXG4gICAgcmVhZGxpbmtTeW5jKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLiNsaW5rVGFyZ2V0O1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jYW5SZWFkbGluaygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAvLyBhbHJlYWR5IGNvdmVyZWQgYnkgdGhlIGNhblJlYWRsaW5rIHRlc3QsIGhlcmUgZm9yIHRzIGdydW1wbGVzXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWQgPSB0aGlzLiNmcy5yZWFkbGlua1N5bmModGhpcy5mdWxscGF0aCgpKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtUYXJnZXQgPSB0aGlzLnBhcmVudC5yZXNvbHZlKHJlYWQpO1xuICAgICAgICAgICAgaWYgKGxpbmtUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuI2xpbmtUYXJnZXQgPSBsaW5rVGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIHRoaXMuI3JlYWRsaW5rRmFpbChlci5jb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI3JlYWRkaXJTdWNjZXNzKGNoaWxkcmVuKSB7XG4gICAgICAgIC8vIHN1Y2NlZWRlZCwgbWFyayByZWFkZGlyIGNhbGxlZCBiaXRcbiAgICAgICAgdGhpcy4jdHlwZSB8PSBSRUFERElSX0NBTExFRDtcbiAgICAgICAgLy8gbWFyayBhbGwgcmVtYWluaW5nIHByb3Zpc2lvbmFsIGNoaWxkcmVuIGFzIEVOT0VOVFxuICAgICAgICBmb3IgKGxldCBwID0gY2hpbGRyZW4ucHJvdmlzaW9uYWw7IHAgPCBjaGlsZHJlbi5sZW5ndGg7IHArKykge1xuICAgICAgICAgICAgY2hpbGRyZW5bcF0uI21hcmtFTk9FTlQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjbWFya0VOT0VOVCgpIHtcbiAgICAgICAgLy8gbWFyayBhcyBVTktOT1dOIGFuZCBFTk9FTlRcbiAgICAgICAgaWYgKHRoaXMuI3R5cGUgJiBFTk9FTlQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuI3R5cGUgPSAodGhpcy4jdHlwZSB8IEVOT0VOVCkgJiBJRk1UX1VOS05PV047XG4gICAgICAgIHRoaXMuI21hcmtDaGlsZHJlbkVOT0VOVCgpO1xuICAgIH1cbiAgICAjbWFya0NoaWxkcmVuRU5PRU5UKCkge1xuICAgICAgICAvLyBhbGwgY2hpbGRyZW4gYXJlIHByb3Zpc2lvbmFsIGFuZCBkbyBub3QgZXhpc3RcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XG4gICAgICAgIGNoaWxkcmVuLnByb3Zpc2lvbmFsID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBwLiNtYXJrRU5PRU5UKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI21hcmtFTk9SRUFMUEFUSCgpIHtcbiAgICAgICAgdGhpcy4jdHlwZSB8PSBFTk9SRUFMUEFUSDtcbiAgICAgICAgdGhpcy4jbWFya0VOT1RESVIoKTtcbiAgICB9XG4gICAgLy8gc2F2ZSB0aGUgaW5mb3JtYXRpb24gd2hlbiB3ZSBrbm93IHRoZSBlbnRyeSBpcyBub3QgYSBkaXJcbiAgICAjbWFya0VOT1RESVIoKSB7XG4gICAgICAgIC8vIGVudHJ5IGlzIG5vdCBhIGRpcmVjdG9yeSwgc28gYW55IGNoaWxkcmVuIGNhbid0IGV4aXN0LlxuICAgICAgICAvLyB0aGlzICpzaG91bGQqIGJlIGltcG9zc2libGUsIHNpbmNlIGFueSBjaGlsZHJlbiBjcmVhdGVkXG4gICAgICAgIC8vIGFmdGVyIGl0J3MgYmVlbiBtYXJrZWQgRU5PVERJUiBzaG91bGQgYmUgbWFya2VkIEVOT0VOVCxcbiAgICAgICAgLy8gc28gaXQgd29uJ3QgZXZlbiBnZXQgdG8gdGhpcyBwb2ludC5cbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzLiN0eXBlICYgRU5PVERJUilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgbGV0IHQgPSB0aGlzLiN0eXBlO1xuICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpZiB3ZSBzdGF0IGEgZGlyLCB0aGVuIGRlbGV0ZSBpdCxcbiAgICAgICAgLy8gdGhlbiB0cnkgdG8gcmVhZCBpdCBvciBvbmUgb2YgaXRzIGNoaWxkcmVuLlxuICAgICAgICBpZiAoKHQgJiBJRk1UKSA9PT0gSUZESVIpXG4gICAgICAgICAgICB0ICY9IElGTVRfVU5LTk9XTjtcbiAgICAgICAgdGhpcy4jdHlwZSA9IHQgfCBFTk9URElSO1xuICAgICAgICB0aGlzLiNtYXJrQ2hpbGRyZW5FTk9FTlQoKTtcbiAgICB9XG4gICAgI3JlYWRkaXJGYWlsKGNvZGUgPSAnJykge1xuICAgICAgICAvLyBtYXJrRU5PVERJUiBhbmQgbWFya0VOT0VOVCBhbHNvIHNldCBwcm92aXNpb25hbD0wXG4gICAgICAgIGlmIChjb2RlID09PSAnRU5PVERJUicgfHwgY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgICAgICAgdGhpcy4jbWFya0VOT1RESVIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgdGhpcy4jbWFya0VOT0VOVCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbigpLnByb3Zpc2lvbmFsID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjbHN0YXRGYWlsKGNvZGUgPSAnJykge1xuICAgICAgICAvLyBXaW5kb3dzIGp1c3QgcmFpc2VzIEVOT0VOVCBpbiB0aGlzIGNhc2UsIGRpc2FibGUgZm9yIHdpbiBDSVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKGNvZGUgPT09ICdFTk9URElSJykge1xuICAgICAgICAgICAgLy8gYWxyZWFkeSBrbm93IGl0IGhhcyBhIHBhcmVudCBieSB0aGlzIHBvaW50XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICBwLiNtYXJrRU5PVERJUigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgdGhpcy4jbWFya0VOT0VOVCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgICNyZWFkbGlua0ZhaWwoY29kZSA9ICcnKSB7XG4gICAgICAgIGxldCB0ZXIgPSB0aGlzLiN0eXBlO1xuICAgICAgICB0ZXIgfD0gRU5PUkVBRExJTks7XG4gICAgICAgIGlmIChjb2RlID09PSAnRU5PRU5UJylcbiAgICAgICAgICAgIHRlciB8PSBFTk9FTlQ7XG4gICAgICAgIC8vIHdpbmRvd3MgZ2V0cyBhIHdlaXJkIGVycm9yIHdoZW4geW91IHRyeSB0byByZWFkbGluayBhIGZpbGVcbiAgICAgICAgaWYgKGNvZGUgPT09ICdFSU5WQUwnIHx8IGNvZGUgPT09ICdVTktOT1dOJykge1xuICAgICAgICAgICAgLy8gZXhpc3RzLCBidXQgbm90IGEgc3ltbGluaywgd2UgZG9uJ3Qga25vdyBXSEFUIGl0IGlzLCBzbyByZW1vdmVcbiAgICAgICAgICAgIC8vIGFsbCBJRk1UIGJpdHMuXG4gICAgICAgICAgICB0ZXIgJj0gSUZNVF9VTktOT1dOO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3R5cGUgPSB0ZXI7XG4gICAgICAgIC8vIHdpbmRvd3MganVzdCBnZXRzIEVOT0VOVCBpbiB0aGlzIGNhc2UuICBXZSBkbyBjb3ZlciB0aGUgY2FzZSxcbiAgICAgICAgLy8ganVzdCBkaXNhYmxlZCBiZWNhdXNlIGl0J3MgaW1wb3NzaWJsZSBvbiBXaW5kb3dzIENJXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoY29kZSA9PT0gJ0VOT1RESVInICYmIHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC4jbWFya0VOT1RESVIoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIH1cbiAgICAjcmVhZGRpckFkZENoaWxkKGUsIGMpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNyZWFkZGlyTWF5YmVQcm9tb3RlQ2hpbGQoZSwgYykgfHxcbiAgICAgICAgICAgIHRoaXMuI3JlYWRkaXJBZGROZXdDaGlsZChlLCBjKSk7XG4gICAgfVxuICAgICNyZWFkZGlyQWRkTmV3Q2hpbGQoZSwgYykge1xuICAgICAgICAvLyBhbGxvYyBuZXcgZW50cnkgYXQgaGVhZCwgc28gaXQncyBuZXZlciBwcm92aXNpb25hbFxuICAgICAgICBjb25zdCB0eXBlID0gZW50VG9UeXBlKGUpO1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMubmV3Q2hpbGQoZS5uYW1lLCB0eXBlLCB7IHBhcmVudDogdGhpcyB9KTtcbiAgICAgICAgY29uc3QgaWZtdCA9IGNoaWxkLiN0eXBlICYgSUZNVDtcbiAgICAgICAgaWYgKGlmbXQgIT09IElGRElSICYmIGlmbXQgIT09IElGTE5LICYmIGlmbXQgIT09IFVOS05PV04pIHtcbiAgICAgICAgICAgIGNoaWxkLiN0eXBlIHw9IEVOT1RESVI7XG4gICAgICAgIH1cbiAgICAgICAgYy51bnNoaWZ0KGNoaWxkKTtcbiAgICAgICAgYy5wcm92aXNpb25hbCsrO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgICNyZWFkZGlyTWF5YmVQcm9tb3RlQ2hpbGQoZSwgYykge1xuICAgICAgICBmb3IgKGxldCBwID0gYy5wcm92aXNpb25hbDsgcCA8IGMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBjaGlsZCA9IGNbcF07XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5ub2Nhc2VcbiAgICAgICAgICAgICAgICA/IG5vcm1hbGl6ZU5vY2FzZShlLm5hbWUpXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemUoZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBwY2hpbGQuI21hdGNoTmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3JlYWRkaXJQcm9tb3RlQ2hpbGQoZSwgcGNoaWxkLCBwLCBjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjcmVhZGRpclByb21vdGVDaGlsZChlLCBwLCBpbmRleCwgYykge1xuICAgICAgICBjb25zdCB2ID0gcC5uYW1lO1xuICAgICAgICAvLyByZXRhaW4gYW55IG90aGVyIGZsYWdzLCBidXQgc2V0IGlmbXQgZnJvbSBkaXJlbnRcbiAgICAgICAgcC4jdHlwZSA9IChwLiN0eXBlICYgSUZNVF9VTktOT1dOKSB8IGVudFRvVHlwZShlKTtcbiAgICAgICAgLy8gY2FzZSBzZW5zaXRpdml0eSBmaXhpbmcgd2hlbiB3ZSBsZWFybiB0aGUgdHJ1ZSBuYW1lLlxuICAgICAgICBpZiAodiAhPT0gZS5uYW1lKVxuICAgICAgICAgICAgcC5uYW1lID0gZS5uYW1lO1xuICAgICAgICAvLyBqdXN0IGFkdmFuY2UgcHJvdmlzaW9uYWwgaW5kZXggKHBvdGVudGlhbGx5IG9mZiB0aGUgbGlzdCksXG4gICAgICAgIC8vIG90aGVyd2lzZSB3ZSBoYXZlIHRvIHNwbGljZS9wb3AgaXQgb3V0IGFuZCByZS1pbnNlcnQgYXQgaGVhZFxuICAgICAgICBpZiAoaW5kZXggIT09IGMucHJvdmlzaW9uYWwpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gYy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIGMucG9wKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgYy51bnNoaWZ0KHApO1xuICAgICAgICB9XG4gICAgICAgIGMucHJvdmlzaW9uYWwrKztcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgbHN0YXQoKSBvbiB0aGlzIFBhdGgsIGFuZCB1cGRhdGUgYWxsIGtub3duIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlXG4gICAgICogZGV0ZXJtaW5lZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB1bmxpa2UgYGZzLmxzdGF0KClgLCB0aGUgcmV0dXJuZWQgdmFsdWUgZG9lcyBub3QgY29udGFpbiBzb21lXG4gICAgICogaW5mb3JtYXRpb24sIHN1Y2ggYXMgYG1vZGVgLCBgZGV2YCwgYG5saW5rYCwgYW5kIGBpbm9gLiAgSWYgdGhhdFxuICAgICAqIGluZm9ybWF0aW9uIGlzIHJlcXVpcmVkLCB5b3Ugd2lsbCBuZWVkIHRvIGNhbGwgYGZzLmxzdGF0YCB5b3Vyc2VsZi5cbiAgICAgKlxuICAgICAqIElmIHRoZSBQYXRoIHJlZmVycyB0byBhIG5vbmV4aXN0ZW50IGZpbGUsIG9yIGlmIHRoZSBsc3RhdCBjYWxsIGZhaWxzIGZvclxuICAgICAqIGFueSByZWFzb24sIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLiAgT3RoZXJ3aXNlIHRoZSB1cGRhdGVkIFBhdGggb2JqZWN0IGlzXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBSZXN1bHRzIGFyZSBjYWNoZWQsIGFuZCB0aHVzIG1heSBiZSBvdXQgb2YgZGF0ZSBpZiB0aGUgZmlsZXN5c3RlbSBpc1xuICAgICAqIG11dGF0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgbHN0YXQoKSB7XG4gICAgICAgIGlmICgodGhpcy4jdHlwZSAmIEVOT0VOVCkgPT09IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYXBwbHlTdGF0KGF3YWl0IHRoaXMuI2ZzLnByb21pc2VzLmxzdGF0KHRoaXMuZnVsbHBhdGgoKSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbHN0YXRGYWlsKGVyLmNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHN5bmNocm9ub3VzIHtAbGluayBQYXRoQmFzZS5sc3RhdH1cbiAgICAgKi9cbiAgICBsc3RhdFN5bmMoKSB7XG4gICAgICAgIGlmICgodGhpcy4jdHlwZSAmIEVOT0VOVCkgPT09IDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jYXBwbHlTdGF0KHRoaXMuI2ZzLmxzdGF0U3luYyh0aGlzLmZ1bGxwYXRoKCkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuI2xzdGF0RmFpbChlci5jb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAjYXBwbHlTdGF0KHN0KSB7XG4gICAgICAgIGNvbnN0IHsgYXRpbWUsIGF0aW1lTXMsIGJpcnRodGltZSwgYmlydGh0aW1lTXMsIGJsa3NpemUsIGJsb2NrcywgY3RpbWUsIGN0aW1lTXMsIGRldiwgZ2lkLCBpbm8sIG1vZGUsIG10aW1lLCBtdGltZU1zLCBubGluaywgcmRldiwgc2l6ZSwgdWlkLCB9ID0gc3Q7XG4gICAgICAgIHRoaXMuI2F0aW1lID0gYXRpbWU7XG4gICAgICAgIHRoaXMuI2F0aW1lTXMgPSBhdGltZU1zO1xuICAgICAgICB0aGlzLiNiaXJ0aHRpbWUgPSBiaXJ0aHRpbWU7XG4gICAgICAgIHRoaXMuI2JpcnRodGltZU1zID0gYmlydGh0aW1lTXM7XG4gICAgICAgIHRoaXMuI2Jsa3NpemUgPSBibGtzaXplO1xuICAgICAgICB0aGlzLiNibG9ja3MgPSBibG9ja3M7XG4gICAgICAgIHRoaXMuI2N0aW1lID0gY3RpbWU7XG4gICAgICAgIHRoaXMuI2N0aW1lTXMgPSBjdGltZU1zO1xuICAgICAgICB0aGlzLiNkZXYgPSBkZXY7XG4gICAgICAgIHRoaXMuI2dpZCA9IGdpZDtcbiAgICAgICAgdGhpcy4jaW5vID0gaW5vO1xuICAgICAgICB0aGlzLiNtb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy4jbXRpbWUgPSBtdGltZTtcbiAgICAgICAgdGhpcy4jbXRpbWVNcyA9IG10aW1lTXM7XG4gICAgICAgIHRoaXMuI25saW5rID0gbmxpbms7XG4gICAgICAgIHRoaXMuI3JkZXYgPSByZGV2O1xuICAgICAgICB0aGlzLiNzaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy4jdWlkID0gdWlkO1xuICAgICAgICBjb25zdCBpZm10ID0gZW50VG9UeXBlKHN0KTtcbiAgICAgICAgLy8gcmV0YWluIGFueSBvdGhlciBmbGFncywgYnV0IHNldCB0aGUgaWZtdFxuICAgICAgICB0aGlzLiN0eXBlID0gKHRoaXMuI3R5cGUgJiBJRk1UX1VOS05PV04pIHwgaWZtdCB8IExTVEFUX0NBTExFRDtcbiAgICAgICAgaWYgKGlmbXQgIT09IFVOS05PV04gJiYgaWZtdCAhPT0gSUZESVIgJiYgaWZtdCAhPT0gSUZMTkspIHtcbiAgICAgICAgICAgIHRoaXMuI3R5cGUgfD0gRU5PVERJUjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjb25SZWFkZGlyQ0IgPSBbXTtcbiAgICAjcmVhZGRpckNCSW5GbGlnaHQgPSBmYWxzZTtcbiAgICAjY2FsbE9uUmVhZGRpckNCKGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMuI3JlYWRkaXJDQkluRmxpZ2h0ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNicyA9IHRoaXMuI29uUmVhZGRpckNCLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuI29uUmVhZGRpckNCLmxlbmd0aCA9IDA7XG4gICAgICAgIGNicy5mb3JFYWNoKGNiID0+IGNiKG51bGwsIGNoaWxkcmVuKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIG5vZGUtc3R5bGUgY2FsbGJhY2sgaW50ZXJmYWNlIHRvIGdldCBsaXN0IG9mIGRpcmVjdG9yeSBlbnRyaWVzLlxuICAgICAqXG4gICAgICogSWYgdGhlIFBhdGggY2Fubm90IG9yIGRvZXMgbm90IGNvbnRhaW4gYW55IGNoaWxkcmVuLCB0aGVuIGFuIGVtcHR5IGFycmF5XG4gICAgICogaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBSZXN1bHRzIGFyZSBjYWNoZWQsIGFuZCB0aHVzIG1heSBiZSBvdXQgb2YgZGF0ZSBpZiB0aGUgZmlsZXN5c3RlbSBpc1xuICAgICAqIG11dGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2IgVGhlIGNhbGxiYWNrIGNhbGxlZCB3aXRoIChlciwgZW50cmllcykuICBOb3RlIHRoYXQgdGhlIGBlcmBcbiAgICAgKiBwYXJhbSBpcyBzb21ld2hhdCBleHRyYW5lb3VzLCBhcyBhbGwgcmVhZGRpcigpIGVycm9ycyBhcmUgaGFuZGxlZCBhbmRcbiAgICAgKiBzaW1wbHkgcmVzdWx0IGluIGFuIGVtcHR5IHNldCBvZiBlbnRyaWVzIGJlaW5nIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSBhbGxvd1phbGdvIEJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IGltbWVkaWF0ZWx5IGtub3duIHJlc3VsdHMgc2hvdWxkXG4gICAgICogKm5vdCogYmUgZGVmZXJyZWQgd2l0aCBgcXVldWVNaWNyb3Rhc2tgLiBEZWZhdWx0cyB0byBgZmFsc2VgLiBSZWxlYXNlXG4gICAgICogemFsZ28gYXQgeW91ciBwZXJpbCwgdGhlIGRhcmsgcG9ueSBsb3JkIGlzIGRldmlvdXMgYW5kIHVuZm9yZ2l2aW5nLlxuICAgICAqL1xuICAgIHJlYWRkaXJDQihjYiwgYWxsb3daYWxnbyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW5SZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1phbGdvKVxuICAgICAgICAgICAgICAgIGNiKG51bGwsIFtdKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYihudWxsLCBbXSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbigpO1xuICAgICAgICBpZiAodGhpcy5jYWxsZWRSZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjaGlsZHJlbi5zbGljZSgwLCBjaGlsZHJlbi5wcm92aXNpb25hbCk7XG4gICAgICAgICAgICBpZiAoYWxsb3daYWxnbylcbiAgICAgICAgICAgICAgICBjYihudWxsLCBjKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYihudWxsLCBjKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCB6YWxnbyBhdCB0aGlzIHBvaW50LlxuICAgICAgICB0aGlzLiNvblJlYWRkaXJDQi5wdXNoKGNiKTtcbiAgICAgICAgaWYgKHRoaXMuI3JlYWRkaXJDQkluRmxpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcmVhZGRpckNCSW5GbGlnaHQgPSB0cnVlO1xuICAgICAgICAvLyBlbHNlIHJlYWQgdGhlIGRpcmVjdG9yeSwgZmlsbCB1cCBjaGlsZHJlblxuICAgICAgICAvLyBkZS1wcm92aXNpb25hbGl6ZSBhbnkgcHJvdmlzaW9uYWwgY2hpbGRyZW4uXG4gICAgICAgIGNvbnN0IGZ1bGxwYXRoID0gdGhpcy5mdWxscGF0aCgpO1xuICAgICAgICB0aGlzLiNmcy5yZWFkZGlyKGZ1bGxwYXRoLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSwgKGVyLCBlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNyZWFkZGlyRmFpbChlci5jb2RlKTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wcm92aXNpb25hbCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGFuIGVycm9yLCB3ZSBhbHdheXMgZ2V0IGVudHJpZXMuXG4gICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcmVhZGRpckFkZENoaWxkKGUsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVhZGRpclN1Y2Nlc3MoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jY2FsbE9uUmVhZGRpckNCKGNoaWxkcmVuLnNsaWNlKDAsIGNoaWxkcmVuLnByb3Zpc2lvbmFsKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAjYXN5bmNSZWFkZGlySW5GbGlnaHQ7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIGtub3duIGNoaWxkIGVudHJpZXMuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgUGF0aCBjYW5ub3Qgb3IgZG9lcyBub3QgY29udGFpbiBhbnkgY2hpbGRyZW4sIHRoZW4gYW4gZW1wdHkgYXJyYXlcbiAgICAgKiBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIFJlc3VsdHMgYXJlIGNhY2hlZCwgYW5kIHRodXMgbWF5IGJlIG91dCBvZiBkYXRlIGlmIHRoZSBmaWxlc3lzdGVtIGlzXG4gICAgICogbXV0YXRlZC5cbiAgICAgKi9cbiAgICBhc3luYyByZWFkZGlyKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2FuUmVhZGRpcigpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XG4gICAgICAgIGlmICh0aGlzLmNhbGxlZFJlYWRkaXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuLnNsaWNlKDAsIGNoaWxkcmVuLnByb3Zpc2lvbmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIHJlYWQgdGhlIGRpcmVjdG9yeSwgZmlsbCB1cCBjaGlsZHJlblxuICAgICAgICAvLyBkZS1wcm92aXNpb25hbGl6ZSBhbnkgcHJvdmlzaW9uYWwgY2hpbGRyZW4uXG4gICAgICAgIGNvbnN0IGZ1bGxwYXRoID0gdGhpcy5mdWxscGF0aCgpO1xuICAgICAgICBpZiAodGhpcy4jYXN5bmNSZWFkZGlySW5GbGlnaHQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuI2FzeW5jUmVhZGRpckluRmxpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB0aGlzLiNhc3luY1JlYWRkaXJJbkZsaWdodCA9IG5ldyBQcm9taXNlKHJlcyA9PiAocmVzb2x2ZSA9IHJlcykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgYXdhaXQgdGhpcy4jZnMucHJvbWlzZXMucmVhZGRpcihmdWxscGF0aCwge1xuICAgICAgICAgICAgICAgICAgICB3aXRoRmlsZVR5cGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3JlYWRkaXJBZGRDaGlsZChlLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI3JlYWRkaXJTdWNjZXNzKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuI3JlYWRkaXJGYWlsKGVyLmNvZGUpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnByb3Zpc2lvbmFsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2FzeW5jUmVhZGRpckluRmxpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5zbGljZSgwLCBjaGlsZHJlbi5wcm92aXNpb25hbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHN5bmNocm9ub3VzIHtAbGluayBQYXRoQmFzZS5yZWFkZGlyfVxuICAgICAqL1xuICAgIHJlYWRkaXJTeW5jKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2FuUmVhZGRpcigpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XG4gICAgICAgIGlmICh0aGlzLmNhbGxlZFJlYWRkaXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuLnNsaWNlKDAsIGNoaWxkcmVuLnByb3Zpc2lvbmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIHJlYWQgdGhlIGRpcmVjdG9yeSwgZmlsbCB1cCBjaGlsZHJlblxuICAgICAgICAvLyBkZS1wcm92aXNpb25hbGl6ZSBhbnkgcHJvdmlzaW9uYWwgY2hpbGRyZW4uXG4gICAgICAgIGNvbnN0IGZ1bGxwYXRoID0gdGhpcy5mdWxscGF0aCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIHRoaXMuI2ZzLnJlYWRkaXJTeW5jKGZ1bGxwYXRoLCB7XG4gICAgICAgICAgICAgICAgd2l0aEZpbGVUeXBlczogdHJ1ZSxcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVhZGRpckFkZENoaWxkKGUsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI3JlYWRkaXJTdWNjZXNzKGNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgIHRoaXMuI3JlYWRkaXJGYWlsKGVyLmNvZGUpO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHJvdmlzaW9uYWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5zbGljZSgwLCBjaGlsZHJlbi5wcm92aXNpb25hbCk7XG4gICAgfVxuICAgIGNhblJlYWRkaXIoKSB7XG4gICAgICAgIGlmICh0aGlzLiN0eXBlICYgRU5PQ0hJTEQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGlmbXQgPSBJRk1UICYgdGhpcy4jdHlwZTtcbiAgICAgICAgLy8gd2UgYWx3YXlzIHNldCBFTk9URElSIHdoZW4gc2V0dGluZyBJRk1ULCBzbyBzaG91bGQgYmUgaW1wb3NzaWJsZVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCEoaWZtdCA9PT0gVU5LTk9XTiB8fCBpZm10ID09PSBJRkRJUiB8fCBpZm10ID09PSBJRkxOSykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2hvdWxkV2FsayhkaXJzLCB3YWxrRmlsdGVyKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMuI3R5cGUgJiBJRkRJUikgPT09IElGRElSICYmXG4gICAgICAgICAgICAhKHRoaXMuI3R5cGUgJiBFTk9DSElMRCkgJiZcbiAgICAgICAgICAgICFkaXJzLmhhcyh0aGlzKSAmJlxuICAgICAgICAgICAgKCF3YWxrRmlsdGVyIHx8IHdhbGtGaWx0ZXIodGhpcykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBQYXRoIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHBhdGggYXMgcmVzb2x2ZWRcbiAgICAgKiBieSByZWFscGF0aCgzKS5cbiAgICAgKlxuICAgICAqIElmIHRoZSByZWFscGF0aCBjYWxsIGZhaWxzIGZvciBhbnkgcmVhc29uLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIFJlc3VsdCBpcyBjYWNoZWQsIGFuZCB0aHVzIG1heSBiZSBvdXRkYXRlZCBpZiB0aGUgZmlsZXN5c3RlbSBpcyBtdXRhdGVkLlxuICAgICAqIE9uIHN1Y2Nlc3MsIHJldHVybnMgYSBQYXRoIG9iamVjdC5cbiAgICAgKi9cbiAgICBhc3luYyByZWFscGF0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI3JlYWxwYXRoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3JlYWxwYXRoO1xuICAgICAgICBpZiAoKEVOT1JFQUxQQVRIIHwgRU5PUkVBRExJTksgfCBFTk9FTlQpICYgdGhpcy4jdHlwZSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBycCA9IGF3YWl0IHRoaXMuI2ZzLnByb21pc2VzLnJlYWxwYXRoKHRoaXMuZnVsbHBhdGgoKSk7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3JlYWxwYXRoID0gdGhpcy5yZXNvbHZlKHJwKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHRoaXMuI21hcmtFTk9SRUFMUEFUSCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9ub3VzIHtAbGluayByZWFscGF0aH1cbiAgICAgKi9cbiAgICByZWFscGF0aFN5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLiNyZWFscGF0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZWFscGF0aDtcbiAgICAgICAgaWYgKChFTk9SRUFMUEFUSCB8IEVOT1JFQURMSU5LIHwgRU5PRU5UKSAmIHRoaXMuI3R5cGUpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcnAgPSB0aGlzLiNmcy5yZWFscGF0aFN5bmModGhpcy5mdWxscGF0aCgpKTtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jcmVhbHBhdGggPSB0aGlzLnJlc29sdmUocnApKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgdGhpcy4jbWFya0VOT1JFQUxQQVRIKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIG1hcmsgdGhpcyBQYXRoIG9iamVjdCBhcyB0aGUgc2N1cnJ5IGN3ZCxcbiAgICAgKiBjYWxsZWQgYnkge0BsaW5rIFBhdGhTY3VycnkjY2hkaXJ9XG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBbc2V0QXNDd2RdKG9sZEN3ZCkge1xuICAgICAgICBpZiAob2xkQ3dkID09PSB0aGlzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjaGFuZ2VkID0gbmV3IFNldChbXSk7XG4gICAgICAgIGxldCBycCA9IFtdO1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChwICYmIHAucGFyZW50KSB7XG4gICAgICAgICAgICBjaGFuZ2VkLmFkZChwKTtcbiAgICAgICAgICAgIHAuI3JlbGF0aXZlID0gcnAuam9pbih0aGlzLnNlcCk7XG4gICAgICAgICAgICBwLiNyZWxhdGl2ZVBvc2l4ID0gcnAuam9pbignLycpO1xuICAgICAgICAgICAgcCA9IHAucGFyZW50O1xuICAgICAgICAgICAgcnAucHVzaCgnLi4nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBub3cgdW4tbWVtb2l6ZSBwYXJlbnRzIG9mIG9sZCBjd2RcbiAgICAgICAgcCA9IG9sZEN3ZDtcbiAgICAgICAgd2hpbGUgKHAgJiYgcC5wYXJlbnQgJiYgIWNoYW5nZWQuaGFzKHApKSB7XG4gICAgICAgICAgICBwLiNyZWxhdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHAuI3JlbGF0aXZlUG9zaXggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwID0gcC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlBhdGhCYXNlID0gUGF0aEJhc2U7XG4vKipcbiAqIFBhdGggY2xhc3MgdXNlZCBvbiB3aW4zMiBzeXN0ZW1zXG4gKlxuICogVXNlcyBgJ1xcXFwnYCBhcyB0aGUgcGF0aCBzZXBhcmF0b3IgZm9yIHJldHVybmVkIHBhdGhzLCBlaXRoZXIgYCdcXFxcJ2Agb3IgYCcvJ2BcbiAqIGFzIHRoZSBwYXRoIHNlcGFyYXRvciBmb3IgcGFyc2luZyBwYXRocy5cbiAqL1xuY2xhc3MgUGF0aFdpbjMyIGV4dGVuZHMgUGF0aEJhc2Uge1xuICAgIC8qKlxuICAgICAqIFNlcGFyYXRvciBmb3IgZ2VuZXJhdGluZyBwYXRoIHN0cmluZ3MuXG4gICAgICovXG4gICAgc2VwID0gJ1xcXFwnO1xuICAgIC8qKlxuICAgICAqIFNlcGFyYXRvciBmb3IgcGFyc2luZyBwYXRoIHN0cmluZ3MuXG4gICAgICovXG4gICAgc3BsaXRTZXAgPSBlaXRoZXJTZXA7XG4gICAgLyoqXG4gICAgICogRG8gbm90IGNyZWF0ZSBuZXcgUGF0aCBvYmplY3RzIGRpcmVjdGx5LiAgVGhleSBzaG91bGQgYWx3YXlzIGJlIGFjY2Vzc2VkXG4gICAgICogdmlhIHRoZSBQYXRoU2N1cnJ5IGNsYXNzIG9yIG90aGVyIG1ldGhvZHMgb24gdGhlIFBhdGggY2xhc3MuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlID0gVU5LTk9XTiwgcm9vdCwgcm9vdHMsIG5vY2FzZSwgY2hpbGRyZW4sIG9wdHMpIHtcbiAgICAgICAgc3VwZXIobmFtZSwgdHlwZSwgcm9vdCwgcm9vdHMsIG5vY2FzZSwgY2hpbGRyZW4sIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBuZXdDaGlsZChuYW1lLCB0eXBlID0gVU5LTk9XTiwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aFdpbjMyKG5hbWUsIHR5cGUsIHRoaXMucm9vdCwgdGhpcy5yb290cywgdGhpcy5ub2Nhc2UsIHRoaXMuY2hpbGRyZW5DYWNoZSgpLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0Um9vdFN0cmluZyhwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoXzEud2luMzIucGFyc2UocGF0aCkucm9vdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0Um9vdChyb290UGF0aCkge1xuICAgICAgICByb290UGF0aCA9IHVuY1RvRHJpdmUocm9vdFBhdGgudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIGlmIChyb290UGF0aCA9PT0gdGhpcy5yb290Lm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2ssIG5vdCB0aGF0IG9uZSwgY2hlY2sgaWYgaXQgbWF0Y2hlcyBhbm90aGVyIHdlIGtub3cgYWJvdXRcbiAgICAgICAgZm9yIChjb25zdCBbY29tcGFyZSwgcm9vdF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5yb290cykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNhbWVSb290KHJvb3RQYXRoLCBjb21wYXJlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5yb290c1tyb290UGF0aF0gPSByb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UsIGhhdmUgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgICAgcmV0dXJuICh0aGlzLnJvb3RzW3Jvb3RQYXRoXSA9IG5ldyBQYXRoU2N1cnJ5V2luMzIocm9vdFBhdGgsIHRoaXMpLnJvb3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzYW1lUm9vdChyb290UGF0aCwgY29tcGFyZSA9IHRoaXMucm9vdC5uYW1lKSB7XG4gICAgICAgIC8vIHdpbmRvd3MgY2FuIChyYXJlbHkpIGhhdmUgY2FzZS1zZW5zaXRpdmUgZmlsZXN5c3RlbSwgYnV0XG4gICAgICAgIC8vIFVOQyBhbmQgZHJpdmUgbGV0dGVycyBhcmUgYWx3YXlzIGNhc2UtaW5zZW5zaXRpdmUsIGFuZCBjYW5vbmljYWxseVxuICAgICAgICAvLyByZXByZXNlbnRlZCB1cHBlcmNhc2UuXG4gICAgICAgIHJvb3RQYXRoID0gcm9vdFBhdGhcbiAgICAgICAgICAgIC50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwvL2csICdcXFxcJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHVuY0RyaXZlUmVnZXhwLCAnJDFcXFxcJyk7XG4gICAgICAgIHJldHVybiByb290UGF0aCA9PT0gY29tcGFyZTtcbiAgICB9XG59XG5leHBvcnRzLlBhdGhXaW4zMiA9IFBhdGhXaW4zMjtcbi8qKlxuICogUGF0aCBjbGFzcyB1c2VkIG9uIGFsbCBwb3NpeCBzeXN0ZW1zLlxuICpcbiAqIFVzZXMgYCcvJ2AgYXMgdGhlIHBhdGggc2VwYXJhdG9yLlxuICovXG5jbGFzcyBQYXRoUG9zaXggZXh0ZW5kcyBQYXRoQmFzZSB7XG4gICAgLyoqXG4gICAgICogc2VwYXJhdG9yIGZvciBwYXJzaW5nIHBhdGggc3RyaW5nc1xuICAgICAqL1xuICAgIHNwbGl0U2VwID0gJy8nO1xuICAgIC8qKlxuICAgICAqIHNlcGFyYXRvciBmb3IgZ2VuZXJhdGluZyBwYXRoIHN0cmluZ3NcbiAgICAgKi9cbiAgICBzZXAgPSAnLyc7XG4gICAgLyoqXG4gICAgICogRG8gbm90IGNyZWF0ZSBuZXcgUGF0aCBvYmplY3RzIGRpcmVjdGx5LiAgVGhleSBzaG91bGQgYWx3YXlzIGJlIGFjY2Vzc2VkXG4gICAgICogdmlhIHRoZSBQYXRoU2N1cnJ5IGNsYXNzIG9yIG90aGVyIG1ldGhvZHMgb24gdGhlIFBhdGggY2xhc3MuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlID0gVU5LTk9XTiwgcm9vdCwgcm9vdHMsIG5vY2FzZSwgY2hpbGRyZW4sIG9wdHMpIHtcbiAgICAgICAgc3VwZXIobmFtZSwgdHlwZSwgcm9vdCwgcm9vdHMsIG5vY2FzZSwgY2hpbGRyZW4sIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXRSb290U3RyaW5nKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGguc3RhcnRzV2l0aCgnLycpID8gJy8nIDogJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldFJvb3QoX3Jvb3RQYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG5ld0NoaWxkKG5hbWUsIHR5cGUgPSBVTktOT1dOLCBvcHRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoUG9zaXgobmFtZSwgdHlwZSwgdGhpcy5yb290LCB0aGlzLnJvb3RzLCB0aGlzLm5vY2FzZSwgdGhpcy5jaGlsZHJlbkNhY2hlKCksIG9wdHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGF0aFBvc2l4ID0gUGF0aFBvc2l4O1xuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIFBhdGhTY3VycnkgY2xhc3NlcywgcHJvdmlkaW5nIHRoZSBpbnRlcmZhY2UgZm9yIHBhdGhcbiAqIHJlc29sdXRpb24gYW5kIGZpbGVzeXN0ZW0gb3BlcmF0aW9ucy5cbiAqXG4gKiBUeXBpY2FsbHksIHlvdSBzaG91bGQgKm5vdCogaW5zdGFudGlhdGUgdGhpcyBjbGFzcyBkaXJlY3RseSwgYnV0IHJhdGhlciBvbmVcbiAqIG9mIHRoZSBwbGF0Zm9ybS1zcGVjaWZpYyBjbGFzc2VzLCBvciB0aGUgZXhwb3J0ZWQge0BsaW5rIFBhdGhTY3Vycnl9IHdoaWNoXG4gKiBkZWZhdWx0cyB0byB0aGUgY3VycmVudCBwbGF0Zm9ybS5cbiAqL1xuY2xhc3MgUGF0aFNjdXJyeUJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSByb290IFBhdGggZW50cnkgZm9yIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IG9mIHRoaXMgU2N1cnJ5XG4gICAgICovXG4gICAgcm9vdDtcbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHBhdGggZm9yIHRoZSByb290IG9mIHRoaXMgU2N1cnJ5J3MgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICAgICAqL1xuICAgIHJvb3RQYXRoO1xuICAgIC8qKlxuICAgICAqIEEgY29sbGVjdGlvbiBvZiBhbGwgcm9vdHMgZW5jb3VudGVyZWQsIHJlZmVyZW5jZWQgYnkgcm9vdFBhdGhcbiAgICAgKi9cbiAgICByb290cztcbiAgICAvKipcbiAgICAgKiBUaGUgUGF0aCBlbnRyeSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgUGF0aFNjdXJyeSdzIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgY3dkO1xuICAgICNyZXNvbHZlQ2FjaGU7XG4gICAgI3Jlc29sdmVQb3NpeENhY2hlO1xuICAgICNjaGlsZHJlbjtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIHBhdGggY29tcGFyaXNvbnMgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdHJ1ZSBvbiBEYXJ3aW4gYW5kIFdpbmRvd3Mgc3lzdGVtcywgZmFsc2UgZWxzZXdoZXJlLlxuICAgICAqL1xuICAgIG5vY2FzZTtcbiAgICAjZnM7XG4gICAgLyoqXG4gICAgICogVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIFVzZSBQYXRoU2N1cnJ5V2luMzIsIFBhdGhTY3VycnlEYXJ3aW4sIFBhdGhTY3VycnlQb3NpeCwgb3IgUGF0aFNjdXJyeVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY3dkID0gcHJvY2Vzcy5jd2QoKSwgcGF0aEltcGwsIHNlcCwgeyBub2Nhc2UsIGNoaWxkcmVuQ2FjaGVTaXplID0gMTYgKiAxMDI0LCBmcyA9IGRlZmF1bHRGUywgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuI2ZzID0gZnNGcm9tT3B0aW9uKGZzKTtcbiAgICAgICAgaWYgKGN3ZCBpbnN0YW5jZW9mIFVSTCB8fCBjd2Quc3RhcnRzV2l0aCgnZmlsZTovLycpKSB7XG4gICAgICAgICAgICBjd2QgPSAoMCwgdXJsXzEuZmlsZVVSTFRvUGF0aCkoY3dkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNvbHZlIGFuZCBzcGxpdCByb290LCBhbmQgdGhlbiBhZGQgdG8gdGhlIHN0b3JlLlxuICAgICAgICAvLyB0aGlzIGlzIHRoZSBvbmx5IHRpbWUgd2UgY2FsbCBwYXRoLnJlc29sdmUoKVxuICAgICAgICBjb25zdCBjd2RQYXRoID0gcGF0aEltcGwucmVzb2x2ZShjd2QpO1xuICAgICAgICB0aGlzLnJvb3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5yb290UGF0aCA9IHRoaXMucGFyc2VSb290UGF0aChjd2RQYXRoKTtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZUNhY2hlID0gbmV3IFJlc29sdmVDYWNoZSgpO1xuICAgICAgICB0aGlzLiNyZXNvbHZlUG9zaXhDYWNoZSA9IG5ldyBSZXNvbHZlQ2FjaGUoKTtcbiAgICAgICAgdGhpcy4jY2hpbGRyZW4gPSBuZXcgQ2hpbGRyZW5DYWNoZShjaGlsZHJlbkNhY2hlU2l6ZSk7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gY3dkUGF0aC5zdWJzdHJpbmcodGhpcy5yb290UGF0aC5sZW5ndGgpLnNwbGl0KHNlcCk7XG4gICAgICAgIC8vIHJlc29sdmUoJy8nKSBsZWF2ZXMgJycsIHNwbGl0cyB0byBbJyddLCB3ZSBkb24ndCB3YW50IHRoYXQuXG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggPT09IDEgJiYgIXNwbGl0WzBdKSB7XG4gICAgICAgICAgICBzcGxpdC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKG5vY2FzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHByb3ZpZGUgbm9jYXNlIHNldHRpbmcgdG8gUGF0aFNjdXJyeUJhc2UgY3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHRoaXMubm9jYXNlID0gbm9jYXNlO1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLm5ld1Jvb3QodGhpcy4jZnMpO1xuICAgICAgICB0aGlzLnJvb3RzW3RoaXMucm9vdFBhdGhdID0gdGhpcy5yb290O1xuICAgICAgICBsZXQgcHJldiA9IHRoaXMucm9vdDtcbiAgICAgICAgbGV0IGxlbiA9IHNwbGl0Lmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGpvaW5TZXAgPSBwYXRoSW1wbC5zZXA7XG4gICAgICAgIGxldCBhYnMgPSB0aGlzLnJvb3RQYXRoO1xuICAgICAgICBsZXQgc2F3Rmlyc3QgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHNwbGl0KSB7XG4gICAgICAgICAgICBjb25zdCBsID0gbGVuLS07XG4gICAgICAgICAgICBwcmV2ID0gcHJldi5jaGlsZChwYXJ0LCB7XG4gICAgICAgICAgICAgICAgcmVsYXRpdmU6IG5ldyBBcnJheShsKS5maWxsKCcuLicpLmpvaW4oam9pblNlcCksXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVQb3NpeDogbmV3IEFycmF5KGwpLmZpbGwoJy4uJykuam9pbignLycpLFxuICAgICAgICAgICAgICAgIGZ1bGxwYXRoOiAoYWJzICs9IChzYXdGaXJzdCA/ICcnIDogam9pblNlcCkgKyBwYXJ0KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2F3Rmlyc3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3dkID0gcHJldjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZXB0aCBvZiBhIHByb3ZpZGVkIHBhdGgsIHN0cmluZywgb3IgdGhlIGN3ZFxuICAgICAqL1xuICAgIGRlcHRoKHBhdGggPSB0aGlzLmN3ZCkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXRoID0gdGhpcy5jd2QucmVzb2x2ZShwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5kZXB0aCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGNhY2hlIG9mIGNoaWxkIGVudHJpZXMuICBFeHBvc2VkIHNvIHN1YmNsYXNzZXMgY2FuIGNyZWF0ZVxuICAgICAqIGNoaWxkIFBhdGggb2JqZWN0cyBpbiBhIHBsYXRmb3JtLXNwZWNpZmljIHdheS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGNoaWxkcmVuQ2FjaGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjaGlsZHJlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBvbmUgb3IgbW9yZSBwYXRoIHN0cmluZ3MgdG8gYSByZXNvbHZlZCBzdHJpbmdcbiAgICAgKlxuICAgICAqIFNhbWUgaW50ZXJmYWNlIGFzIHJlcXVpcmUoJ3BhdGgnKS5yZXNvbHZlLlxuICAgICAqXG4gICAgICogTXVjaCBmYXN0ZXIgdGhhbiBwYXRoLnJlc29sdmUoKSB3aGVuIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWVcbiAgICAgKiBwYXRoLCBiZWNhdXNlIHRoZSByZXNvbHZlZCBQYXRoIG9iamVjdHMgYXJlIGNhY2hlZC4gIE11Y2ggc2xvd2VyXG4gICAgICogb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlc29sdmUoLi4ucGF0aHMpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlndXJlIG91dCB0aGUgbWluaW11bSBudW1iZXIgb2YgcGF0aHMgd2UgaGF2ZSB0byB0ZXN0XG4gICAgICAgIC8vIHdlIGFsd2F5cyBzdGFydCBhdCBjd2QsIGJ1dCBhbnkgYWJzb2x1dGVzIHdpbGwgYnVtcCB0aGUgc3RhcnRcbiAgICAgICAgbGV0IHIgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gcGF0aHNbaV07XG4gICAgICAgICAgICBpZiAoIXAgfHwgcCA9PT0gJy4nKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgciA9IHIgPyBgJHtwfS8ke3J9YCA6IHA7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Fic29sdXRlKHApKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy4jcmVzb2x2ZUNhY2hlLmdldChyKTtcbiAgICAgICAgaWYgKGNhY2hlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY3dkLnJlc29sdmUocikuZnVsbHBhdGgoKTtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZUNhY2hlLnNldChyLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIG9uZSBvciBtb3JlIHBhdGggc3RyaW5ncyB0byBhIHJlc29sdmVkIHN0cmluZywgcmV0dXJuaW5nXG4gICAgICogdGhlIHBvc2l4IHBhdGguICBJZGVudGljYWwgdG8gLnJlc29sdmUoKSBvbiBwb3NpeCBzeXN0ZW1zLCBidXQgb25cbiAgICAgKiB3aW5kb3dzIHdpbGwgcmV0dXJuIGEgZm9yd2FyZC1zbGFzaCBzZXBhcmF0ZWQgVU5DIHBhdGguXG4gICAgICpcbiAgICAgKiBTYW1lIGludGVyZmFjZSBhcyByZXF1aXJlKCdwYXRoJykucmVzb2x2ZS5cbiAgICAgKlxuICAgICAqIE11Y2ggZmFzdGVyIHRoYW4gcGF0aC5yZXNvbHZlKCkgd2hlbiBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzYW1lXG4gICAgICogcGF0aCwgYmVjYXVzZSB0aGUgcmVzb2x2ZWQgUGF0aCBvYmplY3RzIGFyZSBjYWNoZWQuICBNdWNoIHNsb3dlclxuICAgICAqIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICByZXNvbHZlUG9zaXgoLi4ucGF0aHMpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlndXJlIG91dCB0aGUgbWluaW11bSBudW1iZXIgb2YgcGF0aHMgd2UgaGF2ZSB0byB0ZXN0XG4gICAgICAgIC8vIHdlIGFsd2F5cyBzdGFydCBhdCBjd2QsIGJ1dCBhbnkgYWJzb2x1dGVzIHdpbGwgYnVtcCB0aGUgc3RhcnRcbiAgICAgICAgbGV0IHIgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gcGF0aHNbaV07XG4gICAgICAgICAgICBpZiAoIXAgfHwgcCA9PT0gJy4nKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgciA9IHIgPyBgJHtwfS8ke3J9YCA6IHA7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Fic29sdXRlKHApKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy4jcmVzb2x2ZVBvc2l4Q2FjaGUuZ2V0KHIpO1xuICAgICAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jd2QucmVzb2x2ZShyKS5mdWxscGF0aFBvc2l4KCk7XG4gICAgICAgIHRoaXMuI3Jlc29sdmVQb3NpeENhY2hlLnNldChyLCByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmaW5kIHRoZSByZWxhdGl2ZSBwYXRoIGZyb20gdGhlIGN3ZCB0byB0aGUgc3VwcGxpZWQgcGF0aCBzdHJpbmcgb3IgZW50cnlcbiAgICAgKi9cbiAgICByZWxhdGl2ZShlbnRyeSA9IHRoaXMuY3dkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS5yZWxhdGl2ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmaW5kIHRoZSByZWxhdGl2ZSBwYXRoIGZyb20gdGhlIGN3ZCB0byB0aGUgc3VwcGxpZWQgcGF0aCBzdHJpbmcgb3JcbiAgICAgKiBlbnRyeSwgdXNpbmcgLyBhcyB0aGUgcGF0aCBkZWxpbWl0ZXIsIGV2ZW4gb24gV2luZG93cy5cbiAgICAgKi9cbiAgICByZWxhdGl2ZVBvc2l4KGVudHJ5ID0gdGhpcy5jd2QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LnJlbGF0aXZlUG9zaXgoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBiYXNlbmFtZSBmb3IgdGhlIHByb3ZpZGVkIHN0cmluZyBvciBQYXRoIG9iamVjdFxuICAgICAqL1xuICAgIGJhc2VuYW1lKGVudHJ5ID0gdGhpcy5jd2QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5Lm5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZGlybmFtZSBmb3IgdGhlIHByb3ZpZGVkIHN0cmluZyBvciBQYXRoIG9iamVjdFxuICAgICAqL1xuICAgIGRpcm5hbWUoZW50cnkgPSB0aGlzLmN3ZCkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGVudHJ5LnBhcmVudCB8fCBlbnRyeSkuZnVsbHBhdGgoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZGRpcihlbnRyeSA9IHRoaXMuY3dkLCBvcHRzID0ge1xuICAgICAgICB3aXRoRmlsZVR5cGVzOiB0cnVlLFxuICAgIH0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgb3B0cyA9IGVudHJ5O1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpdGhGaWxlVHlwZXMgfSA9IG9wdHM7XG4gICAgICAgIGlmICghZW50cnkuY2FuUmVhZGRpcigpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwID0gYXdhaXQgZW50cnkucmVhZGRpcigpO1xuICAgICAgICAgICAgcmV0dXJuIHdpdGhGaWxlVHlwZXMgPyBwIDogcC5tYXAoZSA9PiBlLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWRkaXJTeW5jKGVudHJ5ID0gdGhpcy5jd2QsIG9wdHMgPSB7XG4gICAgICAgIHdpdGhGaWxlVHlwZXM6IHRydWUsXG4gICAgfSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICBvcHRzID0gZW50cnk7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgd2l0aEZpbGVUeXBlcyA9IHRydWUgfSA9IG9wdHM7XG4gICAgICAgIGlmICghZW50cnkuY2FuUmVhZGRpcigpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod2l0aEZpbGVUeXBlcykge1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5LnJlYWRkaXJTeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkucmVhZGRpclN5bmMoKS5tYXAoZSA9PiBlLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgbHN0YXQoKSBvbiB0aGUgc3RyaW5nIG9yIFBhdGggb2JqZWN0LCBhbmQgdXBkYXRlIGFsbCBrbm93blxuICAgICAqIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIGRldGVybWluZWQuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdW5saWtlIGBmcy5sc3RhdCgpYCwgdGhlIHJldHVybmVkIHZhbHVlIGRvZXMgbm90IGNvbnRhaW4gc29tZVxuICAgICAqIGluZm9ybWF0aW9uLCBzdWNoIGFzIGBtb2RlYCwgYGRldmAsIGBubGlua2AsIGFuZCBgaW5vYC4gIElmIHRoYXRcbiAgICAgKiBpbmZvcm1hdGlvbiBpcyByZXF1aXJlZCwgeW91IHdpbGwgbmVlZCB0byBjYWxsIGBmcy5sc3RhdGAgeW91cnNlbGYuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgUGF0aCByZWZlcnMgdG8gYSBub25leGlzdGVudCBmaWxlLCBvciBpZiB0aGUgbHN0YXQgY2FsbCBmYWlscyBmb3JcbiAgICAgKiBhbnkgcmVhc29uLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC4gIE90aGVyd2lzZSB0aGUgdXBkYXRlZCBQYXRoIG9iamVjdCBpc1xuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogUmVzdWx0cyBhcmUgY2FjaGVkLCBhbmQgdGh1cyBtYXkgYmUgb3V0IG9mIGRhdGUgaWYgdGhlIGZpbGVzeXN0ZW0gaXNcbiAgICAgKiBtdXRhdGVkLlxuICAgICAqL1xuICAgIGFzeW5jIGxzdGF0KGVudHJ5ID0gdGhpcy5jd2QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LmxzdGF0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHN5bmNocm9ub3VzIHtAbGluayBQYXRoU2N1cnJ5QmFzZS5sc3RhdH1cbiAgICAgKi9cbiAgICBsc3RhdFN5bmMoZW50cnkgPSB0aGlzLmN3ZCkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnkubHN0YXRTeW5jKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRsaW5rKGVudHJ5ID0gdGhpcy5jd2QsIHsgd2l0aEZpbGVUeXBlcyB9ID0ge1xuICAgICAgICB3aXRoRmlsZVR5cGVzOiBmYWxzZSxcbiAgICB9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIHdpdGhGaWxlVHlwZXMgPSBlbnRyeS53aXRoRmlsZVR5cGVzO1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlID0gYXdhaXQgZW50cnkucmVhZGxpbmsoKTtcbiAgICAgICAgcmV0dXJuIHdpdGhGaWxlVHlwZXMgPyBlIDogZT8uZnVsbHBhdGgoKTtcbiAgICB9XG4gICAgcmVhZGxpbmtTeW5jKGVudHJ5ID0gdGhpcy5jd2QsIHsgd2l0aEZpbGVUeXBlcyB9ID0ge1xuICAgICAgICB3aXRoRmlsZVR5cGVzOiBmYWxzZSxcbiAgICB9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIHdpdGhGaWxlVHlwZXMgPSBlbnRyeS53aXRoRmlsZVR5cGVzO1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlID0gZW50cnkucmVhZGxpbmtTeW5jKCk7XG4gICAgICAgIHJldHVybiB3aXRoRmlsZVR5cGVzID8gZSA6IGU/LmZ1bGxwYXRoKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWxwYXRoKGVudHJ5ID0gdGhpcy5jd2QsIHsgd2l0aEZpbGVUeXBlcyB9ID0ge1xuICAgICAgICB3aXRoRmlsZVR5cGVzOiBmYWxzZSxcbiAgICB9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIHdpdGhGaWxlVHlwZXMgPSBlbnRyeS53aXRoRmlsZVR5cGVzO1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlID0gYXdhaXQgZW50cnkucmVhbHBhdGgoKTtcbiAgICAgICAgcmV0dXJuIHdpdGhGaWxlVHlwZXMgPyBlIDogZT8uZnVsbHBhdGgoKTtcbiAgICB9XG4gICAgcmVhbHBhdGhTeW5jKGVudHJ5ID0gdGhpcy5jd2QsIHsgd2l0aEZpbGVUeXBlcyB9ID0ge1xuICAgICAgICB3aXRoRmlsZVR5cGVzOiBmYWxzZSxcbiAgICB9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIHdpdGhGaWxlVHlwZXMgPSBlbnRyeS53aXRoRmlsZVR5cGVzO1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlID0gZW50cnkucmVhbHBhdGhTeW5jKCk7XG4gICAgICAgIHJldHVybiB3aXRoRmlsZVR5cGVzID8gZSA6IGU/LmZ1bGxwYXRoKCk7XG4gICAgfVxuICAgIGFzeW5jIHdhbGsoZW50cnkgPSB0aGlzLmN3ZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB3aXRoRmlsZVR5cGVzID0gdHJ1ZSwgZm9sbG93ID0gZmFsc2UsIGZpbHRlciwgd2Fsa0ZpbHRlciwgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGVudHJ5KSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHdpdGhGaWxlVHlwZXMgPyBlbnRyeSA6IGVudHJ5LmZ1bGxwYXRoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IHdhbGsgPSAoZGlyLCBjYikgPT4ge1xuICAgICAgICAgICAgZGlycy5hZGQoZGlyKTtcbiAgICAgICAgICAgIGRpci5yZWFkZGlyQ0IoKGVyLCBlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgaWYgKGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgbGV0IGxlbiA9IGVudHJpZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICghbGVuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoLS1sZW4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHdpdGhGaWxlVHlwZXMgPyBlIDogZS5mdWxscGF0aCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9sbG93ICYmIGUuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5yZWFscGF0aCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ociA9PiAocj8uaXNVbmtub3duKCkgPyByLmxzdGF0KCkgOiByKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyID0+IHI/LnNob3VsZFdhbGsoZGlycywgd2Fsa0ZpbHRlcikgPyB3YWxrKHIsIG5leHQpIDogbmV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnNob3VsZFdhbGsoZGlycywgd2Fsa0ZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxrKGUsIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdHJ1ZSk7IC8vIHphbGdvb29vb29vXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gZW50cnk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgIHdhbGsoc3RhcnQsIGVyID0+IHtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBpZiAoZXIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWooZXIpO1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICAgICAgcmVzKHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3YWxrU3luYyhlbnRyeSA9IHRoaXMuY3dkLCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgb3B0cyA9IGVudHJ5O1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpdGhGaWxlVHlwZXMgPSB0cnVlLCBmb2xsb3cgPSBmYWxzZSwgZmlsdGVyLCB3YWxrRmlsdGVyLCB9ID0gb3B0cztcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZW50cnkpKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2god2l0aEZpbGVUeXBlcyA/IGVudHJ5IDogZW50cnkuZnVsbHBhdGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlycyA9IG5ldyBTZXQoW2VudHJ5XSk7XG4gICAgICAgIGZvciAoY29uc3QgZGlyIG9mIGRpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBkaXIucmVhZGRpclN5bmMoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh3aXRoRmlsZVR5cGVzID8gZSA6IGUuZnVsbHBhdGgoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByID0gZTtcbiAgICAgICAgICAgICAgICBpZiAoZS5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGZvbGxvdyAmJiAociA9IGUucmVhbHBhdGhTeW5jKCkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoci5pc1Vua25vd24oKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHIubHN0YXRTeW5jKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyLnNob3VsZFdhbGsoZGlycywgd2Fsa0ZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlycy5hZGQocik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdXBwb3J0IGZvciBgZm9yIGF3YWl0YFxuICAgICAqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBQYXRoU2N1cnJ5QmFzZS5pdGVyYXRlfVxuICAgICAqXG4gICAgICogTm90ZTogQXMgb2YgTm9kZSAxOSwgdGhpcyBpcyB2ZXJ5IHNsb3csIGNvbXBhcmVkIHRvIG90aGVyIG1ldGhvZHMgb2ZcbiAgICAgKiB3YWxraW5nLiAgQ29uc2lkZXIgdXNpbmcge0BsaW5rIFBhdGhTY3VycnlCYXNlLnN0cmVhbX0gaWYgbWVtb3J5IG92ZXJoZWFkXG4gICAgICogYW5kIGJhY2twcmVzc3VyZSBhcmUgY29uY2VybnMsIG9yIHtAbGluayBQYXRoU2N1cnJ5QmFzZS53YWxrfSBpZiBub3QuXG4gICAgICovXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0ZSgpO1xuICAgIH1cbiAgICBpdGVyYXRlKGVudHJ5ID0gdGhpcy5jd2QsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBpdGVyYXRpbmcgYXN5bmMgb3ZlciB0aGUgc3RyZWFtIGlzIHNpZ25pZmljYW50bHkgbW9yZSBwZXJmb3JtYW50LFxuICAgICAgICAvLyBlc3BlY2lhbGx5IGluIHRoZSB3YXJtLWNhY2hlIHNjZW5hcmlvLCBiZWNhdXNlIGl0IGJ1ZmZlcnMgdXAgZGlyZWN0b3J5XG4gICAgICAgIC8vIGVudHJpZXMgaW4gdGhlIGJhY2tncm91bmQgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciBhIHlpZWxkIGZvciBlYWNoIG9uZS5cbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IGVudHJ5O1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0oZW50cnksIG9wdGlvbnMpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRpbmcgb3ZlciBhIFBhdGhTY3VycnkgcGVyZm9ybXMgYSBzeW5jaHJvbm91cyB3YWxrLlxuICAgICAqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBQYXRoU2N1cnJ5QmFzZS5pdGVyYXRlU3luY31cbiAgICAgKi9cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0ZVN5bmMoKTtcbiAgICB9XG4gICAgKml0ZXJhdGVTeW5jKGVudHJ5ID0gdGhpcy5jd2QsIG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICBvcHRzID0gZW50cnk7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgd2l0aEZpbGVUeXBlcyA9IHRydWUsIGZvbGxvdyA9IGZhbHNlLCBmaWx0ZXIsIHdhbGtGaWx0ZXIsIH0gPSBvcHRzO1xuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZW50cnkpKSB7XG4gICAgICAgICAgICB5aWVsZCB3aXRoRmlsZVR5cGVzID8gZW50cnkgOiBlbnRyeS5mdWxscGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpcnMgPSBuZXcgU2V0KFtlbnRyeV0pO1xuICAgICAgICBmb3IgKGNvbnN0IGRpciBvZiBkaXJzKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gZGlyLnJlYWRkaXJTeW5jKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihlKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB3aXRoRmlsZVR5cGVzID8gZSA6IGUuZnVsbHBhdGgoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHIgPSBlO1xuICAgICAgICAgICAgICAgIGlmIChlLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZm9sbG93ICYmIChyID0gZS5yZWFscGF0aFN5bmMoKSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmlzVW5rbm93bigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgci5sc3RhdFN5bmMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHIuc2hvdWxkV2FsayhkaXJzLCB3YWxrRmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJzLmFkZChyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyZWFtKGVudHJ5ID0gdGhpcy5jd2QsIG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICBvcHRzID0gZW50cnk7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgd2l0aEZpbGVUeXBlcyA9IHRydWUsIGZvbGxvdyA9IGZhbHNlLCBmaWx0ZXIsIHdhbGtGaWx0ZXIsIH0gPSBvcHRzO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gbmV3IG1pbmlwYXNzXzEuTWluaXBhc3MoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZW50cnkpKSB7XG4gICAgICAgICAgICByZXN1bHRzLndyaXRlKHdpdGhGaWxlVHlwZXMgPyBlbnRyeSA6IGVudHJ5LmZ1bGxwYXRoKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW2VudHJ5XTtcbiAgICAgICAgbGV0IHByb2Nlc3NpbmcgPSAwO1xuICAgICAgICBjb25zdCBwcm9jZXNzID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKCFwYXVzZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXIgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmICghZGlyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzaW5nID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nKys7XG4gICAgICAgICAgICAgICAgZGlycy5hZGQoZGlyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvblJlYWRkaXIgPSAoZXIsIGVudHJpZXMsIGRpZFJlYWxwYXRocyA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvbGxvdyAmJiAhZGlkUmVhbHBhdGhzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlYWxwYXRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChyKSA9PiByPy5pc1Vua25vd24oKSA/IHIubHN0YXQoKSA6IHIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4gb25SZWFkZGlyKG51bGwsIGVudHJpZXMsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlICYmICghZmlsdGVyIHx8IGZpbHRlcihlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdHMud3JpdGUod2l0aEZpbGVUeXBlcyA/IGUgOiBlLmZ1bGxwYXRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NpbmctLTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBlLnJlYWxwYXRoQ2FjaGVkKCkgfHwgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLnNob3VsZFdhbGsoZGlycywgd2Fsa0ZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXVzZWQgJiYgIXJlc3VsdHMuZmxvd2luZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5vbmNlKCdkcmFpbicsIHByb2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIHphbGdvIGNvbnRhaW5tZW50XG4gICAgICAgICAgICAgICAgbGV0IHN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRpci5yZWFkZGlyQ0Iob25SZWFkZGlyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBzeW5jID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIHN0cmVhbVN5bmMoZW50cnkgPSB0aGlzLmN3ZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB3aXRoRmlsZVR5cGVzID0gdHJ1ZSwgZm9sbG93ID0gZmFsc2UsIGZpbHRlciwgd2Fsa0ZpbHRlciwgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgbWluaXBhc3NfMS5NaW5pcGFzcyh7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IGRpcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihlbnRyeSkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMud3JpdGUod2l0aEZpbGVUeXBlcyA/IGVudHJ5IDogZW50cnkuZnVsbHBhdGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVldWUgPSBbZW50cnldO1xuICAgICAgICBsZXQgcHJvY2Vzc2luZyA9IDA7XG4gICAgICAgIGNvbnN0IHByb2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoIXBhdXNlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpciA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NpbmcgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcrKztcbiAgICAgICAgICAgICAgICBkaXJzLmFkZChkaXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBkaXIucmVhZGRpclN5bmMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0cy53cml0ZSh3aXRoRmlsZVR5cGVzID8gZSA6IGUuZnVsbHBhdGgoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmctLTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgciA9IGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGZvbGxvdyAmJiAociA9IGUucmVhbHBhdGhTeW5jKCkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyLmlzVW5rbm93bigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIubHN0YXRTeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHIuc2hvdWxkV2FsayhkaXJzLCB3YWxrRmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXVzZWQgJiYgIXJlc3VsdHMuZmxvd2luZylcbiAgICAgICAgICAgICAgICByZXN1bHRzLm9uY2UoJ2RyYWluJywgcHJvY2Vzcyk7XG4gICAgICAgIH07XG4gICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIGNoZGlyKHBhdGggPSB0aGlzLmN3ZCkge1xuICAgICAgICBjb25zdCBvbGRDd2QgPSB0aGlzLmN3ZDtcbiAgICAgICAgdGhpcy5jd2QgPSB0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycgPyB0aGlzLmN3ZC5yZXNvbHZlKHBhdGgpIDogcGF0aDtcbiAgICAgICAgdGhpcy5jd2Rbc2V0QXNDd2RdKG9sZEN3ZCk7XG4gICAgfVxufVxuZXhwb3J0cy5QYXRoU2N1cnJ5QmFzZSA9IFBhdGhTY3VycnlCYXNlO1xuLyoqXG4gKiBXaW5kb3dzIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayBQYXRoU2N1cnJ5QmFzZX1cbiAqXG4gKiBEZWZhdWx0cyB0byBjYXNlIGluc2Vuc2l0dmUsIHVzZXMgYCdcXFxcJ2AgdG8gZ2VuZXJhdGUgcGF0aCBzdHJpbmdzLiAgVXNlc1xuICoge0BsaW5rIFBhdGhXaW4zMn0gZm9yIFBhdGggb2JqZWN0cy5cbiAqL1xuY2xhc3MgUGF0aFNjdXJyeVdpbjMyIGV4dGVuZHMgUGF0aFNjdXJyeUJhc2Uge1xuICAgIC8qKlxuICAgICAqIHNlcGFyYXRvciBmb3IgZ2VuZXJhdGluZyBwYXRoIHN0cmluZ3NcbiAgICAgKi9cbiAgICBzZXAgPSAnXFxcXCc7XG4gICAgY29uc3RydWN0b3IoY3dkID0gcHJvY2Vzcy5jd2QoKSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgbm9jYXNlID0gdHJ1ZSB9ID0gb3B0cztcbiAgICAgICAgc3VwZXIoY3dkLCBwYXRoXzEud2luMzIsICdcXFxcJywgeyAuLi5vcHRzLCBub2Nhc2UgfSk7XG4gICAgICAgIHRoaXMubm9jYXNlID0gbm9jYXNlO1xuICAgICAgICBmb3IgKGxldCBwID0gdGhpcy5jd2Q7IHA7IHAgPSBwLnBhcmVudCkge1xuICAgICAgICAgICAgcC5ub2Nhc2UgPSB0aGlzLm5vY2FzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwYXJzZVJvb3RQYXRoKGRpcikge1xuICAgICAgICAvLyBpZiB0aGUgcGF0aCBzdGFydHMgd2l0aCBhIHNpbmdsZSBzZXBhcmF0b3IsIGl0J3Mgbm90IGEgVU5DLCBhbmQgd2UnbGxcbiAgICAgICAgLy8ganVzdCBnZXQgc2VwYXJhdG9yIGFzIHRoZSByb290LCBhbmQgZHJpdmVGcm9tVU5DIHdpbGwgcmV0dXJuIFxcXG4gICAgICAgIC8vIEluIHRoYXQgY2FzZSwgbW91bnQgXFwgb24gdGhlIHJvb3QgZnJvbSB0aGUgY3dkLlxuICAgICAgICByZXR1cm4gcGF0aF8xLndpbjMyLnBhcnNlKGRpcikucm9vdC50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBuZXdSb290KGZzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aFdpbjMyKHRoaXMucm9vdFBhdGgsIElGRElSLCB1bmRlZmluZWQsIHRoaXMucm9vdHMsIHRoaXMubm9jYXNlLCB0aGlzLmNoaWxkcmVuQ2FjaGUoKSwgeyBmcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHByb3ZpZGVkIHBhdGggc3RyaW5nIGlzIGFuIGFic29sdXRlIHBhdGhcbiAgICAgKi9cbiAgICBpc0Fic29sdXRlKHApIHtcbiAgICAgICAgcmV0dXJuIChwLnN0YXJ0c1dpdGgoJy8nKSB8fCBwLnN0YXJ0c1dpdGgoJ1xcXFwnKSB8fCAvXlthLXpdOihcXC98XFxcXCkvaS50ZXN0KHApKTtcbiAgICB9XG59XG5leHBvcnRzLlBhdGhTY3VycnlXaW4zMiA9IFBhdGhTY3VycnlXaW4zMjtcbi8qKlxuICoge0BsaW5rIFBhdGhTY3VycnlCYXNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgYWxsIHBvc2l4IHN5c3RlbXMgb3RoZXIgdGhhbiBEYXJ3aW4uXG4gKlxuICogRGVmYXVsdHMgdG8gY2FzZS1zZW5zaXRpdmUgbWF0Y2hpbmcsIHVzZXMgYCcvJ2AgdG8gZ2VuZXJhdGUgcGF0aCBzdHJpbmdzLlxuICpcbiAqIFVzZXMge0BsaW5rIFBhdGhQb3NpeH0gZm9yIFBhdGggb2JqZWN0cy5cbiAqL1xuY2xhc3MgUGF0aFNjdXJyeVBvc2l4IGV4dGVuZHMgUGF0aFNjdXJyeUJhc2Uge1xuICAgIC8qKlxuICAgICAqIHNlcGFyYXRvciBmb3IgZ2VuZXJhdGluZyBwYXRoIHN0cmluZ3NcbiAgICAgKi9cbiAgICBzZXAgPSAnLyc7XG4gICAgY29uc3RydWN0b3IoY3dkID0gcHJvY2Vzcy5jd2QoKSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgbm9jYXNlID0gZmFsc2UgfSA9IG9wdHM7XG4gICAgICAgIHN1cGVyKGN3ZCwgcGF0aF8xLnBvc2l4LCAnLycsIHsgLi4ub3B0cywgbm9jYXNlIH0pO1xuICAgICAgICB0aGlzLm5vY2FzZSA9IG5vY2FzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcGFyc2VSb290UGF0aChfZGlyKSB7XG4gICAgICAgIHJldHVybiAnLyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG5ld1Jvb3QoZnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoUG9zaXgodGhpcy5yb290UGF0aCwgSUZESVIsIHVuZGVmaW5lZCwgdGhpcy5yb290cywgdGhpcy5ub2Nhc2UsIHRoaXMuY2hpbGRyZW5DYWNoZSgpLCB7IGZzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgcGF0aCBzdHJpbmcgaXMgYW4gYWJzb2x1dGUgcGF0aFxuICAgICAqL1xuICAgIGlzQWJzb2x1dGUocCkge1xuICAgICAgICByZXR1cm4gcC5zdGFydHNXaXRoKCcvJyk7XG4gICAgfVxufVxuZXhwb3J0cy5QYXRoU2N1cnJ5UG9zaXggPSBQYXRoU2N1cnJ5UG9zaXg7XG4vKipcbiAqIHtAbGluayBQYXRoU2N1cnJ5QmFzZX0gaW1wbGVtZW50YXRpb24gZm9yIERhcndpbiAobWFjT1MpIHN5c3RlbXMuXG4gKlxuICogRGVmYXVsdHMgdG8gY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZywgdXNlcyBgJy8nYCBmb3IgZ2VuZXJhdGluZyBwYXRoXG4gKiBzdHJpbmdzLlxuICpcbiAqIFVzZXMge0BsaW5rIFBhdGhQb3NpeH0gZm9yIFBhdGggb2JqZWN0cy5cbiAqL1xuY2xhc3MgUGF0aFNjdXJyeURhcndpbiBleHRlbmRzIFBhdGhTY3VycnlQb3NpeCB7XG4gICAgY29uc3RydWN0b3IoY3dkID0gcHJvY2Vzcy5jd2QoKSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgbm9jYXNlID0gdHJ1ZSB9ID0gb3B0cztcbiAgICAgICAgc3VwZXIoY3dkLCB7IC4uLm9wdHMsIG5vY2FzZSB9KTtcbiAgICB9XG59XG5leHBvcnRzLlBhdGhTY3VycnlEYXJ3aW4gPSBQYXRoU2N1cnJ5RGFyd2luO1xuLyoqXG4gKiBEZWZhdWx0IHtAbGluayBQYXRoQmFzZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICpcbiAqIHtAbGluayBQYXRoV2luMzJ9IG9uIFdpbmRvd3Mgc3lzdGVtcywge0BsaW5rIFBhdGhQb3NpeH0gb24gYWxsIG90aGVycy5cbiAqL1xuZXhwb3J0cy5QYXRoID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/IFBhdGhXaW4zMiA6IFBhdGhQb3NpeDtcbi8qKlxuICogRGVmYXVsdCB7QGxpbmsgUGF0aFNjdXJyeUJhc2V9IGltcGxlbWVudGF0aW9uIGZvciB0aGUgY3VycmVudCBwbGF0Zm9ybS5cbiAqXG4gKiB7QGxpbmsgUGF0aFNjdXJyeVdpbjMyfSBvbiBXaW5kb3dzIHN5c3RlbXMsIHtAbGluayBQYXRoU2N1cnJ5RGFyd2lufSBvblxuICogRGFyd2luIChtYWNPUykgc3lzdGVtcywge0BsaW5rIFBhdGhTY3VycnlQb3NpeH0gb24gYWxsIG90aGVycy5cbiAqL1xuZXhwb3J0cy5QYXRoU2N1cnJ5ID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xuICAgID8gUGF0aFNjdXJyeVdpbjMyXG4gICAgOiBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJ1xuICAgICAgICA/IFBhdGhTY3VycnlEYXJ3aW5cbiAgICAgICAgOiBQYXRoU2N1cnJ5UG9zaXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiX19jcmVhdGVCaW5kaW5nIiwiT2JqZWN0IiwiY3JlYXRlIiwibyIsIm0iLCJrIiwiazIiLCJ1bmRlZmluZWQiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX19lc01vZHVsZSIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmluZVByb3BlcnR5IiwiX19zZXRNb2R1bGVEZWZhdWx0IiwidiIsInZhbHVlIiwiX19pbXBvcnRTdGFyIiwibW9kIiwicmVzdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZXhwb3J0cyIsIlBhdGhTY3VycnkiLCJQYXRoIiwiUGF0aFNjdXJyeURhcndpbiIsIlBhdGhTY3VycnlQb3NpeCIsIlBhdGhTY3VycnlXaW4zMiIsIlBhdGhTY3VycnlCYXNlIiwiUGF0aFBvc2l4IiwiUGF0aFdpbjMyIiwiUGF0aEJhc2UiLCJDaGlsZHJlbkNhY2hlIiwiUmVzb2x2ZUNhY2hlIiwibHJ1X2NhY2hlXzEiLCJyZXF1aXJlIiwicGF0aF8xIiwidXJsXzEiLCJhY3R1YWxGUyIsImZzXzEiLCJyZWFscGF0aFN5bmMiLCJuYXRpdmUiLCJwcm9taXNlc18xIiwibWluaXBhc3NfMSIsImRlZmF1bHRGUyIsImxzdGF0U3luYyIsInJlYWRkaXIiLCJyZWFkZGlyU3luYyIsInJlYWRsaW5rU3luYyIsInByb21pc2VzIiwibHN0YXQiLCJyZWFkbGluayIsInJlYWxwYXRoIiwiZnNGcm9tT3B0aW9uIiwiZnNPcHRpb24iLCJ1bmNEcml2ZVJlZ2V4cCIsInVuY1RvRHJpdmUiLCJyb290UGF0aCIsInJlcGxhY2UiLCJlaXRoZXJTZXAiLCJVTktOT1dOIiwiSUZJRk8iLCJJRkNIUiIsIklGRElSIiwiSUZCTEsiLCJJRlJFRyIsIklGTE5LIiwiSUZTT0NLIiwiSUZNVCIsIklGTVRfVU5LTk9XTiIsIlJFQURESVJfQ0FMTEVEIiwiTFNUQVRfQ0FMTEVEIiwiRU5PVERJUiIsIkVOT0VOVCIsIkVOT1JFQURMSU5LIiwiRU5PUkVBTFBBVEgiLCJFTk9DSElMRCIsIlRZUEVNQVNLIiwiZW50VG9UeXBlIiwicyIsImlzRmlsZSIsImlzRGlyZWN0b3J5IiwiaXNTeW1ib2xpY0xpbmsiLCJpc0NoYXJhY3RlckRldmljZSIsImlzQmxvY2tEZXZpY2UiLCJpc1NvY2tldCIsImlzRklGTyIsIm5vcm1hbGl6ZUNhY2hlIiwiTWFwIiwibm9ybWFsaXplIiwiYyIsIm4iLCJzZXQiLCJub3JtYWxpemVOb2Nhc2VDYWNoZSIsIm5vcm1hbGl6ZU5vY2FzZSIsInRvTG93ZXJDYXNlIiwiTFJVQ2FjaGUiLCJjb25zdHJ1Y3RvciIsIm1heCIsIm1heFNpemUiLCJzaXplQ2FsY3VsYXRpb24iLCJhIiwibGVuZ3RoIiwic2V0QXNDd2QiLCJTeW1ib2wiLCJmcyIsImRldiIsIm1vZGUiLCJubGluayIsInVpZCIsImdpZCIsInJkZXYiLCJibGtzaXplIiwiaW5vIiwic2l6ZSIsImJsb2NrcyIsImF0aW1lTXMiLCJtdGltZU1zIiwiY3RpbWVNcyIsImJpcnRodGltZU1zIiwiYXRpbWUiLCJtdGltZSIsImN0aW1lIiwiYmlydGh0aW1lIiwibWF0Y2hOYW1lIiwiZGVwdGgiLCJmdWxscGF0aCIsImZ1bGxwYXRoUG9zaXgiLCJyZWxhdGl2ZSIsInJlbGF0aXZlUG9zaXgiLCJ0eXBlIiwiY2hpbGRyZW4iLCJsaW5rVGFyZ2V0IiwicGF0aCIsInBhcmVudCIsIm5hbWUiLCJyb290Iiwicm9vdHMiLCJub2Nhc2UiLCJvcHRzIiwib25SZWFkZGlyQ0IiLCJyZWFkZGlyQ0JJbkZsaWdodCIsImNoaWxkcmVuQ2FjaGUiLCJyZXNvbHZlIiwiZ2V0Um9vdFN0cmluZyIsImRpciIsInN1YnN0cmluZyIsImRpclBhcnRzIiwic3BsaXQiLCJzcGxpdFNlcCIsImdldFJvb3QiLCJyZXNvbHZlUGFydHMiLCJwIiwicGFydCIsImNoaWxkIiwiY2FjaGVkIiwiYXNzaWduIiwicHJvdmlzaW9uYWwiLCJwYXRoUGFydCIsInNlcCIsInBjaGlsZCIsIm5ld0NoaWxkIiwiY2FuUmVhZGRpciIsInB1c2giLCJwdiIsImZwIiwidGVzdCIsInBmcHAiLCJmcHAiLCJpc1Vua25vd24iLCJpc1R5cGUiLCJnZXRUeXBlIiwibHN0YXRDYWNoZWQiLCJyZWFkbGlua0NhY2hlZCIsInJlYWxwYXRoQ2FjaGVkIiwicmVhZGRpckNhY2hlZCIsInNsaWNlIiwiY2FuUmVhZGxpbmsiLCJpZm10IiwiY2FsbGVkUmVhZGRpciIsImlzRU5PRU5UIiwiaXNOYW1lZCIsInRhcmdldCIsInJlYWQiLCJlciIsInJlYWRsaW5rRmFpbCIsImNvZGUiLCJyZWFkZGlyU3VjY2VzcyIsIm1hcmtFTk9FTlQiLCJtYXJrQ2hpbGRyZW5FTk9FTlQiLCJtYXJrRU5PUkVBTFBBVEgiLCJtYXJrRU5PVERJUiIsInQiLCJyZWFkZGlyRmFpbCIsImxzdGF0RmFpbCIsInRlciIsInJlYWRkaXJBZGRDaGlsZCIsImUiLCJyZWFkZGlyTWF5YmVQcm9tb3RlQ2hpbGQiLCJyZWFkZGlyQWRkTmV3Q2hpbGQiLCJ1bnNoaWZ0IiwicmVhZGRpclByb21vdGVDaGlsZCIsImluZGV4IiwicG9wIiwic3BsaWNlIiwiYXBwbHlTdGF0Iiwic3QiLCJjYWxsT25SZWFkZGlyQ0IiLCJjYnMiLCJmb3JFYWNoIiwiY2IiLCJyZWFkZGlyQ0IiLCJhbGxvd1phbGdvIiwicXVldWVNaWNyb3Rhc2siLCJ3aXRoRmlsZVR5cGVzIiwiZW50cmllcyIsImFzeW5jUmVhZGRpckluRmxpZ2h0IiwiUHJvbWlzZSIsInJlcyIsInNob3VsZFdhbGsiLCJkaXJzIiwid2Fsa0ZpbHRlciIsImhhcyIsInJwIiwiXyIsIm9sZEN3ZCIsImNoYW5nZWQiLCJTZXQiLCJhZGQiLCJqb2luIiwid2luMzIiLCJwYXJzZSIsInRvVXBwZXJDYXNlIiwiY29tcGFyZSIsInNhbWVSb290Iiwic3RhcnRzV2l0aCIsIl9yb290UGF0aCIsInJlc29sdmVDYWNoZSIsInJlc29sdmVQb3NpeENhY2hlIiwiY3dkIiwicHJvY2VzcyIsInBhdGhJbXBsIiwiY2hpbGRyZW5DYWNoZVNpemUiLCJVUkwiLCJmaWxlVVJMVG9QYXRoIiwiY3dkUGF0aCIsInBhcnNlUm9vdFBhdGgiLCJUeXBlRXJyb3IiLCJuZXdSb290IiwicHJldiIsImxlbiIsImpvaW5TZXAiLCJhYnMiLCJzYXdGaXJzdCIsImwiLCJBcnJheSIsImZpbGwiLCJwYXRocyIsInIiLCJpIiwiaXNBYnNvbHV0ZSIsInJlc29sdmVQb3NpeCIsImVudHJ5IiwiYmFzZW5hbWUiLCJkaXJuYW1lIiwibWFwIiwid2FsayIsImZvbGxvdyIsImZpbHRlciIsInJlc3VsdHMiLCJuZXh0IiwidGhlbiIsInN0YXJ0IiwicmVqIiwid2Fsa1N5bmMiLCJhc3luY0l0ZXJhdG9yIiwiaXRlcmF0ZSIsIm9wdGlvbnMiLCJzdHJlYW0iLCJpdGVyYXRvciIsIml0ZXJhdGVTeW5jIiwiTWluaXBhc3MiLCJvYmplY3RNb2RlIiwid3JpdGUiLCJxdWV1ZSIsInByb2Nlc3NpbmciLCJwYXVzZWQiLCJzaGlmdCIsImVuZCIsIm9uUmVhZGRpciIsImRpZFJlYWxwYXRocyIsImVtaXQiLCJhbGwiLCJmbG93aW5nIiwib25jZSIsInN5bmMiLCJzdHJlYW1TeW5jIiwiY2hkaXIiLCJwb3NpeCIsIl9kaXIiLCJwbGF0Zm9ybSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/path-scurry/dist/cjs/index.js\n");

/***/ })

};
;