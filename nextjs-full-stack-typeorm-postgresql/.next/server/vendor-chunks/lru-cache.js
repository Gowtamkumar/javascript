"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lru-cache";
exports.ids = ["vendor-chunks/lru-cache"];
exports.modules = {

/***/ "(rsc)/./node_modules/lru-cache/dist/commonjs/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/lru-cache/dist/commonjs/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * @module LRUCache\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.LRUCache = void 0;\nconst perf = typeof performance === \"object\" && performance && typeof performance.now === \"function\" ? performance : Date;\nconst warned = new Set();\n/* c8 ignore start */ const PROCESS = typeof process === \"object\" && !!process ? process : {};\n/* c8 ignore start */ const emitWarning = (msg, type, code, fn)=>{\n    typeof PROCESS.emitWarning === \"function\" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */ if (typeof AC === \"undefined\") {\n    //@ts-ignore\n    AS = class AbortSignal {\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n        constructor(){\n            this._onabort = [];\n            this.aborted = false;\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor(){\n            this.signal = new AS();\n            warnACPolyfill();\n        }\n        abort(reason) {\n            if (this.signal.aborted) return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort){\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== \"1\";\n    const warnACPolyfill = ()=>{\n        if (!printACPolyfillWarning) return;\n        printACPolyfillWarning = false;\n        emitWarning(\"AbortController is not defined. If using lru-cache in \" + \"node 14, load an AbortController polyfill from the \" + \"`node-abort-controller` package. A minimal polyfill is \" + \"provided for use by LRUCache.fetch(), but it should not be \" + \"relied upon in other contexts (eg, passing it to other APIs that \" + \"use AbortController/AbortSignal might have undesirable effects). \" + \"You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.\", \"NO_ABORT_CONTROLLER\", \"ENOTSUP\", warnACPolyfill);\n    };\n}\n/* c8 ignore stop */ const shouldWarn = (code)=>!warned.has(code);\nconst TYPE = Symbol(\"type\");\nconst isPosInt = (n)=>n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */ // This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max)=>!isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;\n/* c8 ignore stop */ class ZeroArray extends Array {\n    constructor(size){\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls) return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls){\n        /* c8 ignore start */ if (!Stack.#constructing) {\n            throw new TypeError(\"instantiate Stack using Stack.create(n)\");\n        }\n        /* c8 ignore stop */ this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\nlet prop;\n/**\n * Default export, the thing you're using this module to get.\n *\n * All properties from the options object (with the exception of\n * {@link OptionsBase.max} and {@link OptionsBase.maxSize}) are added as\n * normal public members. (`max` and `maxBase` are read-only getters.)\n * Changing any of these will alter the defaults for subsequent method calls,\n * but is otherwise safe.\n */ class LRUCache {\n    static{\n        prop = Symbol.toStringTag;\n    }\n    // properties coming in from the options of these, only max and maxSize\n    // really *need* to be protected. The rest can be modified, as they just\n    // set defaults for various methods.\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */ static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head () {\n                return c.#head;\n            },\n            get tail () {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p)=>c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context)=>c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index)=>c.#moveToTail(index),\n            indexes: (options)=>c.#indexes(options),\n            rindexes: (options)=>c.#rindexes(options),\n            isStale: (index)=>c.#isStale(index)\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */ get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */ get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */ get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */ get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */ get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */ get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */ get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options){\n        // conditionally set private methods related to TTL\n        this.#updateItemAge = ()=>{};\n        this.#statusTTL = ()=>{};\n        this.#setItemTTL = ()=>{};\n        /* c8 ignore stop */ this.#isStale = ()=>false;\n        this.#removeItemSize = (_i)=>{};\n        this.#addItemSize = (_i, _s, _st)=>{};\n        this.#requireSize = (_k, _v, size, sizeCalculation)=>{\n            if (size || sizeCalculation) {\n                throw new TypeError(\"cannot set size without setting maxSize or maxEntrySize on cache\");\n            }\n            return 0;\n        };\n        /**\n     * A String value that is used in the creation of the default string description of an object.\n     * Called by the built-in method Object.prototype.toString.\n     */ this[prop] = \"LRUCache\";\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError(\"max option must be a nonnegative integer\");\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error(\"invalid max value: \" + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError(\"cannot set sizeCalculation without setting maxSize or maxEntrySize\");\n            }\n            if (typeof this.sizeCalculation !== \"function\") {\n                throw new TypeError(\"sizeCalculation set to non-function\");\n            }\n        }\n        if (fetchMethod !== undefined && typeof fetchMethod !== \"function\") {\n            throw new TypeError(\"fetchMethod must be a function if specified\");\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === \"function\") {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === \"function\") {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        } else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError(\"maxSize must be a positive integer if specified\");\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError(\"maxEntrySize must be a positive integer if specified\");\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError(\"ttl must be a positive integer if specified\");\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError(\"At least one of max, maxSize, or ttl is required\");\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = \"LRU_CACHE_UNBOUNDED\";\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = \"TTL caching without ttlAutopurge, max, or maxSize can \" + \"result in unbounded memory consumption.\";\n                emitWarning(msg, \"UnboundedCacheWarning\", code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the remaining TTL time for a given entry key\n     */ getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now())=>{\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(()=>{\n                    if (this.#isStale(index)) {\n                        this.delete(this.#keyList[index]);\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */ if (t.unref) {\n                    t.unref();\n                }\n            /* c8 ignore stop */ }\n        };\n        this.#updateItemAge = (index)=>{\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index)=>{\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */ if (!ttl || !start) return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = ()=>{\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(()=>cachedNow = 0, this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */ if (t.unref) {\n                    t.unref();\n                }\n            /* c8 ignore stop */ }\n            return n;\n        };\n        this.getRemainingTTL = (key)=>{\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = (index)=>{\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    #updateItemAge;\n    #statusTTL;\n    #setItemTTL;\n    #isStale;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = (index)=>{\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation)=>{\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== \"function\") {\n                        throw new TypeError(\"sizeCalculation must be a function\");\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError(\"sizeCalculation return invalid (expect positive integer)\");\n                    }\n                } else {\n                    throw new TypeError(\"invalid size value (must be positive integer). \" + \"When maxSize or maxEntrySize is used, sizeCalculation \" + \"or size must be set.\");\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status)=>{\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while(this.#calculatedSize > maxSize){\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize;\n    #addItemSize;\n    #requireSize;\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for(let i = this.#tail; true;){\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                } else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for(let i = this.#head; true;){\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                } else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return index !== undefined && this.#keyMap.get(this.#keyList[index]) === index;\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */ *entries() {\n        for (const i of this.#indexes()){\n            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [\n                    this.#keyList[i],\n                    this.#valList[i]\n                ];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */ *rentries() {\n        for (const i of this.#rindexes()){\n            if (this.#valList[i] !== undefined && this.#keyList[i] !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [\n                    this.#keyList[i],\n                    this.#valList[i]\n                ];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */ *keys() {\n        for (const i of this.#indexes()){\n            const k = this.#keyList[i];\n            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */ *rkeys() {\n        for (const i of this.#rindexes()){\n            const k = this.#keyList[i];\n            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */ *values() {\n        for (const i of this.#indexes()){\n            const v = this.#valList[i];\n            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */ *rvalues() {\n        for (const i of this.#rindexes()){\n            const v = this.#valList[i];\n            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */ [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to Array.find().  fn is called as fn(value, key, cache).\n     */ find(fn, getOptions = {}) {\n        for (const i of this.#indexes()){\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from\n     * most recently used to least recently used.  fn is called as\n     * fn(value, key, cache).  Does not update age or recenty of use.\n     * Does not iterate over stale values.\n     */ forEach(fn, thisp = this) {\n        for (const i of this.#indexes()){\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */ rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()){\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined) continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */ purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({\n            allowStale: true\n        })){\n            if (this.#isStale(i)) {\n                this.delete(this.#keyList[i]);\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a\n     * single key. Always returns stale values, if their info is found in the\n     * cache, so be sure to check for expired TTLs if relevant.\n     */ info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined) return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n        if (value === undefined) return undefined;\n        const entry = {\n            value\n        };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to cache.load()\n     */ dump() {\n        const arr = [];\n        for (const i of this.#indexes({\n            allowStale: true\n        })){\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n            if (value === undefined || key === undefined) continue;\n            const entry = {\n                value\n            };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([\n                key,\n                entry\n            ]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     * Note that the shape of the resulting cache may be different if the\n     * same options are not used in both caches.\n     */ load(arr) {\n        this.clear();\n        for (const [key, entry] of arr){\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     */ set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = \"miss\";\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.delete(k);\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status) status.set = \"add\";\n            noUpdateTTL = false;\n        } else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error(\"replaced\"));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, \"set\");\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([\n                                s,\n                                k,\n                                \"set\"\n                            ]);\n                        }\n                    }\n                } else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, \"set\");\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([\n                            oldVal,\n                            k,\n                            \"set\"\n                        ]);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = \"replace\";\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;\n                    if (oldValue !== undefined) status.oldValue = oldValue;\n                }\n            } else if (status) {\n                status.set = \"update\";\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status) this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while(task = dt?.shift()){\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */ pop() {\n        try {\n            while(this.#size){\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                } else if (val !== undefined) {\n                    return val;\n                }\n            }\n        } finally{\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while(task = dt?.shift()){\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error(\"evicted\"));\n        } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, \"evict\");\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([\n                    v,\n                    k,\n                    \"evict\"\n                ]);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        } else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */ has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = \"hit\";\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            } else if (status) {\n                status.has = \"stale\";\n                this.#statusTTL(status, index);\n            }\n        } else if (status) {\n            status.has = \"miss\";\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */ peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined || !allowStale && this.#isStale(index)) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener(\"abort\", ()=>ac.abort(signal.reason), {\n            signal: ac.signal\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context\n        };\n        const cb = (v, updateCache = false)=>{\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort) options.status.fetchAbortIgnored = true;\n                } else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    } else {\n                        this.delete(k);\n                    }\n                } else {\n                    if (options.status) options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er)=>{\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er)=>{\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.delete(k);\n                } else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            } else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej)=>{\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then((v)=>res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener(\"abort\", ()=>{\n                if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = (v)=>cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status) options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, {\n                ...fetchOpts.options,\n                status: undefined\n            });\n            index = this.#keyMap.get(k);\n        } else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod) return false;\n        const b = p;\n        return !!b && b instanceof Promise && b.hasOwnProperty(\"__staleWhileFetching\") && b.__abortController instanceof AC;\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status) status.fetch = \"get\";\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status) status.fetch = \"miss\";\n            const p = this.#backgroundFetch(k, index, options, context);\n            return p.__returned = p;\n        } else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = \"inflight\";\n                    if (stale) status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : v.__returned = v;\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status) status.fetch = \"hit\";\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status) this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? \"stale\" : \"refresh\";\n                if (staleVal && isStale) status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : p.__returned = p;\n        }\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */ get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status) this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status) status.get = \"stale\";\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.delete(k);\n                    }\n                    if (status && allowStale) status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                } else {\n                    if (status && allowStale && value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            } else {\n                if (status) status.get = \"hit\";\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        } else if (status) {\n            status.get = \"miss\";\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            } else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     * Returns true if the key was deleted, false otherwise.\n     */ delete(k) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.clear();\n                } else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error(\"deleted\"));\n                    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, \"delete\");\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([\n                                v,\n                                k,\n                                \"delete\"\n                            ]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    } else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    } else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while(task = dt?.shift()){\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */ clear() {\n        for (const index of this.#rindexes({\n            allowStale: true\n        })){\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error(\"deleted\"));\n            } else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, \"delete\");\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([\n                        v,\n                        k,\n                        \"delete\"\n                    ]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while(task = dt?.shift()){\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\nexports.LRUCache = LRUCache; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2Rpc3QvY29tbW9uanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Q0FFQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsZ0JBQWdCLEdBQUcsS0FBSztBQUN4QixNQUFNRyxPQUFPLE9BQU9DLGdCQUFnQixZQUNoQ0EsZUFDQSxPQUFPQSxZQUFZQyxHQUFHLEtBQUssYUFDekJELGNBQ0FFO0FBQ04sTUFBTUMsU0FBUyxJQUFJQztBQUNuQixtQkFBbUIsR0FDbkIsTUFBTUMsVUFBVyxPQUFPQyxZQUFZLFlBQVksQ0FBQyxDQUFDQSxVQUFVQSxVQUFVLENBQUM7QUFDdkUsbUJBQW1CLEdBQ25CLE1BQU1DLGNBQWMsQ0FBQ0MsS0FBS0MsTUFBTUMsTUFBTUM7SUFDbEMsT0FBT04sUUFBUUUsV0FBVyxLQUFLLGFBQ3pCRixRQUFRRSxXQUFXLENBQUNDLEtBQUtDLE1BQU1DLE1BQU1DLE1BQ3JDQyxRQUFRQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUVILEtBQUssRUFBRSxFQUFFRCxLQUFLLEVBQUUsRUFBRUQsSUFBSSxDQUFDO0FBQ25EO0FBQ0EsSUFBSU0sS0FBS0MsV0FBV0MsZUFBZTtBQUNuQyxJQUFJQyxLQUFLRixXQUFXRyxXQUFXO0FBQy9CLG1CQUFtQixHQUNuQixJQUFJLE9BQU9KLE9BQU8sYUFBYTtJQUMzQixZQUFZO0lBQ1pHLEtBQUssTUFBTUM7UUFLUEMsaUJBQWlCQyxDQUFDLEVBQUVULEVBQUUsRUFBRTtZQUNwQixJQUFJLENBQUNVLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDWDtRQUN2Qjs7aUJBTEFVLFdBQVcsRUFBRTtpQkFFYkUsVUFBVTs7SUFJZDtJQUNBLFlBQVk7SUFDWlQsS0FBSyxNQUFNRTtRQUNQUSxhQUFjO2lCQUdkQyxTQUFTLElBQUlSO1lBRlRTO1FBQ0o7UUFFQUMsTUFBTUMsTUFBTSxFQUFFO1lBQ1YsSUFBSSxJQUFJLENBQUNI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LENBQUMsQ0FBQ3BILFlBQVksTUFBTW1IO1lBQzVCO1FBQ0o7SUFDSjtBQUNKO0FBQ0F6TCxnQkFBZ0IsR0FBR0UsVUFDbkIsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktYXBwLy4vbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9kaXN0L2NvbW1vbmpzL2luZGV4LmpzPzUxN2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBtb2R1bGUgTFJVQ2FjaGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MUlVDYWNoZSA9IHZvaWQgMDtcbmNvbnN0IHBlcmYgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmXG4gICAgcGVyZm9ybWFuY2UgJiZcbiAgICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nXG4gICAgPyBwZXJmb3JtYW5jZVxuICAgIDogRGF0ZTtcbmNvbnN0IHdhcm5lZCA9IG5ldyBTZXQoKTtcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgUFJPQ0VTUyA9ICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgISFwcm9jZXNzID8gcHJvY2VzcyA6IHt9KTtcbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgZW1pdFdhcm5pbmcgPSAobXNnLCB0eXBlLCBjb2RlLCBmbikgPT4ge1xuICAgIHR5cGVvZiBQUk9DRVNTLmVtaXRXYXJuaW5nID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gUFJPQ0VTUy5lbWl0V2FybmluZyhtc2csIHR5cGUsIGNvZGUsIGZuKVxuICAgICAgICA6IGNvbnNvbGUuZXJyb3IoYFske2NvZGV9XSAke3R5cGV9OiAke21zZ31gKTtcbn07XG5sZXQgQUMgPSBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlcjtcbmxldCBBUyA9IGdsb2JhbFRoaXMuQWJvcnRTaWduYWw7XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmlmICh0eXBlb2YgQUMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy9AdHMtaWdub3JlXG4gICAgQVMgPSBjbGFzcyBBYm9ydFNpZ25hbCB7XG4gICAgICAgIG9uYWJvcnQ7XG4gICAgICAgIF9vbmFib3J0ID0gW107XG4gICAgICAgIHJlYXNvbjtcbiAgICAgICAgYWJvcnRlZCA9IGZhbHNlO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKF8sIGZuKSB7XG4gICAgICAgICAgICB0aGlzLl9vbmFib3J0LnB1c2goZm4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvL0B0cy1pZ25vcmVcbiAgICBBQyA9IGNsYXNzIEFib3J0Q29udHJvbGxlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgd2FybkFDUG9seWZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBzaWduYWwgPSBuZXcgQVMoKTtcbiAgICAgICAgYWJvcnQocmVhc29uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWduYWwuYWJvcnRlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5zaWduYWwuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIGZvciAoY29uc3QgZm4gb2YgdGhpcy5zaWduYWwuX29uYWJvcnQpIHtcbiAgICAgICAgICAgICAgICBmbihyZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zaWduYWwub25hYm9ydD8uKHJlYXNvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCBwcmludEFDUG9seWZpbGxXYXJuaW5nID0gUFJPQ0VTUy5lbnY/LkxSVV9DQUNIRV9JR05PUkVfQUNfV0FSTklORyAhPT0gJzEnO1xuICAgIGNvbnN0IHdhcm5BQ1BvbHlmaWxsID0gKCkgPT4ge1xuICAgICAgICBpZiAoIXByaW50QUNQb2x5ZmlsbFdhcm5pbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHByaW50QUNQb2x5ZmlsbFdhcm5pbmcgPSBmYWxzZTtcbiAgICAgICAgZW1pdFdhcm5pbmcoJ0Fib3J0Q29udHJvbGxlciBpcyBub3QgZGVmaW5lZC4gSWYgdXNpbmcgbHJ1LWNhY2hlIGluICcgK1xuICAgICAgICAgICAgJ25vZGUgMTQsIGxvYWQgYW4gQWJvcnRDb250cm9sbGVyIHBvbHlmaWxsIGZyb20gdGhlICcgK1xuICAgICAgICAgICAgJ2Bub2RlLWFib3J0LWNvbnRyb2xsZXJgIHBhY2thZ2UuIEEgbWluaW1hbCBwb2x5ZmlsbCBpcyAnICtcbiAgICAgICAgICAgICdwcm92aWRlZCBmb3IgdXNlIGJ5IExSVUNhY2hlLmZldGNoKCksIGJ1dCBpdCBzaG91bGQgbm90IGJlICcgK1xuICAgICAgICAgICAgJ3JlbGllZCB1cG9uIGluIG90aGVyIGNvbnRleHRzIChlZywgcGFzc2luZyBpdCB0byBvdGhlciBBUElzIHRoYXQgJyArXG4gICAgICAgICAgICAndXNlIEFib3J0Q29udHJvbGxlci9BYm9ydFNpZ25hbCBtaWdodCBoYXZlIHVuZGVzaXJhYmxlIGVmZmVjdHMpLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGRpc2FibGUgdGhpcyB3aXRoIExSVV9DQUNIRV9JR05PUkVfQUNfV0FSTklORz0xIGluIHRoZSBlbnYuJywgJ05PX0FCT1JUX0NPTlRST0xMRVInLCAnRU5PVFNVUCcsIHdhcm5BQ1BvbHlmaWxsKTtcbiAgICB9O1xufVxuLyogYzggaWdub3JlIHN0b3AgKi9cbmNvbnN0IHNob3VsZFdhcm4gPSAoY29kZSkgPT4gIXdhcm5lZC5oYXMoY29kZSk7XG5jb25zdCBUWVBFID0gU3ltYm9sKCd0eXBlJyk7XG5jb25zdCBpc1Bvc0ludCA9IChuKSA9PiBuICYmIG4gPT09IE1hdGguZmxvb3IobikgJiYgbiA+IDAgJiYgaXNGaW5pdGUobik7XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8vIFRoaXMgaXMgYSBsaXR0bGUgYml0IHJpZGljdWxvdXMsIHRiaC5cbi8vIFRoZSBtYXhpbXVtIGFycmF5IGxlbmd0aCBpcyAyXjMyLTEgb3IgdGhlcmVhYm91dHMgb24gbW9zdCBKUyBpbXBscy5cbi8vIEFuZCB3ZWxsIGJlZm9yZSB0aGF0IHBvaW50LCB5b3UncmUgY2FjaGluZyB0aGUgZW50aXJlIHdvcmxkLCBJIG1lYW4sXG4vLyB0aGF0J3MgfjMyR0Igb2YganVzdCBpbnRlZ2VycyBmb3IgdGhlIG5leHQvcHJldiBsaW5rcywgcGx1cyB3aGF0ZXZlclxuLy8gZWxzZSB0byBob2xkIHRoYXQgbWFueSBrZXlzIGFuZCB2YWx1ZXMuICBKdXN0IGZpbGxpbmcgdGhlIG1lbW9yeSB3aXRoXG4vLyB6ZXJvZXMgYXQgaW5pdCB0aW1lIGlzIGJydXRhbCB3aGVuIHlvdSBnZXQgdGhhdCBiaWcuXG4vLyBCdXQgd2h5IG5vdCBiZSBjb21wbGV0ZT9cbi8vIE1heWJlIGluIHRoZSBmdXR1cmUsIHRoZXNlIGxpbWl0cyB3aWxsIGhhdmUgZXhwYW5kZWQuXG5jb25zdCBnZXRVaW50QXJyYXkgPSAobWF4KSA9PiAhaXNQb3NJbnQobWF4KVxuICAgID8gbnVsbFxuICAgIDogbWF4IDw9IE1hdGgucG93KDIsIDgpXG4gICAgICAgID8gVWludDhBcnJheVxuICAgICAgICA6IG1heCA8PSBNYXRoLnBvdygyLCAxNilcbiAgICAgICAgICAgID8gVWludDE2QXJyYXlcbiAgICAgICAgICAgIDogbWF4IDw9IE1hdGgucG93KDIsIDMyKVxuICAgICAgICAgICAgICAgID8gVWludDMyQXJyYXlcbiAgICAgICAgICAgICAgICA6IG1heCA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICAgICAgICAgICAgICAgICAgICA/IFplcm9BcnJheVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuY2xhc3MgWmVyb0FycmF5IGV4dGVuZHMgQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKHNpemUpIHtcbiAgICAgICAgc3VwZXIoc2l6ZSk7XG4gICAgICAgIHRoaXMuZmlsbCgwKTtcbiAgICB9XG59XG5jbGFzcyBTdGFjayB7XG4gICAgaGVhcDtcbiAgICBsZW5ndGg7XG4gICAgLy8gcHJpdmF0ZSBjb25zdHJ1Y3RvclxuICAgIHN0YXRpYyAjY29uc3RydWN0aW5nID0gZmFsc2U7XG4gICAgc3RhdGljIGNyZWF0ZShtYXgpIHtcbiAgICAgICAgY29uc3QgSGVhcENscyA9IGdldFVpbnRBcnJheShtYXgpO1xuICAgICAgICBpZiAoIUhlYXBDbHMpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIFN0YWNrLiNjb25zdHJ1Y3RpbmcgPSB0cnVlO1xuICAgICAgICBjb25zdCBzID0gbmV3IFN0YWNrKG1heCwgSGVhcENscyk7XG4gICAgICAgIFN0YWNrLiNjb25zdHJ1Y3RpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1heCwgSGVhcENscykge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCFTdGFjay4jY29uc3RydWN0aW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnN0YW50aWF0ZSBTdGFjayB1c2luZyBTdGFjay5jcmVhdGUobiknKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLmhlYXAgPSBuZXcgSGVhcENscyhtYXgpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHB1c2gobikge1xuICAgICAgICB0aGlzLmhlYXBbdGhpcy5sZW5ndGgrK10gPSBuO1xuICAgIH1cbiAgICBwb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYXBbLS10aGlzLmxlbmd0aF07XG4gICAgfVxufVxuLyoqXG4gKiBEZWZhdWx0IGV4cG9ydCwgdGhlIHRoaW5nIHlvdSdyZSB1c2luZyB0aGlzIG1vZHVsZSB0byBnZXQuXG4gKlxuICogQWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgb3B0aW9ucyBvYmplY3QgKHdpdGggdGhlIGV4Y2VwdGlvbiBvZlxuICoge0BsaW5rIE9wdGlvbnNCYXNlLm1heH0gYW5kIHtAbGluayBPcHRpb25zQmFzZS5tYXhTaXplfSkgYXJlIGFkZGVkIGFzXG4gKiBub3JtYWwgcHVibGljIG1lbWJlcnMuIChgbWF4YCBhbmQgYG1heEJhc2VgIGFyZSByZWFkLW9ubHkgZ2V0dGVycy4pXG4gKiBDaGFuZ2luZyBhbnkgb2YgdGhlc2Ugd2lsbCBhbHRlciB0aGUgZGVmYXVsdHMgZm9yIHN1YnNlcXVlbnQgbWV0aG9kIGNhbGxzLFxuICogYnV0IGlzIG90aGVyd2lzZSBzYWZlLlxuICovXG5jbGFzcyBMUlVDYWNoZSB7XG4gICAgLy8gcHJvcGVydGllcyBjb21pbmcgaW4gZnJvbSB0aGUgb3B0aW9ucyBvZiB0aGVzZSwgb25seSBtYXggYW5kIG1heFNpemVcbiAgICAvLyByZWFsbHkgKm5lZWQqIHRvIGJlIHByb3RlY3RlZC4gVGhlIHJlc3QgY2FuIGJlIG1vZGlmaWVkLCBhcyB0aGV5IGp1c3RcbiAgICAvLyBzZXQgZGVmYXVsdHMgZm9yIHZhcmlvdXMgbWV0aG9kcy5cbiAgICAjbWF4O1xuICAgICNtYXhTaXplO1xuICAgICNkaXNwb3NlO1xuICAgICNkaXNwb3NlQWZ0ZXI7XG4gICAgI2ZldGNoTWV0aG9kO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS50dGx9XG4gICAgICovXG4gICAgdHRsO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS50dGxSZXNvbHV0aW9ufVxuICAgICAqL1xuICAgIHR0bFJlc29sdXRpb247XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnR0bEF1dG9wdXJnZX1cbiAgICAgKi9cbiAgICB0dGxBdXRvcHVyZ2U7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnVwZGF0ZUFnZU9uR2V0fVxuICAgICAqL1xuICAgIHVwZGF0ZUFnZU9uR2V0O1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS51cGRhdGVBZ2VPbkhhc31cbiAgICAgKi9cbiAgICB1cGRhdGVBZ2VPbkhhcztcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuYWxsb3dTdGFsZX1cbiAgICAgKi9cbiAgICBhbGxvd1N0YWxlO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5ub0Rpc3Bvc2VPblNldH1cbiAgICAgKi9cbiAgICBub0Rpc3Bvc2VPblNldDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2Uubm9VcGRhdGVUVEx9XG4gICAgICovXG4gICAgbm9VcGRhdGVUVEw7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm1heEVudHJ5U2l6ZX1cbiAgICAgKi9cbiAgICBtYXhFbnRyeVNpemU7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnNpemVDYWxjdWxhdGlvbn1cbiAgICAgKi9cbiAgICBzaXplQ2FsY3VsYXRpb247XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm5vRGVsZXRlT25GZXRjaFJlamVjdGlvbn1cbiAgICAgKi9cbiAgICBub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm5vRGVsZXRlT25TdGFsZUdldH1cbiAgICAgKi9cbiAgICBub0RlbGV0ZU9uU3RhbGVHZXQ7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGVPbkZldGNoQWJvcnR9XG4gICAgICovXG4gICAgYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb259XG4gICAgICovXG4gICAgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmlnbm9yZUZldGNoQWJvcnR9XG4gICAgICovXG4gICAgaWdub3JlRmV0Y2hBYm9ydDtcbiAgICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzXG4gICAgI3NpemU7XG4gICAgI2NhbGN1bGF0ZWRTaXplO1xuICAgICNrZXlNYXA7XG4gICAgI2tleUxpc3Q7XG4gICAgI3ZhbExpc3Q7XG4gICAgI25leHQ7XG4gICAgI3ByZXY7XG4gICAgI2hlYWQ7XG4gICAgI3RhaWw7XG4gICAgI2ZyZWU7XG4gICAgI2Rpc3Bvc2VkO1xuICAgICNzaXplcztcbiAgICAjc3RhcnRzO1xuICAgICN0dGxzO1xuICAgICNoYXNEaXNwb3NlO1xuICAgICNoYXNGZXRjaE1ldGhvZDtcbiAgICAjaGFzRGlzcG9zZUFmdGVyO1xuICAgIC8qKlxuICAgICAqIERvIG5vdCBjYWxsIHRoaXMgbWV0aG9kIHVubGVzcyB5b3UgbmVlZCB0byBpbnNwZWN0IHRoZVxuICAgICAqIGlubmVyIHdvcmtpbmdzIG9mIHRoZSBjYWNoZS4gIElmIGFueXRoaW5nIHJldHVybmVkIGJ5IHRoaXNcbiAgICAgKiBvYmplY3QgaXMgbW9kaWZpZWQgaW4gYW55IHdheSwgc3RyYW5nZSBicmVha2FnZSBtYXkgb2NjdXIuXG4gICAgICpcbiAgICAgKiBUaGVzZSBmaWVsZHMgYXJlIHByaXZhdGUgZm9yIGEgcmVhc29uIVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHVuc2FmZUV4cG9zZUludGVybmFscyhjKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBzdGFydHM6IGMuI3N0YXJ0cyxcbiAgICAgICAgICAgIHR0bHM6IGMuI3R0bHMsXG4gICAgICAgICAgICBzaXplczogYy4jc2l6ZXMsXG4gICAgICAgICAgICBrZXlNYXA6IGMuI2tleU1hcCxcbiAgICAgICAgICAgIGtleUxpc3Q6IGMuI2tleUxpc3QsXG4gICAgICAgICAgICB2YWxMaXN0OiBjLiN2YWxMaXN0LFxuICAgICAgICAgICAgbmV4dDogYy4jbmV4dCxcbiAgICAgICAgICAgIHByZXY6IGMuI3ByZXYsXG4gICAgICAgICAgICBnZXQgaGVhZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy4jaGVhZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgdGFpbCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy4jdGFpbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcmVlOiBjLiNmcmVlLFxuICAgICAgICAgICAgLy8gbWV0aG9kc1xuICAgICAgICAgICAgaXNCYWNrZ3JvdW5kRmV0Y2g6IChwKSA9PiBjLiNpc0JhY2tncm91bmRGZXRjaChwKSxcbiAgICAgICAgICAgIGJhY2tncm91bmRGZXRjaDogKGssIGluZGV4LCBvcHRpb25zLCBjb250ZXh0KSA9PiBjLiNiYWNrZ3JvdW5kRmV0Y2goaywgaW5kZXgsIG9wdGlvbnMsIGNvbnRleHQpLFxuICAgICAgICAgICAgbW92ZVRvVGFpbDogKGluZGV4KSA9PiBjLiNtb3ZlVG9UYWlsKGluZGV4KSxcbiAgICAgICAgICAgIGluZGV4ZXM6IChvcHRpb25zKSA9PiBjLiNpbmRleGVzKG9wdGlvbnMpLFxuICAgICAgICAgICAgcmluZGV4ZXM6IChvcHRpb25zKSA9PiBjLiNyaW5kZXhlcyhvcHRpb25zKSxcbiAgICAgICAgICAgIGlzU3RhbGU6IChpbmRleCkgPT4gYy4jaXNTdGFsZShpbmRleCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFByb3RlY3RlZCByZWFkLW9ubHkgbWVtYmVyc1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5tYXh9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IG1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI21heDtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm1heFNpemV9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IG1heFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtYXhTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgY29tcHV0ZWQgc2l6ZSBvZiBpdGVtcyBpbiB0aGUgY2FjaGUgKHJlYWQtb25seSlcbiAgICAgKi9cbiAgICBnZXQgY2FsY3VsYXRlZFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjYWxjdWxhdGVkU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBpdGVtcyBzdG9yZWQgaW4gdGhlIGNhY2hlIChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNzaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuZmV0Y2hNZXRob2R9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IGZldGNoTWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZmV0Y2hNZXRob2Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5kaXNwb3NlfSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBkaXNwb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGlzcG9zZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmRpc3Bvc2VBZnRlcn0gKHJlYWQtb25seSlcbiAgICAgKi9cbiAgICBnZXQgZGlzcG9zZUFmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGlzcG9zZUFmdGVyO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgbWF4ID0gMCwgdHRsLCB0dGxSZXNvbHV0aW9uID0gMSwgdHRsQXV0b3B1cmdlLCB1cGRhdGVBZ2VPbkdldCwgdXBkYXRlQWdlT25IYXMsIGFsbG93U3RhbGUsIGRpc3Bvc2UsIGRpc3Bvc2VBZnRlciwgbm9EaXNwb3NlT25TZXQsIG5vVXBkYXRlVFRMLCBtYXhTaXplID0gMCwgbWF4RW50cnlTaXplID0gMCwgc2l6ZUNhbGN1bGF0aW9uLCBmZXRjaE1ldGhvZCwgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uLCBub0RlbGV0ZU9uU3RhbGVHZXQsIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uLCBhbGxvd1N0YWxlT25GZXRjaEFib3J0LCBpZ25vcmVGZXRjaEFib3J0LCB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKG1heCAhPT0gMCAmJiAhaXNQb3NJbnQobWF4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG9wdGlvbiBtdXN0IGJlIGEgbm9ubmVnYXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFVpbnRBcnJheSA9IG1heCA/IGdldFVpbnRBcnJheShtYXgpIDogQXJyYXk7XG4gICAgICAgIGlmICghVWludEFycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbWF4IHZhbHVlOiAnICsgbWF4KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNtYXggPSBtYXg7XG4gICAgICAgIHRoaXMuI21heFNpemUgPSBtYXhTaXplO1xuICAgICAgICB0aGlzLm1heEVudHJ5U2l6ZSA9IG1heEVudHJ5U2l6ZSB8fCB0aGlzLiNtYXhTaXplO1xuICAgICAgICB0aGlzLnNpemVDYWxjdWxhdGlvbiA9IHNpemVDYWxjdWxhdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuI21heFNpemUgJiYgIXRoaXMubWF4RW50cnlTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBzaXplQ2FsY3VsYXRpb24gd2l0aG91dCBzZXR0aW5nIG1heFNpemUgb3IgbWF4RW50cnlTaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2l6ZUNhbGN1bGF0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW9uIHNldCB0byBub24tZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmV0Y2hNZXRob2QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdHlwZW9mIGZldGNoTWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmZXRjaE1ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24gaWYgc3BlY2lmaWVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZmV0Y2hNZXRob2QgPSBmZXRjaE1ldGhvZDtcbiAgICAgICAgdGhpcy4jaGFzRmV0Y2hNZXRob2QgPSAhIWZldGNoTWV0aG9kO1xuICAgICAgICB0aGlzLiNrZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuI2tleUxpc3QgPSBuZXcgQXJyYXkobWF4KS5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuI3ZhbExpc3QgPSBuZXcgQXJyYXkobWF4KS5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuI25leHQgPSBuZXcgVWludEFycmF5KG1heCk7XG4gICAgICAgIHRoaXMuI3ByZXYgPSBuZXcgVWludEFycmF5KG1heCk7XG4gICAgICAgIHRoaXMuI2hlYWQgPSAwO1xuICAgICAgICB0aGlzLiN0YWlsID0gMDtcbiAgICAgICAgdGhpcy4jZnJlZSA9IFN0YWNrLmNyZWF0ZShtYXgpO1xuICAgICAgICB0aGlzLiNzaXplID0gMDtcbiAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2UgPSBkaXNwb3NlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGlzcG9zZUFmdGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXIgPSBkaXNwb3NlQWZ0ZXI7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NlZCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jaGFzRGlzcG9zZSA9ICEhdGhpcy4jZGlzcG9zZTtcbiAgICAgICAgdGhpcy4jaGFzRGlzcG9zZUFmdGVyID0gISF0aGlzLiNkaXNwb3NlQWZ0ZXI7XG4gICAgICAgIHRoaXMubm9EaXNwb3NlT25TZXQgPSAhIW5vRGlzcG9zZU9uU2V0O1xuICAgICAgICB0aGlzLm5vVXBkYXRlVFRMID0gISFub1VwZGF0ZVRUTDtcbiAgICAgICAgdGhpcy5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24gPSAhIW5vRGVsZXRlT25GZXRjaFJlamVjdGlvbjtcbiAgICAgICAgdGhpcy5hbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiA9ICEhYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgICAgIHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCA9ICEhYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydDtcbiAgICAgICAgdGhpcy5pZ25vcmVGZXRjaEFib3J0ID0gISFpZ25vcmVGZXRjaEFib3J0O1xuICAgICAgICAvLyBOQjogbWF4RW50cnlTaXplIGlzIHNldCB0byBtYXhTaXplIGlmIGl0J3Mgc2V0XG4gICAgICAgIGlmICh0aGlzLm1heEVudHJ5U2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI21heFNpemUgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUG9zSW50KHRoaXMuI21heFNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heFNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1Bvc0ludCh0aGlzLm1heEVudHJ5U2l6ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhFbnRyeVNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgaWYgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNpbml0aWFsaXplU2l6ZVRyYWNraW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxvd1N0YWxlID0gISFhbGxvd1N0YWxlO1xuICAgICAgICB0aGlzLm5vRGVsZXRlT25TdGFsZUdldCA9ICEhbm9EZWxldGVPblN0YWxlR2V0O1xuICAgICAgICB0aGlzLnVwZGF0ZUFnZU9uR2V0ID0gISF1cGRhdGVBZ2VPbkdldDtcbiAgICAgICAgdGhpcy51cGRhdGVBZ2VPbkhhcyA9ICEhdXBkYXRlQWdlT25IYXM7XG4gICAgICAgIHRoaXMudHRsUmVzb2x1dGlvbiA9XG4gICAgICAgICAgICBpc1Bvc0ludCh0dGxSZXNvbHV0aW9uKSB8fCB0dGxSZXNvbHV0aW9uID09PSAwXG4gICAgICAgICAgICAgICAgPyB0dGxSZXNvbHV0aW9uXG4gICAgICAgICAgICAgICAgOiAxO1xuICAgICAgICB0aGlzLnR0bEF1dG9wdXJnZSA9ICEhdHRsQXV0b3B1cmdlO1xuICAgICAgICB0aGlzLnR0bCA9IHR0bCB8fCAwO1xuICAgICAgICBpZiAodGhpcy50dGwpIHtcbiAgICAgICAgICAgIGlmICghaXNQb3NJbnQodGhpcy50dGwpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndHRsIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jaW5pdGlhbGl6ZVRUTFRyYWNraW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gbm90IGFsbG93IGNvbXBsZXRlbHkgdW5ib3VuZGVkIGNhY2hlc1xuICAgICAgICBpZiAodGhpcy4jbWF4ID09PSAwICYmIHRoaXMudHRsID09PSAwICYmIHRoaXMuI21heFNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0F0IGxlYXN0IG9uZSBvZiBtYXgsIG1heFNpemUsIG9yIHR0bCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50dGxBdXRvcHVyZ2UgJiYgIXRoaXMuI21heCAmJiAhdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9ICdMUlVfQ0FDSEVfVU5CT1VOREVEJztcbiAgICAgICAgICAgIGlmIChzaG91bGRXYXJuKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgd2FybmVkLmFkZChjb2RlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnVFRMIGNhY2hpbmcgd2l0aG91dCB0dGxBdXRvcHVyZ2UsIG1heCwgb3IgbWF4U2l6ZSBjYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICdyZXN1bHQgaW4gdW5ib3VuZGVkIG1lbW9yeSBjb25zdW1wdGlvbi4nO1xuICAgICAgICAgICAgICAgIGVtaXRXYXJuaW5nKG1zZywgJ1VuYm91bmRlZENhY2hlV2FybmluZycsIGNvZGUsIExSVUNhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHJlbWFpbmluZyBUVEwgdGltZSBmb3IgYSBnaXZlbiBlbnRyeSBrZXlcbiAgICAgKi9cbiAgICBnZXRSZW1haW5pbmdUVEwoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNrZXlNYXAuaGFzKGtleSkgPyBJbmZpbml0eSA6IDA7XG4gICAgfVxuICAgICNpbml0aWFsaXplVFRMVHJhY2tpbmcoKSB7XG4gICAgICAgIGNvbnN0IHR0bHMgPSBuZXcgWmVyb0FycmF5KHRoaXMuI21heCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0cyA9IG5ldyBaZXJvQXJyYXkodGhpcy4jbWF4KTtcbiAgICAgICAgdGhpcy4jdHRscyA9IHR0bHM7XG4gICAgICAgIHRoaXMuI3N0YXJ0cyA9IHN0YXJ0cztcbiAgICAgICAgdGhpcy4jc2V0SXRlbVRUTCA9IChpbmRleCwgdHRsLCBzdGFydCA9IHBlcmYubm93KCkpID0+IHtcbiAgICAgICAgICAgIHN0YXJ0c1tpbmRleF0gPSB0dGwgIT09IDAgPyBzdGFydCA6IDA7XG4gICAgICAgICAgICB0dGxzW2luZGV4XSA9IHR0bDtcbiAgICAgICAgICAgIGlmICh0dGwgIT09IDAgJiYgdGhpcy50dGxBdXRvcHVyZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNpc1N0YWxlKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGUodGhpcy4ja2V5TGlzdFtpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgdHRsICsgMSk7XG4gICAgICAgICAgICAgICAgLy8gdW5yZWYoKSBub3Qgc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXNcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBpZiAodC51bnJlZikge1xuICAgICAgICAgICAgICAgICAgICB0LnVucmVmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI3VwZGF0ZUl0ZW1BZ2UgPSBpbmRleCA9PiB7XG4gICAgICAgICAgICBzdGFydHNbaW5kZXhdID0gdHRsc1tpbmRleF0gIT09IDAgPyBwZXJmLm5vdygpIDogMDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jc3RhdHVzVFRMID0gKHN0YXR1cywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmICh0dGxzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR0bCA9IHR0bHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhcnRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgIGlmICghdHRsIHx8ICFzdGFydClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHN0YXR1cy50dGwgPSB0dGw7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgc3RhdHVzLm5vdyA9IGNhY2hlZE5vdyB8fCBnZXROb3coKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhZ2UgPSBzdGF0dXMubm93IC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnJlbWFpbmluZ1RUTCA9IHR0bCAtIGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZGVib3VuY2UgY2FsbHMgdG8gcGVyZi5ub3coKSB0byAxcyBzbyB3ZSdyZSBub3QgaGl0dGluZ1xuICAgICAgICAvLyB0aGF0IGNvc3RseSBjYWxsIHJlcGVhdGVkbHkuXG4gICAgICAgIGxldCBjYWNoZWROb3cgPSAwO1xuICAgICAgICBjb25zdCBnZXROb3cgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gcGVyZi5ub3coKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR0bFJlc29sdXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkTm93ID0gbjtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiAoY2FjaGVkTm93ID0gMCksIHRoaXMudHRsUmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgLy8gbm90IGF2YWlsYWJsZSBvbiBhbGwgcGxhdGZvcm1zXG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgaWYgKHQudW5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdC51bnJlZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0UmVtYWluaW5nVFRMID0ga2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR0bCA9IHR0bHNbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBzdGFydHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCF0dGwgfHwgIXN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWdlID0gKGNhY2hlZE5vdyB8fCBnZXROb3coKSkgLSBzdGFydDtcbiAgICAgICAgICAgIHJldHVybiB0dGwgLSBhZ2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2lzU3RhbGUgPSBpbmRleCA9PiB7XG4gICAgICAgICAgICBjb25zdCBzID0gc3RhcnRzW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB0dGxzW2luZGV4XTtcbiAgICAgICAgICAgIHJldHVybiAhIXQgJiYgISFzICYmIChjYWNoZWROb3cgfHwgZ2V0Tm93KCkpIC0gcyA+IHQ7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGNvbmRpdGlvbmFsbHkgc2V0IHByaXZhdGUgbWV0aG9kcyByZWxhdGVkIHRvIFRUTFxuICAgICN1cGRhdGVJdGVtQWdlID0gKCkgPT4geyB9O1xuICAgICNzdGF0dXNUVEwgPSAoKSA9PiB7IH07XG4gICAgI3NldEl0ZW1UVEwgPSAoKSA9PiB7IH07XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAjaXNTdGFsZSA9ICgpID0+IGZhbHNlO1xuICAgICNpbml0aWFsaXplU2l6ZVRyYWNraW5nKCkge1xuICAgICAgICBjb25zdCBzaXplcyA9IG5ldyBaZXJvQXJyYXkodGhpcy4jbWF4KTtcbiAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgPSAwO1xuICAgICAgICB0aGlzLiNzaXplcyA9IHNpemVzO1xuICAgICAgICB0aGlzLiNyZW1vdmVJdGVtU2l6ZSA9IGluZGV4ID0+IHtcbiAgICAgICAgICAgIHRoaXMuI2NhbGN1bGF0ZWRTaXplIC09IHNpemVzW2luZGV4XTtcbiAgICAgICAgICAgIHNpemVzW2luZGV4XSA9IDA7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI3JlcXVpcmVTaXplID0gKGssIHYsIHNpemUsIHNpemVDYWxjdWxhdGlvbikgPT4ge1xuICAgICAgICAgICAgLy8gcHJvdmlzaW9uYWxseSBhY2NlcHQgYmFja2dyb3VuZCBmZXRjaGVzLlxuICAgICAgICAgICAgLy8gYWN0dWFsIHZhbHVlIHNpemUgd2lsbCBiZSBjaGVja2VkIHdoZW4gdGhleSByZXR1cm4uXG4gICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQb3NJbnQoc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2l6ZUNhbGN1bGF0aW9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplQ2FsY3VsYXRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IHNpemVDYWxjdWxhdGlvbih2LCBrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Bvc0ludChzaXplKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2l6ZUNhbGN1bGF0aW9uIHJldHVybiBpbnZhbGlkIChleHBlY3QgcG9zaXRpdmUgaW50ZWdlciknKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzaXplIHZhbHVlIChtdXN0IGJlIHBvc2l0aXZlIGludGVnZXIpLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdXaGVuIG1heFNpemUgb3IgbWF4RW50cnlTaXplIGlzIHVzZWQsIHNpemVDYWxjdWxhdGlvbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdvciBzaXplIG11c3QgYmUgc2V0LicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNhZGRJdGVtU2l6ZSA9IChpbmRleCwgc2l6ZSwgc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBzaXplc1tpbmRleF0gPSBzaXplO1xuICAgICAgICAgICAgaWYgKHRoaXMuI21heFNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhTaXplID0gdGhpcy4jbWF4U2l6ZSAtIHNpemVzW2luZGV4XTtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy4jY2FsY3VsYXRlZFNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2V2aWN0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2NhbGN1bGF0ZWRTaXplICs9IHNpemVzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZW50cnlTaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICBzdGF0dXMudG90YWxDYWxjdWxhdGVkU2l6ZSA9IHRoaXMuI2NhbGN1bGF0ZWRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAjcmVtb3ZlSXRlbVNpemUgPSBfaSA9PiB7IH07XG4gICAgI2FkZEl0ZW1TaXplID0gKF9pLCBfcywgX3N0KSA9PiB7IH07XG4gICAgI3JlcXVpcmVTaXplID0gKF9rLCBfdiwgc2l6ZSwgc2l6ZUNhbGN1bGF0aW9uKSA9PiB7XG4gICAgICAgIGlmIChzaXplIHx8IHNpemVDYWxjdWxhdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBzaXplIHdpdGhvdXQgc2V0dGluZyBtYXhTaXplIG9yIG1heEVudHJ5U2l6ZSBvbiBjYWNoZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgKiNpbmRleGVzKHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuI3NpemUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLiN0YWlsOyB0cnVlOykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy4jaXNWYWxpZEluZGV4KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dTdGFsZSB8fCAhdGhpcy4jaXNTdGFsZShpKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy4jaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLiNwcmV2W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAqI3JpbmRleGVzKHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuI3NpemUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLiNoZWFkOyB0cnVlOykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy4jaXNWYWxpZEluZGV4KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dTdGFsZSB8fCAhdGhpcy4jaXNTdGFsZShpKSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy4jdGFpbCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLiNuZXh0W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAjaXNWYWxpZEluZGV4KGluZGV4KSB7XG4gICAgICAgIHJldHVybiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy4ja2V5TWFwLmdldCh0aGlzLiNrZXlMaXN0W2luZGV4XSkgPT09IGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIGBba2V5LCB2YWx1ZV1gIHBhaXJzLFxuICAgICAqIGluIG9yZGVyIGZyb20gbW9zdCByZWNlbnRseSB1c2VkIHRvIGxlYXN0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKmVudHJpZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiN2YWxMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiNrZXlMaXN0W2ldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBbdGhpcy4ja2V5TGlzdFtpXSwgdGhpcy4jdmFsTGlzdFtpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52ZXJzZSBvcmRlciB2ZXJzaW9uIG9mIHtAbGluayBMUlVDYWNoZS5lbnRyaWVzfVxuICAgICAqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIGBba2V5LCB2YWx1ZV1gIHBhaXJzLFxuICAgICAqIGluIG9yZGVyIGZyb20gbGVhc3QgcmVjZW50bHkgdXNlZCB0byBtb3N0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKnJlbnRyaWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jcmluZGV4ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3ZhbExpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIFt0aGlzLiNrZXlMaXN0W2ldLCB0aGlzLiN2YWxMaXN0W2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgdGhlIGtleXMgaW4gdGhlIGNhY2hlLFxuICAgICAqIGluIG9yZGVyIGZyb20gbW9zdCByZWNlbnRseSB1c2VkIHRvIGxlYXN0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKmtleXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSB0aGlzLiNrZXlMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52ZXJzZSBvcmRlciB2ZXJzaW9uIG9mIHtAbGluayBMUlVDYWNoZS5rZXlzfVxuICAgICAqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSBrZXlzIGluIHRoZSBjYWNoZSxcbiAgICAgKiBpbiBvcmRlciBmcm9tIGxlYXN0IHJlY2VudGx5IHVzZWQgdG8gbW9zdCByZWNlbnRseSB1c2VkLlxuICAgICAqL1xuICAgICpya2V5cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI3JpbmRleGVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSB0aGlzLiNrZXlMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKGsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSB2YWx1ZXMgaW4gdGhlIGNhY2hlLFxuICAgICAqIGluIG9yZGVyIGZyb20gbW9zdCByZWNlbnRseSB1c2VkIHRvIGxlYXN0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKnZhbHVlcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIG9yZGVyIHZlcnNpb24gb2Yge0BsaW5rIExSVUNhY2hlLnZhbHVlc31cbiAgICAgKlxuICAgICAqIFJldHVybiBhIGdlbmVyYXRvciB5aWVsZGluZyB0aGUgdmFsdWVzIGluIHRoZSBjYWNoZSxcbiAgICAgKiBpbiBvcmRlciBmcm9tIGxlYXN0IHJlY2VudGx5IHVzZWQgdG8gbW9zdCByZWNlbnRseSB1c2VkLlxuICAgICAqL1xuICAgICpydmFsdWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jcmluZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVyYXRpbmcgb3ZlciB0aGUgY2FjaGUgaXRzZWxmIHlpZWxkcyB0aGUgc2FtZSByZXN1bHRzIGFzXG4gICAgICoge0BsaW5rIExSVUNhY2hlLmVudHJpZXN9XG4gICAgICovXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBTdHJpbmcgdmFsdWUgdGhhdCBpcyB1c2VkIGluIHRoZSBjcmVhdGlvbiBvZiB0aGUgZGVmYXVsdCBzdHJpbmcgZGVzY3JpcHRpb24gb2YgYW4gb2JqZWN0LlxuICAgICAqIENhbGxlZCBieSB0aGUgYnVpbHQtaW4gbWV0aG9kIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuXG4gICAgICovXG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAnTFJVQ2FjaGUnO1xuICAgIC8qKlxuICAgICAqIEZpbmQgYSB2YWx1ZSBmb3Igd2hpY2ggdGhlIHN1cHBsaWVkIGZuIG1ldGhvZCByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlLFxuICAgICAqIHNpbWlsYXIgdG8gQXJyYXkuZmluZCgpLiAgZm4gaXMgY2FsbGVkIGFzIGZuKHZhbHVlLCBrZXksIGNhY2hlKS5cbiAgICAgKi9cbiAgICBmaW5kKGZuLCBnZXRPcHRpb25zID0ge30pIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpXG4gICAgICAgICAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICAgICAgOiB2O1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoZm4odmFsdWUsIHRoaXMuI2tleUxpc3RbaV0sIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMuI2tleUxpc3RbaV0sIGdldE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIG9uIGVhY2ggaXRlbSBpbiB0aGUgY2FjaGUsIGluIG9yZGVyIGZyb21cbiAgICAgKiBtb3N0IHJlY2VudGx5IHVzZWQgdG8gbGVhc3QgcmVjZW50bHkgdXNlZC4gIGZuIGlzIGNhbGxlZCBhc1xuICAgICAqIGZuKHZhbHVlLCBrZXksIGNhY2hlKS4gIERvZXMgbm90IHVwZGF0ZSBhZ2Ugb3IgcmVjZW50eSBvZiB1c2UuXG4gICAgICogRG9lcyBub3QgaXRlcmF0ZSBvdmVyIHN0YWxlIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmb3JFYWNoKGZuLCB0aGlzcCA9IHRoaXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpXG4gICAgICAgICAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICAgICAgOiB2O1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXNwLCB2YWx1ZSwgdGhpcy4ja2V5TGlzdFtpXSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMge0BsaW5rIExSVUNhY2hlLmZvckVhY2h9IGJ1dCBpdGVtcyBhcmUgaXRlcmF0ZWQgb3ZlciBpblxuICAgICAqIHJldmVyc2Ugb3JkZXIuICAoaWUsIGxlc3MgcmVjZW50bHkgdXNlZCBpdGVtcyBhcmUgaXRlcmF0ZWQgb3ZlciBmaXJzdC4pXG4gICAgICovXG4gICAgcmZvckVhY2goZm4sIHRoaXNwID0gdGhpcykge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jcmluZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpXG4gICAgICAgICAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICAgICAgOiB2O1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXNwLCB2YWx1ZSwgdGhpcy4ja2V5TGlzdFtpXSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFueSBzdGFsZSBlbnRyaWVzLiBSZXR1cm5zIHRydWUgaWYgYW55dGhpbmcgd2FzIHJlbW92ZWQsXG4gICAgICogZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHB1cmdlU3RhbGUoKSB7XG4gICAgICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNyaW5kZXhlcyh7IGFsbG93U3RhbGU6IHRydWUgfSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc1N0YWxlKGkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGUodGhpcy4ja2V5TGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlbGV0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZXh0ZW5kZWQgaW5mbyBhYm91dCBhIGdpdmVuIGVudHJ5LCB0byBnZXQgaXRzIHZhbHVlLCBzaXplLCBhbmRcbiAgICAgKiBUVEwgaW5mbyBzaW11bHRhbmVvdXNseS4gTGlrZSB7QGxpbmsgTFJVQ2FjaGUjZHVtcH0sIGJ1dCBqdXN0IGZvciBhXG4gICAgICogc2luZ2xlIGtleS4gQWx3YXlzIHJldHVybnMgc3RhbGUgdmFsdWVzLCBpZiB0aGVpciBpbmZvIGlzIGZvdW5kIGluIHRoZVxuICAgICAqIGNhY2hlLCBzbyBiZSBzdXJlIHRvIGNoZWNrIGZvciBleHBpcmVkIFRUTHMgaWYgcmVsZXZhbnQuXG4gICAgICovXG4gICAgaW5mbyhrZXkpIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuI2tleU1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpXG4gICAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgIDogdjtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBlbnRyeSA9IHsgdmFsdWUgfTtcbiAgICAgICAgaWYgKHRoaXMuI3R0bHMgJiYgdGhpcy4jc3RhcnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0dGwgPSB0aGlzLiN0dGxzW2ldO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLiNzdGFydHNbaV07XG4gICAgICAgICAgICBpZiAodHRsICYmIHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluID0gdHRsIC0gKHBlcmYubm93KCkgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgZW50cnkudHRsID0gcmVtYWluO1xuICAgICAgICAgICAgICAgIGVudHJ5LnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jc2l6ZXMpIHtcbiAgICAgICAgICAgIGVudHJ5LnNpemUgPSB0aGlzLiNzaXplc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBba2V5LCB7QGxpbmsgTFJVQ2FjaGUuRW50cnl9XSB0dXBsZXMgd2hpY2ggY2FuIGJlXG4gICAgICogcGFzc2VkIHRvIGNhY2hlLmxvYWQoKVxuICAgICAqL1xuICAgIGR1bXAoKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcyh7IGFsbG93U3RhbGU6IHRydWUgfSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuI2tleUxpc3RbaV07XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICA6IHY7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCBrZXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0geyB2YWx1ZSB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuI3R0bHMgJiYgdGhpcy4jc3RhcnRzKSB7XG4gICAgICAgICAgICAgICAgZW50cnkudHRsID0gdGhpcy4jdHRsc1tpXTtcbiAgICAgICAgICAgICAgICAvLyBhbHdheXMgZHVtcCB0aGUgc3RhcnQgcmVsYXRpdmUgdG8gYSBwb3J0YWJsZSB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAvLyBpdCdzIG9rIGZvciB0aGlzIHRvIGJlIGEgYml0IHNsb3csIGl0J3MgYSByYXJlIG9wZXJhdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zdCBhZ2UgPSBwZXJmLm5vdygpIC0gdGhpcy4jc3RhcnRzW2ldO1xuICAgICAgICAgICAgICAgIGVudHJ5LnN0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC0gYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNzaXplcykge1xuICAgICAgICAgICAgICAgIGVudHJ5LnNpemUgPSB0aGlzLiNzaXplc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyci51bnNoaWZ0KFtrZXksIGVudHJ5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGNhY2hlIGFuZCBsb2FkIGluIHRoZSBpdGVtcyBpbiBlbnRyaWVzIGluIHRoZSBvcmRlciBsaXN0ZWQuXG4gICAgICogTm90ZSB0aGF0IHRoZSBzaGFwZSBvZiB0aGUgcmVzdWx0aW5nIGNhY2hlIG1heSBiZSBkaWZmZXJlbnQgaWYgdGhlXG4gICAgICogc2FtZSBvcHRpb25zIGFyZSBub3QgdXNlZCBpbiBib3RoIGNhY2hlcy5cbiAgICAgKi9cbiAgICBsb2FkKGFycikge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIGFycikge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgLy8gZW50cnkuc3RhcnQgaXMgYSBwb3J0YWJsZSB0aW1lc3RhbXAsIGJ1dCB3ZSBtYXkgYmUgdXNpbmdcbiAgICAgICAgICAgICAgICAvLyBub2RlJ3MgcGVyZm9ybWFuY2Uubm93KCksIHNvIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0LCBzbyB0aGF0XG4gICAgICAgICAgICAgICAgLy8gd2UgZ2V0IHRoZSBpbnRlbmRlZCByZW1haW5pbmcgVFRMLCBubyBtYXR0ZXIgaG93IGxvbmcgaXQnc1xuICAgICAgICAgICAgICAgIC8vIGJlZW4gb24gaWNlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gaXQncyBvayBmb3IgdGhpcyB0byBiZSBhIGJpdCBzbG93LCBpdCdzIGEgcmFyZSBvcGVyYXRpb24uXG4gICAgICAgICAgICAgICAgY29uc3QgYWdlID0gRGF0ZS5ub3coKSAtIGVudHJ5LnN0YXJ0O1xuICAgICAgICAgICAgICAgIGVudHJ5LnN0YXJ0ID0gcGVyZi5ub3coKSAtIGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgZW50cnkudmFsdWUsIGVudHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSB2YWx1ZSB0byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiBpZiBgdW5kZWZpbmVkYCBpcyBzcGVjaWZpZWQgYXMgYSB2YWx1ZSwgdGhpcyBpcyBhbiBhbGlhcyBmb3JcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUjZGVsZXRlfVxuICAgICAqL1xuICAgIHNldChrLCB2LCBzZXRPcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGUoayk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHR0bCA9IHRoaXMudHRsLCBzdGFydCwgbm9EaXNwb3NlT25TZXQgPSB0aGlzLm5vRGlzcG9zZU9uU2V0LCBzaXplQ2FsY3VsYXRpb24gPSB0aGlzLnNpemVDYWxjdWxhdGlvbiwgc3RhdHVzLCB9ID0gc2V0T3B0aW9ucztcbiAgICAgICAgbGV0IHsgbm9VcGRhdGVUVEwgPSB0aGlzLm5vVXBkYXRlVFRMIH0gPSBzZXRPcHRpb25zO1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy4jcmVxdWlyZVNpemUoaywgdiwgc2V0T3B0aW9ucy5zaXplIHx8IDAsIHNpemVDYWxjdWxhdGlvbik7XG4gICAgICAgIC8vIGlmIHRoZSBpdGVtIGRvZXNuJ3QgZml0LCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAvLyBOQjogbWF4RW50cnlTaXplIHNldCB0byBtYXhTaXplIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKHRoaXMubWF4RW50cnlTaXplICYmIHNpemUgPiB0aGlzLm1heEVudHJ5U2l6ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQgPSAnbWlzcyc7XG4gICAgICAgICAgICAgICAgc3RhdHVzLm1heEVudHJ5U2l6ZUV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhdmUgdG8gZGVsZXRlLCBpbiBjYXNlIHNvbWV0aGluZyBpcyB0aGVyZSBhbHJlYWR5LlxuICAgICAgICAgICAgdGhpcy5kZWxldGUoayk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLiNzaXplID09PSAwID8gdW5kZWZpbmVkIDogdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGFkZGl0aW9uXG4gICAgICAgICAgICBpbmRleCA9ICh0aGlzLiNzaXplID09PSAwXG4gICAgICAgICAgICAgICAgPyB0aGlzLiN0YWlsXG4gICAgICAgICAgICAgICAgOiB0aGlzLiNmcmVlLmxlbmd0aCAhPT0gMFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuI2ZyZWUucG9wKClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLiNzaXplID09PSB0aGlzLiNtYXhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy4jZXZpY3QoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuI3NpemUpO1xuICAgICAgICAgICAgdGhpcy4ja2V5TGlzdFtpbmRleF0gPSBrO1xuICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSB2O1xuICAgICAgICAgICAgdGhpcy4ja2V5TWFwLnNldChrLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLiNuZXh0W3RoaXMuI3RhaWxdID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLiNwcmV2W2luZGV4XSA9IHRoaXMuI3RhaWw7XG4gICAgICAgICAgICB0aGlzLiN0YWlsID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLiNzaXplKys7XG4gICAgICAgICAgICB0aGlzLiNhZGRJdGVtU2l6ZShpbmRleCwgc2l6ZSwgc3RhdHVzKTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgc3RhdHVzLnNldCA9ICdhZGQnO1xuICAgICAgICAgICAgbm9VcGRhdGVUVEwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZVxuICAgICAgICAgICAgdGhpcy4jbW92ZVRvVGFpbChpbmRleCk7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWwgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGlmICh2ICE9PSBvbGRWYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRmV0Y2hNZXRob2QgJiYgdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2gob2xkVmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBvbGRWYWwuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdyZXBsYWNlZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBfX3N0YWxlV2hpbGVGZXRjaGluZzogcyB9ID0gb2xkVmFsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocyAhPT0gdW5kZWZpbmVkICYmICFub0Rpc3Bvc2VPblNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlPy4ocywgaywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkPy5wdXNoKFtzLCBrLCAnc2V0J10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFub0Rpc3Bvc2VPblNldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZT8uKG9sZFZhbCwgaywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkPy5wdXNoKFtvbGRWYWwsIGssICdzZXQnXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVtb3ZlSXRlbVNpemUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMuI2FkZEl0ZW1TaXplKGluZGV4LCBzaXplLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gdjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQgPSAncmVwbGFjZSc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gb2xkVmFsICYmIHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKG9sZFZhbClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gb2xkVmFsLl9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9sZFZhbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMub2xkVmFsdWUgPSBvbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuc2V0ID0gJ3VwZGF0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR0bCAhPT0gMCAmJiAhdGhpcy4jdHRscykge1xuICAgICAgICAgICAgdGhpcy4jaW5pdGlhbGl6ZVRUTFRyYWNraW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3R0bHMpIHtcbiAgICAgICAgICAgIGlmICghbm9VcGRhdGVUVEwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNzZXRJdGVtVFRMKGluZGV4LCB0dGwsIHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9EaXNwb3NlT25TZXQgJiYgdGhpcy4jaGFzRGlzcG9zZUFmdGVyICYmIHRoaXMuI2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuI2Rpc3Bvc2VkO1xuICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBkdD8uc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXI/LiguLi50YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZpY3QgdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgaXRlbSwgcmV0dXJuaW5nIGl0cyB2YWx1ZSBvclxuICAgICAqIGB1bmRlZmluZWRgIGlmIGNhY2hlIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIHBvcCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLiNzaXplKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy4jdmFsTGlzdFt0aGlzLiNoZWFkXTtcbiAgICAgICAgICAgICAgICB0aGlzLiNldmljdCh0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLl9fc3RhbGVXaGlsZUZldGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLl9fc3RhbGVXaGlsZUZldGNoaW5nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciAmJiB0aGlzLiNkaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR0ID0gdGhpcy4jZGlzcG9zZWQ7XG4gICAgICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gZHQ/LnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VBZnRlcj8uKC4uLnRhc2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAjZXZpY3QoZnJlZSkge1xuICAgICAgICBjb25zdCBoZWFkID0gdGhpcy4jaGVhZDtcbiAgICAgICAgY29uc3QgayA9IHRoaXMuI2tleUxpc3RbaGVhZF07XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2hlYWRdO1xuICAgICAgICBpZiAodGhpcy4jaGFzRmV0Y2hNZXRob2QgJiYgdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgIHYuX19hYm9ydENvbnRyb2xsZXIuYWJvcnQobmV3IEVycm9yKCdldmljdGVkJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UgfHwgdGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2U/Lih2LCBrLCAnZXZpY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbdiwgaywgJ2V2aWN0J10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3JlbW92ZUl0ZW1TaXplKGhlYWQpO1xuICAgICAgICAvLyBpZiB3ZSBhcmVuJ3QgYWJvdXQgdG8gdXNlIHRoZSBpbmRleCwgdGhlbiBudWxsIHRoZXNlIG91dFxuICAgICAgICBpZiAoZnJlZSkge1xuICAgICAgICAgICAgdGhpcy4ja2V5TGlzdFtoZWFkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaGVhZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLiNmcmVlLnB1c2goaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI3NpemUgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuI2hlYWQgPSB0aGlzLiN0YWlsID0gMDtcbiAgICAgICAgICAgIHRoaXMuI2ZyZWUubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2hlYWQgPSB0aGlzLiNuZXh0W2hlYWRdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2tleU1hcC5kZWxldGUoayk7XG4gICAgICAgIHRoaXMuI3NpemUtLTtcbiAgICAgICAgcmV0dXJuIGhlYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEga2V5IGlzIGluIHRoZSBjYWNoZSwgd2l0aG91dCB1cGRhdGluZyB0aGUgcmVjZW5jeSBvZiB1c2UuXG4gICAgICogV2lsbCByZXR1cm4gZmFsc2UgaWYgdGhlIGl0ZW0gaXMgc3RhbGUsIGV2ZW4gdGhvdWdoIGl0IGlzIHRlY2huaWNhbGx5XG4gICAgICogaW4gdGhlIGNhY2hlLlxuICAgICAqXG4gICAgICogV2lsbCBub3QgdXBkYXRlIGl0ZW0gYWdlIHVubGVzc1xuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS51cGRhdGVBZ2VPbkhhc30gaXMgc2V0LlxuICAgICAqL1xuICAgIGhhcyhrLCBoYXNPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyB1cGRhdGVBZ2VPbkhhcyA9IHRoaXMudXBkYXRlQWdlT25IYXMsIHN0YXR1cyB9ID0gaGFzT3B0aW9ucztcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGspO1xuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpICYmXG4gICAgICAgICAgICAgICAgdi5fX3N0YWxlV2hpbGVGZXRjaGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLiNpc1N0YWxlKGluZGV4KSkge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVBZ2VPbkhhcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiN1cGRhdGVJdGVtQWdlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuaGFzID0gJ2hpdCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuaGFzID0gJ3N0YWxlJztcbiAgICAgICAgICAgICAgICB0aGlzLiNzdGF0dXNUVEwoc3RhdHVzLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICBzdGF0dXMuaGFzID0gJ21pc3MnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlrZSB7QGxpbmsgTFJVQ2FjaGUjZ2V0fSBidXQgZG9lc24ndCB1cGRhdGUgcmVjZW5jeSBvciBkZWxldGUgc3RhbGVcbiAgICAgKiBpdGVtcy5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGl0ZW0gaXMgc3RhbGUsIHVubGVzc1xuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5hbGxvd1N0YWxlfSBpcyBzZXQuXG4gICAgICovXG4gICAgcGVlayhrLCBwZWVrT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0gcGVla09wdGlvbnM7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICghYWxsb3dTdGFsZSAmJiB0aGlzLiNpc1N0YWxlKGluZGV4KSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgIC8vIGVpdGhlciBzdGFsZSBhbmQgYWxsb3dlZCwgb3IgZm9yY2luZyBhIHJlZnJlc2ggb2Ygbm9uLXN0YWxlIHZhbHVlXG4gICAgICAgIHJldHVybiB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiB2O1xuICAgIH1cbiAgICAjYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHYgPSBpbmRleCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWMgPSBuZXcgQUMoKTtcbiAgICAgICAgY29uc3QgeyBzaWduYWwgfSA9IG9wdGlvbnM7XG4gICAgICAgIC8vIHdoZW4vaWYgb3VyIEFDIHNpZ25hbHMsIHRoZW4gc3RvcCBsaXN0ZW5pbmcgdG8gdGhlaXJzLlxuICAgICAgICBzaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gYWMuYWJvcnQoc2lnbmFsLnJlYXNvbiksIHtcbiAgICAgICAgICAgIHNpZ25hbDogYWMuc2lnbmFsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmV0Y2hPcHRzID0ge1xuICAgICAgICAgICAgc2lnbmFsOiBhYy5zaWduYWwsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2IgPSAodiwgdXBkYXRlQ2FjaGUgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhYm9ydGVkIH0gPSBhYy5zaWduYWw7XG4gICAgICAgICAgICBjb25zdCBpZ25vcmVBYm9ydCA9IG9wdGlvbnMuaWdub3JlRmV0Y2hBYm9ydCAmJiB2ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJvcnRlZCAmJiAhdXBkYXRlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hBYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hFcnJvciA9IGFjLnNpZ25hbC5yZWFzb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVBYm9ydClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoQWJvcnRJZ25vcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYm9ydGVkICYmICFpZ25vcmVBYm9ydCAmJiAhdXBkYXRlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hGYWlsKGFjLnNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWl0aGVyIHdlIGRpZG4ndCBhYm9ydCwgYW5kIGFyZSBzdGlsbCBoZXJlLCBvciB3ZSBkaWQsIGFuZCBpZ25vcmVkXG4gICAgICAgICAgICBjb25zdCBiZiA9IHA7XG4gICAgICAgICAgICBpZiAodGhpcy4jdmFsTGlzdFtpbmRleF0gPT09IHApIHtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZi5fX3N0YWxlV2hpbGVGZXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSBiZi5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlKGspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaFVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldChrLCB2LCBmZXRjaE9wdHMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGViID0gKGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaFJlamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaEVycm9yID0gZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hGYWlsKGVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmV0Y2hGYWlsID0gKGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGFib3J0ZWQgfSA9IGFjLnNpZ25hbDtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93U3RhbGVBYm9ydGVkID0gYWJvcnRlZCAmJiBvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoQWJvcnQ7XG4gICAgICAgICAgICBjb25zdCBhbGxvd1N0YWxlID0gYWxsb3dTdGFsZUFib3J0ZWQgfHwgb3B0aW9ucy5hbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IG5vRGVsZXRlID0gYWxsb3dTdGFsZSB8fCBvcHRpb25zLm5vRGVsZXRlT25GZXRjaFJlamVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGJmID0gcDtcbiAgICAgICAgICAgIGlmICh0aGlzLiN2YWxMaXN0W2luZGV4XSA9PT0gcCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFsbG93IHN0YWxlIG9uIGZldGNoIHJlamVjdGlvbnMsIHRoZW4gd2UgbmVlZCB0byBlbnN1cmUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdGFsZSB2YWx1ZSBpcyBub3QgcmVtb3ZlZCBmcm9tIHRoZSBjYWNoZSB3aGVuIHRoZSBmZXRjaCBmYWlscy5cbiAgICAgICAgICAgICAgICBjb25zdCBkZWwgPSAhbm9EZWxldGUgfHwgYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlKGspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYWxsb3dTdGFsZUFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RpbGwgcmVwbGFjZSB0aGUgKnByb21pc2UqIHdpdGggdGhlIHN0YWxlIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBhcmUgZG9uZSB3aXRoIHRoZSBwcm9taXNlIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgIC8vIGxlYXZlIGl0IHVudG91Y2hlZCBpZiB3ZSdyZSBzdGlsbCB3YWl0aW5nIGZvciBhblxuICAgICAgICAgICAgICAgICAgICAvLyBhYm9ydGVkIGJhY2tncm91bmQgZmV0Y2ggdGhhdCBoYXNuJ3QgeWV0IHJldHVybmVkLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbGxvd1N0YWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzICYmIGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMucmV0dXJuZWRTdGFsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiZi5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJmLl9fcmV0dXJuZWQgPT09IGJmKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBjYWxsID0gKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmbXAgPSB0aGlzLiNmZXRjaE1ldGhvZD8uKGssIHYsIGZldGNoT3B0cyk7XG4gICAgICAgICAgICBpZiAoZm1wICYmIGZtcCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBmbXAudGhlbih2ID0+IHJlcyh2ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB2KSwgcmVqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlnbm9yZWQsIHdlIGdvIHVudGlsIHdlIGZpbmlzaCwgcmVnYXJkbGVzcy5cbiAgICAgICAgICAgIC8vIGRlZmVyIGNoZWNrIHVudGlsIHdlIGFyZSBhY3R1YWxseSBhYm9ydGluZyxcbiAgICAgICAgICAgIC8vIHNvIGZldGNoTWV0aG9kIGNhbiBvdmVycmlkZS5cbiAgICAgICAgICAgIGFjLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMuaWdub3JlRmV0Y2hBYm9ydCB8fFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFsbG93U3RhbGVPbkZldGNoQWJvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gaXQgZXZlbnR1YWxseSByZXNvbHZlcywgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gdiA9PiBjYih2LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5zdGF0dXMpXG4gICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5mZXRjaERpc3BhdGNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBwID0gbmV3IFByb21pc2UocGNhbGwpLnRoZW4oY2IsIGViKTtcbiAgICAgICAgY29uc3QgYmYgPSBPYmplY3QuYXNzaWduKHAsIHtcbiAgICAgICAgICAgIF9fYWJvcnRDb250cm9sbGVyOiBhYyxcbiAgICAgICAgICAgIF9fc3RhbGVXaGlsZUZldGNoaW5nOiB2LFxuICAgICAgICAgICAgX19yZXR1cm5lZDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGludGVybmFsLCBkb24ndCBleHBvc2Ugc3RhdHVzLlxuICAgICAgICAgICAgdGhpcy5zZXQoaywgYmYsIHsgLi4uZmV0Y2hPcHRzLm9wdGlvbnMsIHN0YXR1czogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSBiZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmY7XG4gICAgfVxuICAgICNpc0JhY2tncm91bmRGZXRjaChwKSB7XG4gICAgICAgIGlmICghdGhpcy4jaGFzRmV0Y2hNZXRob2QpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGIgPSBwO1xuICAgICAgICByZXR1cm4gKCEhYiAmJlxuICAgICAgICAgICAgYiBpbnN0YW5jZW9mIFByb21pc2UgJiZcbiAgICAgICAgICAgIGIuaGFzT3duUHJvcGVydHkoJ19fc3RhbGVXaGlsZUZldGNoaW5nJykgJiZcbiAgICAgICAgICAgIGIuX19hYm9ydENvbnRyb2xsZXIgaW5zdGFuY2VvZiBBQyk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoKGssIGZldGNoT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgXG4gICAgICAgIC8vIGdldCBvcHRpb25zXG4gICAgICAgIGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUsIHVwZGF0ZUFnZU9uR2V0ID0gdGhpcy51cGRhdGVBZ2VPbkdldCwgbm9EZWxldGVPblN0YWxlR2V0ID0gdGhpcy5ub0RlbGV0ZU9uU3RhbGVHZXQsIFxuICAgICAgICAvLyBzZXQgb3B0aW9uc1xuICAgICAgICB0dGwgPSB0aGlzLnR0bCwgbm9EaXNwb3NlT25TZXQgPSB0aGlzLm5vRGlzcG9zZU9uU2V0LCBzaXplID0gMCwgc2l6ZUNhbGN1bGF0aW9uID0gdGhpcy5zaXplQ2FsY3VsYXRpb24sIG5vVXBkYXRlVFRMID0gdGhpcy5ub1VwZGF0ZVRUTCwgXG4gICAgICAgIC8vIGZldGNoIGV4Y2x1c2l2ZSBvcHRpb25zXG4gICAgICAgIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiA9IHRoaXMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uLCBhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiA9IHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24sIGlnbm9yZUZldGNoQWJvcnQgPSB0aGlzLmlnbm9yZUZldGNoQWJvcnQsIGFsbG93U3RhbGVPbkZldGNoQWJvcnQgPSB0aGlzLmFsbG93U3RhbGVPbkZldGNoQWJvcnQsIGNvbnRleHQsIGZvcmNlUmVmcmVzaCA9IGZhbHNlLCBzdGF0dXMsIHNpZ25hbCwgfSA9IGZldGNoT3B0aW9ucztcbiAgICAgICAgaWYgKCF0aGlzLiNoYXNGZXRjaE1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSAnZ2V0JztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrLCB7XG4gICAgICAgICAgICAgICAgYWxsb3dTdGFsZSxcbiAgICAgICAgICAgICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgICAgICAgICAgICBub0RlbGV0ZU9uU3RhbGVHZXQsXG4gICAgICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFsbG93U3RhbGUsXG4gICAgICAgICAgICB1cGRhdGVBZ2VPbkdldCxcbiAgICAgICAgICAgIG5vRGVsZXRlT25TdGFsZUdldCxcbiAgICAgICAgICAgIHR0bCxcbiAgICAgICAgICAgIG5vRGlzcG9zZU9uU2V0LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIHNpemVDYWxjdWxhdGlvbixcbiAgICAgICAgICAgIG5vVXBkYXRlVFRMLFxuICAgICAgICAgICAgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uLFxuICAgICAgICAgICAgYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24sXG4gICAgICAgICAgICBhbGxvd1N0YWxlT25GZXRjaEFib3J0LFxuICAgICAgICAgICAgaWdub3JlRmV0Y2hBYm9ydCxcbiAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmZldGNoID0gJ21pc3MnO1xuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuI2JhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gKHAuX19yZXR1cm5lZCA9IHApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FjaGUsIG1heWJlIGFscmVhZHkgZmV0Y2hpbmdcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLiN2YWxMaXN0W2luZGV4XTtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YWxlID0gYWxsb3dTdGFsZSAmJiB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSAnaW5mbGlnaHQnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMucmV0dXJuZWRTdGFsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFsZSA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiAodi5fX3JldHVybmVkID0gdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB3ZSBmb3JjZSBhIHJlZnJlc2gsIHRoYXQgbWVhbnMgZG8gTk9UIHNlcnZlIHRoZSBjYWNoZWQgdmFsdWUsXG4gICAgICAgICAgICAvLyB1bmxlc3Mgd2UgYXJlIGFscmVhZHkgaW4gdGhlIHByb2Nlc3Mgb2YgcmVmcmVzaGluZyB0aGUgY2FjaGUuXG4gICAgICAgICAgICBjb25zdCBpc1N0YWxlID0gdGhpcy4jaXNTdGFsZShpbmRleCk7XG4gICAgICAgICAgICBpZiAoIWZvcmNlUmVmcmVzaCAmJiAhaXNTdGFsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5mZXRjaCA9ICdoaXQnO1xuICAgICAgICAgICAgICAgIHRoaXMuI21vdmVUb1RhaWwoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVBZ2VPbkdldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiN1cGRhdGVJdGVtQWdlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb2ssIGl0IGlzIHN0YWxlIG9yIGEgZm9yY2VkIHJlZnJlc2gsIGFuZCBub3QgYWxyZWFkeSBmZXRjaGluZy5cbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIGNhY2hlLlxuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMuI2JhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBoYXNTdGFsZSA9IHAuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHN0YWxlVmFsID0gaGFzU3RhbGUgJiYgYWxsb3dTdGFsZTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSBpc1N0YWxlID8gJ3N0YWxlJyA6ICdyZWZyZXNoJztcbiAgICAgICAgICAgICAgICBpZiAoc3RhbGVWYWwgJiYgaXNTdGFsZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YWxlVmFsID8gcC5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IChwLl9fcmV0dXJuZWQgPSBwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB2YWx1ZSBmcm9tIHRoZSBjYWNoZS4gV2lsbCB1cGRhdGUgdGhlIHJlY2VuY3kgb2YgdGhlIGNhY2hlXG4gICAgICogZW50cnkgZm91bmQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUga2V5IGlzIG5vdCBmb3VuZCwgZ2V0KCkgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZ2V0KGssIGdldE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUsIHVwZGF0ZUFnZU9uR2V0ID0gdGhpcy51cGRhdGVBZ2VPbkdldCwgbm9EZWxldGVPblN0YWxlR2V0ID0gdGhpcy5ub0RlbGV0ZU9uU3RhbGVHZXQsIHN0YXR1cywgfSA9IGdldE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBmZXRjaGluZyA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmdldCA9ICdzdGFsZSc7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIG9ubHkgaWYgbm90IGFuIGluLWZsaWdodCBiYWNrZ3JvdW5kIGZldGNoXG4gICAgICAgICAgICAgICAgaWYgKCFmZXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vRGVsZXRlT25TdGFsZUdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGUoayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAmJiBhbGxvd1N0YWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3dTdGFsZSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dTdGFsZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnJldHVybmVkU3RhbGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGxvd1N0YWxlID8gdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmdldCA9ICdoaXQnO1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGN1cnJlbnRseSBmZXRjaGluZyBpdCwgd2UgZG9uJ3QgYWN0dWFsbHkgaGF2ZSBpdCB5ZXRcbiAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBzdGFsZSwgd2hpY2ggbWVhbnMgdGhpcyBpc24ndCBhIHN0YWxlV2hpbGVSZWZldGNoaW5nLlxuICAgICAgICAgICAgICAgIC8vIElmIGl0J3Mgbm90IHN0YWxlLCBhbmQgZmV0Y2hpbmcsIEFORCBoYXMgYSBfX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgICAgIC8vIHZhbHVlLCB0aGVuIHRoYXQgbWVhbnMgdGhlIHVzZXIgZmV0Y2hlZCB3aXRoIHtmb3JjZVJlZnJlc2g6dHJ1ZX0sXG4gICAgICAgICAgICAgICAgLy8gc28gaXQncyBzYWZlIHRvIHJldHVybiB0aGF0IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChmZXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuX19zdGFsZVdoaWxlRmV0Y2hpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuI21vdmVUb1RhaWwoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVBZ2VPbkdldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiN1cGRhdGVJdGVtQWdlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgc3RhdHVzLmdldCA9ICdtaXNzJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAjY29ubmVjdChwLCBuKSB7XG4gICAgICAgIHRoaXMuI3ByZXZbbl0gPSBwO1xuICAgICAgICB0aGlzLiNuZXh0W3BdID0gbjtcbiAgICB9XG4gICAgI21vdmVUb1RhaWwoaW5kZXgpIHtcbiAgICAgICAgLy8gaWYgdGFpbCBhbHJlYWR5LCBub3RoaW5nIHRvIGRvXG4gICAgICAgIC8vIGlmIGhlYWQsIG1vdmUgaGVhZCB0byBuZXh0W2luZGV4XVxuICAgICAgICAvLyBlbHNlXG4gICAgICAgIC8vICAgbW92ZSBuZXh0W3ByZXZbaW5kZXhdXSB0byBuZXh0W2luZGV4XSAoaGVhZCBoYXMgbm8gcHJldilcbiAgICAgICAgLy8gICBtb3ZlIHByZXZbbmV4dFtpbmRleF1dIHRvIHByZXZbaW5kZXhdXG4gICAgICAgIC8vIHByZXZbaW5kZXhdID0gdGFpbFxuICAgICAgICAvLyBuZXh0W3RhaWxdID0gaW5kZXhcbiAgICAgICAgLy8gdGFpbCA9IGluZGV4XG4gICAgICAgIGlmIChpbmRleCAhPT0gdGhpcy4jdGFpbCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLiNoZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jaGVhZCA9IHRoaXMuI25leHRbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jY29ubmVjdCh0aGlzLiNwcmV2W2luZGV4XSwgdGhpcy4jbmV4dFtpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jY29ubmVjdCh0aGlzLiN0YWlsLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLiN0YWlsID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIGtleSBvdXQgb2YgdGhlIGNhY2hlLlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUga2V5IHdhcyBkZWxldGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZGVsZXRlKGspIHtcbiAgICAgICAgbGV0IGRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuI3NpemUgIT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI3NpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcmVtb3ZlSXRlbVNpemUoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdi5fX2Fib3J0Q29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoJ2RlbGV0ZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4jaGFzRGlzcG9zZSB8fCB0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZT8uKHYsIGssICdkZWxldGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlZD8ucHVzaChbdiwgaywgJ2RlbGV0ZSddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNrZXlNYXAuZGVsZXRlKGspO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNrZXlMaXN0W2luZGV4XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy4jdGFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jdGFpbCA9IHRoaXMuI3ByZXZbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLiNoZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jbmV4dFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwaSA9IHRoaXMuI3ByZXZbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jbmV4dFtwaV0gPSB0aGlzLiNuZXh0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5pID0gdGhpcy4jbmV4dFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNwcmV2W25pXSA9IHRoaXMuI3ByZXZbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3NpemUtLTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZnJlZS5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciAmJiB0aGlzLiNkaXNwb3NlZD8ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuI2Rpc3Bvc2VkO1xuICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBkdD8uc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlQWZ0ZXI/LiguLi50YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVsZXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGNhY2hlIGVudGlyZWx5LCB0aHJvd2luZyBhd2F5IGFsbCB2YWx1ZXMuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggb2YgdGhpcy4jcmluZGV4ZXMoeyBhbGxvd1N0YWxlOiB0cnVlIH0pKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBpZiAodGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godikpIHtcbiAgICAgICAgICAgICAgICB2Ll9fYWJvcnRDb250cm9sbGVyLmFib3J0KG5ldyBFcnJvcignZGVsZXRlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGsgPSB0aGlzLiNrZXlMaXN0W2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlPy4odiwgaywgJ2RlbGV0ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkPy5wdXNoKFt2LCBrLCAnZGVsZXRlJ10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNrZXlNYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy4jdmFsTGlzdC5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuI2tleUxpc3QuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICBpZiAodGhpcy4jdHRscyAmJiB0aGlzLiNzdGFydHMpIHtcbiAgICAgICAgICAgIHRoaXMuI3R0bHMuZmlsbCgwKTtcbiAgICAgICAgICAgIHRoaXMuI3N0YXJ0cy5maWxsKDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNzaXplcykge1xuICAgICAgICAgICAgdGhpcy4jc2l6ZXMuZmlsbCgwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNoZWFkID0gMDtcbiAgICAgICAgdGhpcy4jdGFpbCA9IDA7XG4gICAgICAgIHRoaXMuI2ZyZWUubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgPSAwO1xuICAgICAgICB0aGlzLiNzaXplID0gMDtcbiAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciAmJiB0aGlzLiNkaXNwb3NlZCkge1xuICAgICAgICAgICAgY29uc3QgZHQgPSB0aGlzLiNkaXNwb3NlZDtcbiAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gZHQ/LnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyPy4oLi4udGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxSVUNhY2hlID0gTFJVQ2FjaGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJMUlVDYWNoZSIsInBlcmYiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIkRhdGUiLCJ3YXJuZWQiLCJTZXQiLCJQUk9DRVNTIiwicHJvY2VzcyIsImVtaXRXYXJuaW5nIiwibXNnIiwidHlwZSIsImNvZGUiLCJmbiIsImNvbnNvbGUiLCJlcnJvciIsIkFDIiwiZ2xvYmFsVGhpcyIsIkFib3J0Q29udHJvbGxlciIsIkFTIiwiQWJvcnRTaWduYWwiLCJhZGRFdmVudExpc3RlbmVyIiwiXyIsIl9vbmFib3J0IiwicHVzaCIsImFib3J0ZWQiLCJjb25zdHJ1Y3RvciIsInNpZ25hbCIsIndhcm5BQ1BvbHlmaWxsIiwiYWJvcnQiLCJyZWFzb24iLCJvbmFib3J0IiwicHJpbnRBQ1BvbHlmaWxsV2FybmluZyIsImVudiIsIkxSVV9DQUNIRV9JR05PUkVfQUNfV0FSTklORyIsInNob3VsZFdhcm4iLCJoYXMiLCJUWVBFIiwiU3ltYm9sIiwiaXNQb3NJbnQiLCJuIiwiTWF0aCIsImZsb29yIiwiaXNGaW5pdGUiLCJnZXRVaW50QXJyYXkiLCJtYXgiLCJwb3ciLCJVaW50OEFycmF5IiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJaZXJvQXJyYXkiLCJBcnJheSIsInNpemUiLCJmaWxsIiwiU3RhY2siLCJjb25zdHJ1Y3RpbmciLCJjcmVhdGUiLCJIZWFwQ2xzIiwicyIsIlR5cGVFcnJvciIsImhlYXAiLCJsZW5ndGgiLCJwb3AiLCJ0b1N0cmluZ1RhZyIsIm1heFNpemUiLCJkaXNwb3NlIiwiZGlzcG9zZUFmdGVyIiwiZmV0Y2hNZXRob2QiLCJjYWxjdWxhdGVkU2l6ZSIsImtleU1hcCIsImtleUxpc3QiLCJ2YWxMaXN0IiwibmV4dCIsInByZXYiLCJoZWFkIiwidGFpbCIsImZyZWUiLCJkaXNwb3NlZCIsInNpemVzIiwic3RhcnRzIiwidHRscyIsImhhc0Rpc3Bvc2UiLCJoYXNGZXRjaE1ldGhvZCIsImhhc0Rpc3Bvc2VBZnRlciIsInVuc2FmZUV4cG9zZUludGVybmFscyIsImMiLCJpc0JhY2tncm91bmRGZXRjaCIsInAiLCJiYWNrZ3JvdW5kRmV0Y2giLCJrIiwiaW5kZXgiLCJvcHRpb25zIiwiY29udGV4dCIsIm1vdmVUb1RhaWwiLCJpbmRleGVzIiwicmluZGV4ZXMiLCJpc1N0YWxlIiwidXBkYXRlSXRlbUFnZSIsInN0YXR1c1RUTCIsInNldEl0ZW1UVEwiLCJyZW1vdmVJdGVtU2l6ZSIsIl9pIiwiYWRkSXRlbVNpemUiLCJfcyIsIl9zdCIsInJlcXVpcmVTaXplIiwiX2siLCJfdiIsInNpemVDYWxjdWxhdGlvbiIsInR0bCIsInR0bFJlc29sdXRpb24iLCJ0dGxBdXRvcHVyZ2UiLCJ1cGRhdGVBZ2VPbkdldCIsInVwZGF0ZUFnZU9uSGFzIiwiYWxsb3dTdGFsZSIsIm5vRGlzcG9zZU9uU2V0Iiwibm9VcGRhdGVUVEwiLCJtYXhFbnRyeVNpemUiLCJub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24iLCJub0RlbGV0ZU9uU3RhbGVHZXQiLCJhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiIsImFsbG93U3RhbGVPbkZldGNoQWJvcnQiLCJpZ25vcmVGZXRjaEFib3J0IiwiVWludEFycmF5IiwiRXJyb3IiLCJ1bmRlZmluZWQiLCJNYXAiLCJpbml0aWFsaXplU2l6ZVRyYWNraW5nIiwiaW5pdGlhbGl6ZVRUTFRyYWNraW5nIiwiYWRkIiwiZ2V0UmVtYWluaW5nVFRMIiwia2V5IiwiSW5maW5pdHkiLCJzdGFydCIsInQiLCJzZXRUaW1lb3V0IiwiZGVsZXRlIiwidW5yZWYiLCJzdGF0dXMiLCJjYWNoZWROb3ciLCJnZXROb3ciLCJhZ2UiLCJyZW1haW5pbmdUVEwiLCJnZXQiLCJ2IiwiZXZpY3QiLCJlbnRyeVNpemUiLCJ0b3RhbENhbGN1bGF0ZWRTaXplIiwiaSIsImlzVmFsaWRJbmRleCIsImVudHJpZXMiLCJyZW50cmllcyIsImtleXMiLCJya2V5cyIsInZhbHVlcyIsInJ2YWx1ZXMiLCJpdGVyYXRvciIsImZpbmQiLCJnZXRPcHRpb25zIiwiX19zdGFsZVdoaWxlRmV0Y2hpbmciLCJmb3JFYWNoIiwidGhpc3AiLCJjYWxsIiwicmZvckVhY2giLCJwdXJnZVN0YWxlIiwiZGVsZXRlZCIsImluZm8iLCJlbnRyeSIsInJlbWFpbiIsImR1bXAiLCJhcnIiLCJ1bnNoaWZ0IiwibG9hZCIsImNsZWFyIiwic2V0Iiwic2V0T3B0aW9ucyIsIm1heEVudHJ5U2l6ZUV4Y2VlZGVkIiwib2xkVmFsIiwiX19hYm9ydENvbnRyb2xsZXIiLCJvbGRWYWx1ZSIsImR0IiwidGFzayIsInNoaWZ0IiwidmFsIiwiaGFzT3B0aW9ucyIsInBlZWsiLCJwZWVrT3B0aW9ucyIsImFjIiwiZmV0Y2hPcHRzIiwiY2IiLCJ1cGRhdGVDYWNoZSIsImlnbm9yZUFib3J0IiwiZmV0Y2hBYm9ydGVkIiwiZmV0Y2hFcnJvciIsImZldGNoQWJvcnRJZ25vcmVkIiwiZmV0Y2hSZXNvbHZlZCIsImZldGNoRmFpbCIsImJmIiwiZmV0Y2hVcGRhdGVkIiwiZWIiLCJlciIsImZldGNoUmVqZWN0ZWQiLCJhbGxvd1N0YWxlQWJvcnRlZCIsIm5vRGVsZXRlIiwiZGVsIiwicmV0dXJuZWRTdGFsZSIsIl9fcmV0dXJuZWQiLCJwY2FsbCIsInJlcyIsInJlaiIsImZtcCIsIlByb21pc2UiLCJ0aGVuIiwiZmV0Y2hEaXNwYXRjaGVkIiwiYXNzaWduIiwiYiIsImhhc093blByb3BlcnR5IiwiZmV0Y2giLCJmZXRjaE9wdGlvbnMiLCJmb3JjZVJlZnJlc2giLCJzdGFsZSIsImhhc1N0YWxlIiwic3RhbGVWYWwiLCJmZXRjaGluZyIsImNvbm5lY3QiLCJwaSIsIm5pIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/lru-cache/dist/commonjs/index.js\n");

/***/ })

};
;