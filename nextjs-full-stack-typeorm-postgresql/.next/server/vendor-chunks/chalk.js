"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chalk";
exports.ids = ["vendor-chunks/chalk"];
exports.modules = {

/***/ "(rsc)/./node_modules/chalk/source/index.js":
/*!********************************************!*\
  !*** ./node_modules/chalk/source/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst ansiStyles = __webpack_require__(/*! ansi-styles */ \"(rsc)/./node_modules/ansi-styles/index.js\");\nconst { stdout: stdoutColor, stderr: stderrColor } = __webpack_require__(/*! supports-color */ \"(rsc)/./node_modules/supports-color/index.js\");\nconst { stringReplaceAll, stringEncaseCRLFWithFirstIndex } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/chalk/source/util.js\");\nconst { isArray } = Array;\n// `supportsColor.level` â†’ `ansiStyles.color[name]` mapping\nconst levelMapping = [\n    \"ansi\",\n    \"ansi\",\n    \"ansi256\",\n    \"ansi16m\"\n];\nconst styles = Object.create(null);\nconst applyOptions = (object, options = {})=>{\n    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {\n        throw new Error(\"The `level` option should be an integer from 0 to 3\");\n    }\n    // Detect level if not set manually\n    const colorLevel = stdoutColor ? stdoutColor.level : 0;\n    object.level = options.level === undefined ? colorLevel : options.level;\n};\nclass ChalkClass {\n    constructor(options){\n        // eslint-disable-next-line no-constructor-return\n        return chalkFactory(options);\n    }\n}\nconst chalkFactory = (options)=>{\n    const chalk = {};\n    applyOptions(chalk, options);\n    chalk.template = (...arguments_)=>chalkTag(chalk.template, ...arguments_);\n    Object.setPrototypeOf(chalk, Chalk.prototype);\n    Object.setPrototypeOf(chalk.template, chalk);\n    chalk.template.constructor = ()=>{\n        throw new Error(\"`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.\");\n    };\n    chalk.template.Instance = ChalkClass;\n    return chalk.template;\n};\nfunction Chalk(options) {\n    return chalkFactory(options);\n}\nfor (const [styleName, style] of Object.entries(ansiStyles)){\n    styles[styleName] = {\n        get () {\n            const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);\n            Object.defineProperty(this, styleName, {\n                value: builder\n            });\n            return builder;\n        }\n    };\n}\nstyles.visible = {\n    get () {\n        const builder = createBuilder(this, this._styler, true);\n        Object.defineProperty(this, \"visible\", {\n            value: builder\n        });\n        return builder;\n    }\n};\nconst usedModels = [\n    \"rgb\",\n    \"hex\",\n    \"keyword\",\n    \"hsl\",\n    \"hsv\",\n    \"hwb\",\n    \"ansi\",\n    \"ansi256\"\n];\nfor (const model of usedModels){\n    styles[model] = {\n        get () {\n            const { level } = this;\n            return function(...arguments_) {\n                const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);\n                return createBuilder(this, styler, this._isEmpty);\n            };\n        }\n    };\n}\nfor (const model of usedModels){\n    const bgModel = \"bg\" + model[0].toUpperCase() + model.slice(1);\n    styles[bgModel] = {\n        get () {\n            const { level } = this;\n            return function(...arguments_) {\n                const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);\n                return createBuilder(this, styler, this._isEmpty);\n            };\n        }\n    };\n}\nconst proto = Object.defineProperties(()=>{}, {\n    ...styles,\n    level: {\n        enumerable: true,\n        get () {\n            return this._generator.level;\n        },\n        set (level) {\n            this._generator.level = level;\n        }\n    }\n});\nconst createStyler = (open, close, parent)=>{\n    let openAll;\n    let closeAll;\n    if (parent === undefined) {\n        openAll = open;\n        closeAll = close;\n    } else {\n        openAll = parent.openAll + open;\n        closeAll = close + parent.closeAll;\n    }\n    return {\n        open,\n        close,\n        openAll,\n        closeAll,\n        parent\n    };\n};\nconst createBuilder = (self, _styler, _isEmpty)=>{\n    const builder = (...arguments_)=>{\n        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {\n            // Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`\n            return applyStyle(builder, chalkTag(builder, ...arguments_));\n        }\n        // Single argument is hot path, implicit coercion is faster than anything\n        // eslint-disable-next-line no-implicit-coercion\n        return applyStyle(builder, arguments_.length === 1 ? \"\" + arguments_[0] : arguments_.join(\" \"));\n    };\n    // We alter the prototype because we must return a function, but there is\n    // no way to create a function with a different prototype\n    Object.setPrototypeOf(builder, proto);\n    builder._generator = self;\n    builder._styler = _styler;\n    builder._isEmpty = _isEmpty;\n    return builder;\n};\nconst applyStyle = (self, string)=>{\n    if (self.level <= 0 || !string) {\n        return self._isEmpty ? \"\" : string;\n    }\n    let styler = self._styler;\n    if (styler === undefined) {\n        return string;\n    }\n    const { openAll, closeAll } = styler;\n    if (string.indexOf(\"\\x1b\") !== -1) {\n        while(styler !== undefined){\n            // Replace any instances already present with a re-opening code\n            // otherwise only the part of the string until said closing code\n            // will be colored, and the rest will simply be 'plain'.\n            string = stringReplaceAll(string, styler.close, styler.open);\n            styler = styler.parent;\n        }\n    }\n    // We can move both next actions out of loop, because remaining actions in loop won't have\n    // any/visible effect on parts we add here. Close the styling before a linebreak and reopen\n    // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92\n    const lfIndex = string.indexOf(\"\\n\");\n    if (lfIndex !== -1) {\n        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);\n    }\n    return openAll + string + closeAll;\n};\nlet template;\nconst chalkTag = (chalk, ...strings)=>{\n    const [firstString] = strings;\n    if (!isArray(firstString) || !isArray(firstString.raw)) {\n        // If chalk() was called by itself or with a string,\n        // return the string itself as a string.\n        return strings.join(\" \");\n    }\n    const arguments_ = strings.slice(1);\n    const parts = [\n        firstString.raw[0]\n    ];\n    for(let i = 1; i < firstString.length; i++){\n        parts.push(String(arguments_[i - 1]).replace(/[{}\\\\]/g, \"\\\\$&\"), String(firstString.raw[i]));\n    }\n    if (template === undefined) {\n        template = __webpack_require__(/*! ./templates */ \"(rsc)/./node_modules/chalk/source/templates.js\");\n    }\n    return template(chalk, parts.join(\"\"));\n};\nObject.defineProperties(Chalk.prototype, styles);\nconst chalk = Chalk(); // eslint-disable-line new-cap\nchalk.supportsColor = stdoutColor;\nchalk.stderr = Chalk({\n    level: stderrColor ? stderrColor.level : 0\n}); // eslint-disable-line new-cap\nchalk.stderr.supportsColor = stderrColor;\nmodule.exports = chalk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hhbGsvc291cmNlL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsTUFBTUEsYUFBYUMsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFDQyxRQUFRQyxXQUFXLEVBQUVDLFFBQVFDLFdBQVcsRUFBQyxHQUFHSixtQkFBT0EsQ0FBQztBQUMzRCxNQUFNLEVBQ0xLLGdCQUFnQixFQUNoQkMsOEJBQThCLEVBQzlCLEdBQUdOLG1CQUFPQSxDQUFDO0FBRVosTUFBTSxFQUFDTyxPQUFPLEVBQUMsR0FBR0M7QUFFbEIsMkRBQTJEO0FBQzNELE1BQU1DLGVBQWU7SUFDcEI7SUFDQTtJQUNBO0lBQ0E7Q0FDQTtBQUVELE1BQU1DLFNBQVNDLE9BQU9DLE1BQU0sQ0FBQztBQUU3QixNQUFNQyxlQUFlLENBQUNDLFFBQVFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3pDLElBQUlBLFFBQVFDLEtBQUssSUFBSSxDQUFFQyxDQUFBQSxPQUFPQyxTQUFTLENBQUNILFFBQVFDLEtBQUssS0FBS0QsUUFBUUMsS0FBSyxJQUFJLEtBQUtELFFBQVFDLEtBQUssSUFBSSxJQUFJO1FBQ3BHLE1BQU0sSUFBSUcsTUFBTTtJQUNqQjtJQUVBLG1DQUFtQztJQUNuQyxNQUFNQyxhQUFhbEIsY0FBY0EsWUFBWWMsS0FBSyxHQUFHO0lBQ3JERixPQUFPRSxLQUFLLEdBQUdELFFBQVFDLEtBQUssS0FBS0ssWUFBWUQsYUFBYUwsUUFBUUMsS0FBSztBQUN4RTtBQUVBLE1BQU1NO0lBQ0xDLFlBQVlSLE9BQU8sQ0FBRTtRQUNwQixpREFBaUQ7UUFDakQsT0FBT1MsYUFBYVQ7SUFDckI7QUFDRDtBQUVBLE1BQU1TLGVBQWVULENBQUFBO0lBQ3BCLE1BQU1VLFFBQVEsQ0FBQztJQUNmWixhQUFhWSxPQUFPVjtJQUVwQlUsTUFBTUMsUUFBUSxHQUFHLENBQUMsR0FBR0MsYUFBZUMsU0FBU0gsTUFBTUMsUUFBUSxLQUFLQztJQUVoRWhCLE9BQU9rQixjQUFjLENBQUNK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T0FBTzZDLGdCQUFnQixDQUFDMUIsTUFBTUMsU0FBUyxFQUFFckI7QUFFekMsTUFBTWUsUUFBUUssU0FBUyw4QkFBOEI7QUFDckRMLE1BQU1xRCxhQUFhLEdBQUc1RTtBQUN0QnVCLE1BQU10QixNQUFNLEdBQUcyQixNQUFNO0lBQUNkLE9BQU9aLGNBQWNBLFlBQVlZLEtBQUssR0FBRztBQUFDLElBQUksOEJBQThCO0FBQ2xHUyxNQUFNdEIsTUFBTSxDQUFDMkUsYUFBYSxHQUFHMUU7QUFFN0IyRSxPQUFPQyxPQUFPLEdBQUd2RCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9jaGFsay9zb3VyY2UvaW5kZXguanM/YWQ1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBhbnNpU3R5bGVzID0gcmVxdWlyZSgnYW5zaS1zdHlsZXMnKTtcbmNvbnN0IHtzdGRvdXQ6IHN0ZG91dENvbG9yLCBzdGRlcnI6IHN0ZGVyckNvbG9yfSA9IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XG5jb25zdCB7XG5cdHN0cmluZ1JlcGxhY2VBbGwsXG5cdHN0cmluZ0VuY2FzZUNSTEZXaXRoRmlyc3RJbmRleFxufSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5jb25zdCB7aXNBcnJheX0gPSBBcnJheTtcblxuLy8gYHN1cHBvcnRzQ29sb3IubGV2ZWxgIOKGkiBgYW5zaVN0eWxlcy5jb2xvcltuYW1lXWAgbWFwcGluZ1xuY29uc3QgbGV2ZWxNYXBwaW5nID0gW1xuXHQnYW5zaScsXG5cdCdhbnNpJyxcblx0J2Fuc2kyNTYnLFxuXHQnYW5zaTE2bSdcbl07XG5cbmNvbnN0IHN0eWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmNvbnN0IGFwcGx5T3B0aW9ucyA9IChvYmplY3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRpZiAob3B0aW9ucy5sZXZlbCAmJiAhKE51bWJlci5pc0ludGVnZXIob3B0aW9ucy5sZXZlbCkgJiYgb3B0aW9ucy5sZXZlbCA+PSAwICYmIG9wdGlvbnMubGV2ZWwgPD0gMykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgbGV2ZWxgIG9wdGlvbiBzaG91bGQgYmUgYW4gaW50ZWdlciBmcm9tIDAgdG8gMycpO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IGxldmVsIGlmIG5vdCBzZXQgbWFudWFsbHlcblx0Y29uc3QgY29sb3JMZXZlbCA9IHN0ZG91dENvbG9yID8gc3Rkb3V0Q29sb3IubGV2ZWwgOiAwO1xuXHRvYmplY3QubGV2ZWwgPSBvcHRpb25zLmxldmVsID09PSB1bmRlZmluZWQgPyBjb2xvckxldmVsIDogb3B0aW9ucy5sZXZlbDtcbn07XG5cbmNsYXNzIENoYWxrQ2xhc3Mge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuXHRcdHJldHVybiBjaGFsa0ZhY3Rvcnkob3B0aW9ucyk7XG5cdH1cbn1cblxuY29uc3QgY2hhbGtGYWN0b3J5ID0gb3B0aW9ucyA9PiB7XG5cdGNvbnN0IGNoYWxrID0ge307XG5cdGFwcGx5T3B0aW9ucyhjaGFsaywgb3B0aW9ucyk7XG5cblx0Y2hhbGsudGVtcGxhdGUgPSAoLi4uYXJndW1lbnRzXykgPT4gY2hhbGtUYWcoY2hhbGsudGVtcGxhdGUsIC4uLmFyZ3VtZW50c18pO1xuXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihjaGFsaywgQ2hhbGsucHJvdG90eXBlKTtcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKGNoYWxrLnRlbXBsYXRlLCBjaGFsayk7XG5cblx0Y2hhbGsudGVtcGxhdGUuY29uc3RydWN0b3IgPSAoKSA9PiB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdgY2hhbGsuY29uc3RydWN0b3IoKWAgaXMgZGVwcmVjYXRlZC4gVXNlIGBuZXcgY2hhbGsuSW5zdGFuY2UoKWAgaW5zdGVhZC4nKTtcblx0fTtcblxuXHRjaGFsay50ZW1wbGF0ZS5JbnN0YW5jZSA9IENoYWxrQ2xhc3M7XG5cblx0cmV0dXJuIGNoYWxrLnRlbXBsYXRlO1xufTtcblxuZnVuY3Rpb24gQ2hhbGsob3B0aW9ucykge1xuXHRyZXR1cm4gY2hhbGtGYWN0b3J5KG9wdGlvbnMpO1xufVxuXG5mb3IgKGNvbnN0IFtzdHlsZU5hbWUsIHN0eWxlXSBvZiBPYmplY3QuZW50cmllcyhhbnNpU3R5bGVzKSkge1xuXHRzdHlsZXNbc3R5bGVOYW1lXSA9IHtcblx0XHRnZXQoKSB7XG5cdFx0XHRjb25zdCBidWlsZGVyID0gY3JlYXRlQnVpbGRlcih0aGlzLCBjcmVhdGVTdHlsZXIoc3R5bGUub3Blbiwgc3R5bGUuY2xvc2UsIHRoaXMuX3N0eWxlciksIHRoaXMuX2lzRW1wdHkpO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHN0eWxlTmFtZSwge3ZhbHVlOiBidWlsZGVyfSk7XG5cdFx0XHRyZXR1cm4gYnVpbGRlcjtcblx0XHR9XG5cdH07XG59XG5cbnN0eWxlcy52aXNpYmxlID0ge1xuXHRnZXQoKSB7XG5cdFx0Y29uc3QgYnVpbGRlciA9IGNyZWF0ZUJ1aWxkZXIodGhpcywgdGhpcy5fc3R5bGVyLCB0cnVlKTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Zpc2libGUnLCB7dmFsdWU6IGJ1aWxkZXJ9KTtcblx0XHRyZXR1cm4gYnVpbGRlcjtcblx0fVxufTtcblxuY29uc3QgdXNlZE1vZGVscyA9IFsncmdiJywgJ2hleCcsICdrZXl3b3JkJywgJ2hzbCcsICdoc3YnLCAnaHdiJywgJ2Fuc2knLCAnYW5zaTI1NiddO1xuXG5mb3IgKGNvbnN0IG1vZGVsIG9mIHVzZWRNb2RlbHMpIHtcblx0c3R5bGVzW21vZGVsXSA9IHtcblx0XHRnZXQoKSB7XG5cdFx0XHRjb25zdCB7bGV2ZWx9ID0gdGhpcztcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoLi4uYXJndW1lbnRzXykge1xuXHRcdFx0XHRjb25zdCBzdHlsZXIgPSBjcmVhdGVTdHlsZXIoYW5zaVN0eWxlcy5jb2xvcltsZXZlbE1hcHBpbmdbbGV2ZWxdXVttb2RlbF0oLi4uYXJndW1lbnRzXyksIGFuc2lTdHlsZXMuY29sb3IuY2xvc2UsIHRoaXMuX3N0eWxlcik7XG5cdFx0XHRcdHJldHVybiBjcmVhdGVCdWlsZGVyKHRoaXMsIHN0eWxlciwgdGhpcy5faXNFbXB0eSk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcbn1cblxuZm9yIChjb25zdCBtb2RlbCBvZiB1c2VkTW9kZWxzKSB7XG5cdGNvbnN0IGJnTW9kZWwgPSAnYmcnICsgbW9kZWxbMF0udG9VcHBlckNhc2UoKSArIG1vZGVsLnNsaWNlKDEpO1xuXHRzdHlsZXNbYmdNb2RlbF0gPSB7XG5cdFx0Z2V0KCkge1xuXHRcdFx0Y29uc3Qge2xldmVsfSA9IHRoaXM7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3VtZW50c18pIHtcblx0XHRcdFx0Y29uc3Qgc3R5bGVyID0gY3JlYXRlU3R5bGVyKGFuc2lTdHlsZXMuYmdDb2xvcltsZXZlbE1hcHBpbmdbbGV2ZWxdXVttb2RlbF0oLi4uYXJndW1lbnRzXyksIGFuc2lTdHlsZXMuYmdDb2xvci5jbG9zZSwgdGhpcy5fc3R5bGVyKTtcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZUJ1aWxkZXIodGhpcywgc3R5bGVyLCB0aGlzLl9pc0VtcHR5KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xufVxuXG5jb25zdCBwcm90byA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCgpID0+IHt9LCB7XG5cdC4uLnN0eWxlcyxcblx0bGV2ZWw6IHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9nZW5lcmF0b3IubGV2ZWw7XG5cdFx0fSxcblx0XHRzZXQobGV2ZWwpIHtcblx0XHRcdHRoaXMuX2dlbmVyYXRvci5sZXZlbCA9IGxldmVsO1xuXHRcdH1cblx0fVxufSk7XG5cbmNvbnN0IGNyZWF0ZVN0eWxlciA9IChvcGVuLCBjbG9zZSwgcGFyZW50KSA9PiB7XG5cdGxldCBvcGVuQWxsO1xuXHRsZXQgY2xvc2VBbGw7XG5cdGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wZW5BbGwgPSBvcGVuO1xuXHRcdGNsb3NlQWxsID0gY2xvc2U7XG5cdH0gZWxzZSB7XG5cdFx0b3BlbkFsbCA9IHBhcmVudC5vcGVuQWxsICsgb3Blbjtcblx0XHRjbG9zZUFsbCA9IGNsb3NlICsgcGFyZW50LmNsb3NlQWxsO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRvcGVuLFxuXHRcdGNsb3NlLFxuXHRcdG9wZW5BbGwsXG5cdFx0Y2xvc2VBbGwsXG5cdFx0cGFyZW50XG5cdH07XG59O1xuXG5jb25zdCBjcmVhdGVCdWlsZGVyID0gKHNlbGYsIF9zdHlsZXIsIF9pc0VtcHR5KSA9PiB7XG5cdGNvbnN0IGJ1aWxkZXIgPSAoLi4uYXJndW1lbnRzXykgPT4ge1xuXHRcdGlmIChpc0FycmF5KGFyZ3VtZW50c19bMF0pICYmIGlzQXJyYXkoYXJndW1lbnRzX1swXS5yYXcpKSB7XG5cdFx0XHQvLyBDYWxsZWQgYXMgYSB0ZW1wbGF0ZSBsaXRlcmFsLCBmb3IgZXhhbXBsZTogY2hhbGsucmVkYDIgKyAzID0ge2JvbGQgJHsyKzN9fWBcblx0XHRcdHJldHVybiBhcHBseVN0eWxlKGJ1aWxkZXIsIGNoYWxrVGFnKGJ1aWxkZXIsIC4uLmFyZ3VtZW50c18pKTtcblx0XHR9XG5cblx0XHQvLyBTaW5nbGUgYXJndW1lbnQgaXMgaG90IHBhdGgsIGltcGxpY2l0IGNvZXJjaW9uIGlzIGZhc3RlciB0aGFuIGFueXRoaW5nXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uXG5cdFx0cmV0dXJuIGFwcGx5U3R5bGUoYnVpbGRlciwgKGFyZ3VtZW50c18ubGVuZ3RoID09PSAxKSA/ICgnJyArIGFyZ3VtZW50c19bMF0pIDogYXJndW1lbnRzXy5qb2luKCcgJykpO1xuXHR9O1xuXG5cdC8vIFdlIGFsdGVyIHRoZSBwcm90b3R5cGUgYmVjYXVzZSB3ZSBtdXN0IHJldHVybiBhIGZ1bmN0aW9uLCBidXQgdGhlcmUgaXNcblx0Ly8gbm8gd2F5IHRvIGNyZWF0ZSBhIGZ1bmN0aW9uIHdpdGggYSBkaWZmZXJlbnQgcHJvdG90eXBlXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihidWlsZGVyLCBwcm90byk7XG5cblx0YnVpbGRlci5fZ2VuZXJhdG9yID0gc2VsZjtcblx0YnVpbGRlci5fc3R5bGVyID0gX3N0eWxlcjtcblx0YnVpbGRlci5faXNFbXB0eSA9IF9pc0VtcHR5O1xuXG5cdHJldHVybiBidWlsZGVyO1xufTtcblxuY29uc3QgYXBwbHlTdHlsZSA9IChzZWxmLCBzdHJpbmcpID0+IHtcblx0aWYgKHNlbGYubGV2ZWwgPD0gMCB8fCAhc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHNlbGYuX2lzRW1wdHkgPyAnJyA6IHN0cmluZztcblx0fVxuXG5cdGxldCBzdHlsZXIgPSBzZWxmLl9zdHlsZXI7XG5cblx0aWYgKHN0eWxlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIHN0cmluZztcblx0fVxuXG5cdGNvbnN0IHtvcGVuQWxsLCBjbG9zZUFsbH0gPSBzdHlsZXI7XG5cdGlmIChzdHJpbmcuaW5kZXhPZignXFx1MDAxQicpICE9PSAtMSkge1xuXHRcdHdoaWxlIChzdHlsZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gUmVwbGFjZSBhbnkgaW5zdGFuY2VzIGFscmVhZHkgcHJlc2VudCB3aXRoIGEgcmUtb3BlbmluZyBjb2RlXG5cdFx0XHQvLyBvdGhlcndpc2Ugb25seSB0aGUgcGFydCBvZiB0aGUgc3RyaW5nIHVudGlsIHNhaWQgY2xvc2luZyBjb2RlXG5cdFx0XHQvLyB3aWxsIGJlIGNvbG9yZWQsIGFuZCB0aGUgcmVzdCB3aWxsIHNpbXBseSBiZSAncGxhaW4nLlxuXHRcdFx0c3RyaW5nID0gc3RyaW5nUmVwbGFjZUFsbChzdHJpbmcsIHN0eWxlci5jbG9zZSwgc3R5bGVyLm9wZW4pO1xuXG5cdFx0XHRzdHlsZXIgPSBzdHlsZXIucGFyZW50O1xuXHRcdH1cblx0fVxuXG5cdC8vIFdlIGNhbiBtb3ZlIGJvdGggbmV4dCBhY3Rpb25zIG91dCBvZiBsb29wLCBiZWNhdXNlIHJlbWFpbmluZyBhY3Rpb25zIGluIGxvb3Agd29uJ3QgaGF2ZVxuXHQvLyBhbnkvdmlzaWJsZSBlZmZlY3Qgb24gcGFydHMgd2UgYWRkIGhlcmUuIENsb3NlIHRoZSBzdHlsaW5nIGJlZm9yZSBhIGxpbmVicmVhayBhbmQgcmVvcGVuXG5cdC8vIGFmdGVyIG5leHQgbGluZSB0byBmaXggYSBibGVlZCBpc3N1ZSBvbiBtYWNPUzogaHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2NoYWxrL3B1bGwvOTJcblx0Y29uc3QgbGZJbmRleCA9IHN0cmluZy5pbmRleE9mKCdcXG4nKTtcblx0aWYgKGxmSW5kZXggIT09IC0xKSB7XG5cdFx0c3RyaW5nID0gc3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4KHN0cmluZywgY2xvc2VBbGwsIG9wZW5BbGwsIGxmSW5kZXgpO1xuXHR9XG5cblx0cmV0dXJuIG9wZW5BbGwgKyBzdHJpbmcgKyBjbG9zZUFsbDtcbn07XG5cbmxldCB0ZW1wbGF0ZTtcbmNvbnN0IGNoYWxrVGFnID0gKGNoYWxrLCAuLi5zdHJpbmdzKSA9PiB7XG5cdGNvbnN0IFtmaXJzdFN0cmluZ10gPSBzdHJpbmdzO1xuXG5cdGlmICghaXNBcnJheShmaXJzdFN0cmluZykgfHwgIWlzQXJyYXkoZmlyc3RTdHJpbmcucmF3KSkge1xuXHRcdC8vIElmIGNoYWxrKCkgd2FzIGNhbGxlZCBieSBpdHNlbGYgb3Igd2l0aCBhIHN0cmluZyxcblx0XHQvLyByZXR1cm4gdGhlIHN0cmluZyBpdHNlbGYgYXMgYSBzdHJpbmcuXG5cdFx0cmV0dXJuIHN0cmluZ3Muam9pbignICcpO1xuXHR9XG5cblx0Y29uc3QgYXJndW1lbnRzXyA9IHN0cmluZ3Muc2xpY2UoMSk7XG5cdGNvbnN0IHBhcnRzID0gW2ZpcnN0U3RyaW5nLnJhd1swXV07XG5cblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBmaXJzdFN0cmluZy5sZW5ndGg7IGkrKykge1xuXHRcdHBhcnRzLnB1c2goXG5cdFx0XHRTdHJpbmcoYXJndW1lbnRzX1tpIC0gMV0pLnJlcGxhY2UoL1t7fVxcXFxdL2csICdcXFxcJCYnKSxcblx0XHRcdFN0cmluZyhmaXJzdFN0cmluZy5yYXdbaV0pXG5cdFx0KTtcblx0fVxuXG5cdGlmICh0ZW1wbGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlcycpO1xuXHR9XG5cblx0cmV0dXJuIHRlbXBsYXRlKGNoYWxrLCBwYXJ0cy5qb2luKCcnKSk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGFsay5wcm90b3R5cGUsIHN0eWxlcyk7XG5cbmNvbnN0IGNoYWxrID0gQ2hhbGsoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG5jaGFsay5zdXBwb3J0c0NvbG9yID0gc3Rkb3V0Q29sb3I7XG5jaGFsay5zdGRlcnIgPSBDaGFsayh7bGV2ZWw6IHN0ZGVyckNvbG9yID8gc3RkZXJyQ29sb3IubGV2ZWwgOiAwfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuY2hhbGsuc3RkZXJyLnN1cHBvcnRzQ29sb3IgPSBzdGRlcnJDb2xvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBjaGFsaztcbiJdLCJuYW1lcyI6WyJhbnNpU3R5bGVzIiwicmVxdWlyZSIsInN0ZG91dCIsInN0ZG91dENvbG9yIiwic3RkZXJyIiwic3RkZXJyQ29sb3IiLCJzdHJpbmdSZXBsYWNlQWxsIiwic3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4IiwiaXNBcnJheSIsIkFycmF5IiwibGV2ZWxNYXBwaW5nIiwic3R5bGVzIiwiT2JqZWN0IiwiY3JlYXRlIiwiYXBwbHlPcHRpb25zIiwib2JqZWN0Iiwib3B0aW9ucyIsImxldmVsIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiRXJyb3IiLCJjb2xvckxldmVsIiwidW5kZWZpbmVkIiwiQ2hhbGtDbGFzcyIsImNvbnN0cnVjdG9yIiwiY2hhbGtGYWN0b3J5IiwiY2hhbGsiLCJ0ZW1wbGF0ZSIsImFyZ3VtZW50c18iLCJjaGFsa1RhZyIsInNldFByb3RvdHlwZU9mIiwiQ2hhbGsiLCJwcm90b3R5cGUiLCJJbnN0YW5jZSIsInN0eWxlTmFtZSIsInN0eWxlIiwiZW50cmllcyIsImdldCIsImJ1aWxkZXIiLCJjcmVhdGVCdWlsZGVyIiwiY3JlYXRlU3R5bGVyIiwib3BlbiIsImNsb3NlIiwiX3N0eWxlciIsIl9pc0VtcHR5IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsInZpc2libGUiLCJ1c2VkTW9kZWxzIiwibW9kZWwiLCJzdHlsZXIiLCJjb2xvciIsImJnTW9kZWwiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiYmdDb2xvciIsInByb3RvIiwiZGVmaW5lUHJvcGVydGllcyIsImVudW1lcmFibGUiLCJfZ2VuZXJhdG9yIiwic2V0IiwicGFyZW50Iiwib3BlbkFsbCIsImNsb3NlQWxsIiwic2VsZiIsInJhdyIsImFwcGx5U3R5bGUiLCJsZW5ndGgiLCJqb2luIiwic3RyaW5nIiwiaW5kZXhPZiIsImxmSW5kZXgiLCJzdHJpbmdzIiwiZmlyc3RTdHJpbmciLCJwYXJ0cyIsImkiLCJwdXNoIiwiU3RyaW5nIiwicmVwbGFjZSIsInN1cHBvcnRzQ29sb3IiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/chalk/source/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/chalk/source/templates.js":
/*!************************************************!*\
  !*** ./node_modules/chalk/source/templates.js ***!
  \************************************************/
/***/ ((module) => {

eval("\nconst TEMPLATE_REGEX = /(?:\\\\(u(?:[a-f\\d]{4}|\\{[a-f\\d]{1,6}\\})|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\nconst STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\nconst STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\nconst ESCAPE_REGEX = /\\\\(u(?:[a-f\\d]{4}|{[a-f\\d]{1,6}})|x[a-f\\d]{2}|.)|([^\\\\])/gi;\nconst ESCAPES = new Map([\n    [\n        \"n\",\n        \"\\n\"\n    ],\n    [\n        \"r\",\n        \"\\r\"\n    ],\n    [\n        \"t\",\n        \"\t\"\n    ],\n    [\n        \"b\",\n        \"\\b\"\n    ],\n    [\n        \"f\",\n        \"\\f\"\n    ],\n    [\n        \"v\",\n        \"\\v\"\n    ],\n    [\n        \"0\",\n        \"\\x00\"\n    ],\n    [\n        \"\\\\\",\n        \"\\\\\"\n    ],\n    [\n        \"e\",\n        \"\\x1b\"\n    ],\n    [\n        \"a\",\n        \"\\x07\"\n    ]\n]);\nfunction unescape(c) {\n    const u = c[0] === \"u\";\n    const bracket = c[1] === \"{\";\n    if (u && !bracket && c.length === 5 || c[0] === \"x\" && c.length === 3) {\n        return String.fromCharCode(parseInt(c.slice(1), 16));\n    }\n    if (u && bracket) {\n        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));\n    }\n    return ESCAPES.get(c) || c;\n}\nfunction parseArguments(name, arguments_) {\n    const results = [];\n    const chunks = arguments_.trim().split(/\\s*,\\s*/g);\n    let matches;\n    for (const chunk of chunks){\n        const number = Number(chunk);\n        if (!Number.isNaN(number)) {\n            results.push(number);\n        } else if (matches = chunk.match(STRING_REGEX)) {\n            results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character)=>escape ? unescape(escape) : character));\n        } else {\n            throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n        }\n    }\n    return results;\n}\nfunction parseStyle(style) {\n    STYLE_REGEX.lastIndex = 0;\n    const results = [];\n    let matches;\n    while((matches = STYLE_REGEX.exec(style)) !== null){\n        const name = matches[1];\n        if (matches[2]) {\n            const args = parseArguments(name, matches[2]);\n            results.push([\n                name\n            ].concat(args));\n        } else {\n            results.push([\n                name\n            ]);\n        }\n    }\n    return results;\n}\nfunction buildStyle(chalk, styles) {\n    const enabled = {};\n    for (const layer of styles){\n        for (const style of layer.styles){\n            enabled[style[0]] = layer.inverse ? null : style.slice(1);\n        }\n    }\n    let current = chalk;\n    for (const [styleName, styles] of Object.entries(enabled)){\n        if (!Array.isArray(styles)) {\n            continue;\n        }\n        if (!(styleName in current)) {\n            throw new Error(`Unknown Chalk style: ${styleName}`);\n        }\n        current = styles.length > 0 ? current[styleName](...styles) : current[styleName];\n    }\n    return current;\n}\nmodule.exports = (chalk, temporary)=>{\n    const styles = [];\n    const chunks = [];\n    let chunk = [];\n    // eslint-disable-next-line max-params\n    temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character)=>{\n        if (escapeCharacter) {\n            chunk.push(unescape(escapeCharacter));\n        } else if (style) {\n            const string = chunk.join(\"\");\n            chunk = [];\n            chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));\n            styles.push({\n                inverse,\n                styles: parseStyle(style)\n            });\n        } else if (close) {\n            if (styles.length === 0) {\n                throw new Error(\"Found extraneous } in Chalk template literal\");\n            }\n            chunks.push(buildStyle(chalk, styles)(chunk.join(\"\")));\n            chunk = [];\n            styles.pop();\n        } else {\n            chunk.push(character);\n        }\n    });\n    chunks.push(chunk.join(\"\"));\n    if (styles.length > 0) {\n        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? \"\" : \"s\"} (\\`}\\`)`;\n        throw new Error(errMessage);\n    }\n    return chunks.join(\"\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hhbGsvc291cmNlL3RlbXBsYXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU1BLGlCQUFpQjtBQUN2QixNQUFNQyxjQUFjO0FBQ3BCLE1BQU1DLGVBQWU7QUFDckIsTUFBTUMsZUFBZTtBQUVyQixNQUFNQyxVQUFVLElBQUlDLElBQUk7SUFDdkI7UUFBQztRQUFLO0tBQUs7SUFDWDtRQUFDO1FBQUs7S0FBSztJQUNYO1FBQUM7UUFBSztLQUFLO0lBQ1g7UUFBQztRQUFLO0tBQUs7SUFDWDtRQUFDO1FBQUs7S0FBSztJQUNYO1FBQUM7UUFBSztLQUFLO0lBQ1g7UUFBQztRQUFLO0tBQUs7SUFDWDtRQUFDO1FBQU07S0FBSztJQUNaO1FBQUM7UUFBSztLQUFTO0lBQ2Y7UUFBQztRQUFLO0tBQVM7Q0FDZjtBQUVELFNBQVNDLFNBQVNDLENBQUM7SUFDbEIsTUFBTUMsSUFBSUQsQ0FBQyxDQUFDLEVBQUUsS0FBSztJQUNuQixNQUFNRSxVQUFVRixDQUFDLENBQUMsRUFBRSxLQUFLO0lBRXpCLElBQUksS0FBTSxDQUFDRSxXQUFXRixFQUFFRyxNQUFNLEtBQUssS0FBT0gsQ0FBQyxDQUFDLEVBQUUsS0FBSyxPQUFPQSxFQUFFRyxNQUFNLEtBQUssR0FBSTtRQUMxRSxPQUFPQyxPQUFPQyxZQUFZLENBQUNDLFNBQVNOLEVBQUVPLEtBQUssQ0FBQyxJQUFJO0lBQ2pEO0lBRUEsSUFBSU4sS0FBS0MsU0FBUztRQUNqQixPQUFPRSxPQUFPSSxhQUFhLENBQUNGLFNBQVNOLEVBQUVPLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSTtJQUN0RDtJQUVBLE9BQU9WLFFBQVFZLEdBQUcsQ0FBQ1QsTUFBTUE7QUFDMUI7QUFFQSxTQUFTVSxlQUFlQyxJQUFJLEVBQUVDLFVBQVU7SUFDdkMsTUFBTUMsVUFBVSxFQUFFO0lBQ2xCLE1BQU1DLFNBQVNGLFdBQVdHLElBQUksR0FBR0MsS0FBSyxDQUFDO0lBQ3ZDLElBQUlDO0lBRUosS0FBSyxNQUFNQyxTQUFTSixPQUFRO1FBQzNCLE1BQU1LLFNBQVNDLE9BQU9GO1FBQ3RCLElBQUksQ0FBQ0UsT0FBT0MsS0FBSyxDQUFDRixTQUFTO1lBQzFCTixRQUFRUyxJQUFJLENBQUNIO1FBQ2QsT0FBTyxJQUFLRixVQUFVQyxNQUFNSyxLQUFLLENBQUM1QixlQUFnQjtZQUNqRGtCLFFBQVFTLElBQUksQ0FBQ0wsT0FBTyxDQUFDLEVBQUUsQ0FBQ08sT0FBTyxDQUFDNUIsY0FBYyxDQUFDNkIsR0FBR0MsUUFBUUMsWUFBY0QsU0FBUzNCLFNBQVMyQixVQUFVQztRQUNyRyxPQUFPO1lBQ04sTUFBTSxJQUFJQyxNQUFNLENBQUMsdUNBQXVDLEVBQUVWLE1BQU0sWUFBWSxFQUFFUCxLQUFLLEVBQUUsQ0FBQztRQUN2RjtJQUNEO0lBRUEsT0FBT0U7QUFDUjtBQUVBLFNBQVNnQixXQUFXQyxLQUFLO0lBQ3hCcEMsWUFBWXFDLFNBQVMsR0FBRztJQUV4QixNQUFNbEIsVUFBVSxFQUFFO0lBQ2xCLElBQUlJO0lBRUosTUFBTyxDQUFDQSxVQUFVdkIsWUFBWXNDLElBQUksQ0FBQ0YsTUFBSyxNQUFPLEtBQU07UUFDcEQsTUFBTW5CLE9BQU9NLE9BQU8sQ0FBQyxFQUFFO1FBRXZCLElBQUlBLE9BQU8sQ0FBQyxFQUFFLEVBQUU7WUFDZixNQUFNZ0IsT0FBT3ZCLGVBQWVDLE1BQU1NLE9BQU8sQ0FBQyxFQUFFO1lBQzVDSixRQUFRUyxJQUFJLENBQUM7Z0JBQUNYO2FBQUssQ0FBQ3VCLE1BQU0sQ0FBQ0Q7UUFDNUIsT0FBTztZQUNOcEIsUUFBUVMsSUFBSSxDQUFDO2dCQUFDWDthQUFLO1FBQ3BCO0lBQ0Q7SUFFQSxPQUFPRTtBQUNSO0FBRUEsU0FBU3NCLFdBQVdDLEtBQUssRUFBRUMsTUFBTTtJQUNoQyxNQUFNQyxVQUFVLENBQUM7SUFFakIsS0FBSyxNQUFNQyxTQUFTRixPQUFRO1FBQzNCLEtBQUssTUFBTVAsU0FBU1MsTUFBTUYsTUFBTSxDQUFFO1lBQ2pDQyxPQUFPLENBQUNSLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBR1MsTUFBTUMsT0FBTyxHQUFHLE9BQU9WLE1BQU12QixLQUFLLENBQUM7UUFDeEQ7SUFDRDtJQUVBLElBQUlrQyxVQUFVTDtJQUNkLEtBQUssTUFBTSxDQUFDTSxXQUFXTCxPQUFPLElBQUlNLE9BQU9DLE9BQU8sQ0FBQ04sU0FBVTtRQUMxRCxJQUFJLENBQUNPLE1BQU1DLE9BQU8sQ0FBQ1QsU0FBUztZQUMzQjtRQUNEO1FBRUEsSUFBSSxDQUFFSyxDQUFBQSxhQUFhRCxPQUFNLEdBQUk7WUFDNUIsTUFBTSxJQUFJYixNQUFNLENBQUMscUJBQXFCLEVBQUVjLFVBQVUsQ0FBQztRQUNwRDtRQUVBRCxVQUFVSixPQUFPbEMsTUFBTSxHQUFHLElBQUlzQyxPQUFPLENBQUNDLFVBQVUsSUFBSUwsVUFBVUksT0FBTyxDQUFDQyxVQUFVO0lBQ2pGO0lBRUEsT0FBT0Q7QUFDUjtBQUVBTSxPQUFPQyxPQUFPLEdBQUcsQ0FBQ1osT0FBT2E7SUFDeEIsTUFBTVosU0FBUyxFQUFFO0lBQ2pCLE1BQU12QixTQUFTLEVBQUU7SUFDakIsSUFBSUksUUFBUSxFQUFFO0lBRWQsc0NBQXNDO0lBQ3RDK0IsVUFBVXpCLE9BQU8sQ0FBQy9CLGdCQUFnQixDQUFDZ0MsR0FBR3lCLGlCQUFpQlYsU0FBU1YsT0FBT3FCLE9BQU94QjtRQUM3RSxJQUFJdUIsaUJBQWlCO1lBQ3BCaEMsTUFBTUksSUFBSSxDQUFDdkIsU0FBU21EO1FBQ3JCLE9BQU8sSUFBSXBCLE9BQU87WUFDakIsTUFBTXNCLFNBQVNsQyxNQUFNbUMsSUFBSSxDQUFDO1lBQzFCbkMsUUFBUSxFQUFFO1lBQ1ZKLE9BQU9RLElBQUksQ0FBQ2UsT0FBT2xDLE1BQU0sS0FBSyxJQUFJaUQsU0FBU2pCLFdBQVdDLE9BQU9DLFFBQVFlO1lBQ3JFZixPQUFPZixJQUFJLENBQUM7Z0JBQUNrQjtnQkFBU0gsUUFBUVIsV0FBV0M7WUFBTTtRQUNoRCxPQUFPLElBQUlxQixPQUFPO1lBQ2pCLElBQUlkLE9BQU9sQyxNQUFNLEtBQUssR0FBRztnQkFDeEIsTUFBTSxJQUFJeUIsTUFBTTtZQUNqQjtZQUVBZCxPQUFPUSxJQUFJLENBQUNhLFdBQVdDLE9BQU9DLFFBQVFuQixNQUFNbUMsSUFBSSxDQUFDO1lBQ2pEbkMsUUFBUSxFQUFFO1lBQ1ZtQixPQUFPaUIsR0FBRztRQUNYLE9BQU87WUFDTnBDLE1BQU1JLElBQUksQ0FBQ0s7UUFDWjtJQUNEO0lBRUFiLE9BQU9RLElBQUksQ0FBQ0osTUFBTW1DLElBQUksQ0FBQztJQUV2QixJQUFJaEIsT0FBT2xDLE1BQU0sR0FBRyxHQUFHO1FBQ3RCLE1BQU1vRCxhQUFhLENBQUMsa0NBQWtDLEVBQUVsQixPQUFPbEMsTUFBTSxDQUFDLGdCQUFnQixFQUFFa0MsT0FBT2xDLE1BQU0sS0FBSyxJQUFJLEtBQUssSUFBSSxRQUFRLENBQUM7UUFDaEksTUFBTSxJQUFJeUIsTUFBTTJCO0lBQ2pCO0lBRUEsT0FBT3pDLE9BQU91QyxJQUFJLENBQUM7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvY2hhbGsvc291cmNlL3RlbXBsYXRlcy5qcz80NDY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IFRFTVBMQVRFX1JFR0VYID0gLyg/OlxcXFwodSg/OlthLWZcXGRdezR9fFxce1thLWZcXGRdezEsNn1cXH0pfHhbYS1mXFxkXXsyfXwuKSl8KD86XFx7KH4pPyhcXHcrKD86XFwoW14pXSpcXCkpPyg/OlxcLlxcdysoPzpcXChbXildKlxcKSk/KSopKD86WyBcXHRdfCg/PVxccj9cXG4pKSl8KFxcfSl8KCg/Oi58W1xcclxcblxcZl0pKz8pL2dpO1xuY29uc3QgU1RZTEVfUkVHRVggPSAvKD86XnxcXC4pKFxcdyspKD86XFwoKFteKV0qKVxcKSk/L2c7XG5jb25zdCBTVFJJTkdfUkVHRVggPSAvXihbJ1wiXSkoKD86XFxcXC58KD8hXFwxKVteXFxcXF0pKilcXDEkLztcbmNvbnN0IEVTQ0FQRV9SRUdFWCA9IC9cXFxcKHUoPzpbYS1mXFxkXXs0fXx7W2EtZlxcZF17MSw2fX0pfHhbYS1mXFxkXXsyfXwuKXwoW15cXFxcXSkvZ2k7XG5cbmNvbnN0IEVTQ0FQRVMgPSBuZXcgTWFwKFtcblx0WyduJywgJ1xcbiddLFxuXHRbJ3InLCAnXFxyJ10sXG5cdFsndCcsICdcXHQnXSxcblx0WydiJywgJ1xcYiddLFxuXHRbJ2YnLCAnXFxmJ10sXG5cdFsndicsICdcXHYnXSxcblx0WycwJywgJ1xcMCddLFxuXHRbJ1xcXFwnLCAnXFxcXCddLFxuXHRbJ2UnLCAnXFx1MDAxQiddLFxuXHRbJ2EnLCAnXFx1MDAwNyddXG5dKTtcblxuZnVuY3Rpb24gdW5lc2NhcGUoYykge1xuXHRjb25zdCB1ID0gY1swXSA9PT0gJ3UnO1xuXHRjb25zdCBicmFja2V0ID0gY1sxXSA9PT0gJ3snO1xuXG5cdGlmICgodSAmJiAhYnJhY2tldCAmJiBjLmxlbmd0aCA9PT0gNSkgfHwgKGNbMF0gPT09ICd4JyAmJiBjLmxlbmd0aCA9PT0gMykpIHtcblx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChjLnNsaWNlKDEpLCAxNikpO1xuXHR9XG5cblx0aWYgKHUgJiYgYnJhY2tldCkge1xuXHRcdHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChwYXJzZUludChjLnNsaWNlKDIsIC0xKSwgMTYpKTtcblx0fVxuXG5cdHJldHVybiBFU0NBUEVTLmdldChjKSB8fCBjO1xufVxuXG5mdW5jdGlvbiBwYXJzZUFyZ3VtZW50cyhuYW1lLCBhcmd1bWVudHNfKSB7XG5cdGNvbnN0IHJlc3VsdHMgPSBbXTtcblx0Y29uc3QgY2h1bmtzID0gYXJndW1lbnRzXy50cmltKCkuc3BsaXQoL1xccyosXFxzKi9nKTtcblx0bGV0IG1hdGNoZXM7XG5cblx0Zm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcblx0XHRjb25zdCBudW1iZXIgPSBOdW1iZXIoY2h1bmspO1xuXHRcdGlmICghTnVtYmVyLmlzTmFOKG51bWJlcikpIHtcblx0XHRcdHJlc3VsdHMucHVzaChudW1iZXIpO1xuXHRcdH0gZWxzZSBpZiAoKG1hdGNoZXMgPSBjaHVuay5tYXRjaChTVFJJTkdfUkVHRVgpKSkge1xuXHRcdFx0cmVzdWx0cy5wdXNoKG1hdGNoZXNbMl0ucmVwbGFjZShFU0NBUEVfUkVHRVgsIChtLCBlc2NhcGUsIGNoYXJhY3RlcikgPT4gZXNjYXBlID8gdW5lc2NhcGUoZXNjYXBlKSA6IGNoYXJhY3RlcikpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQ2hhbGsgdGVtcGxhdGUgc3R5bGUgYXJndW1lbnQ6ICR7Y2h1bmt9IChpbiBzdHlsZSAnJHtuYW1lfScpYCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3R5bGUoc3R5bGUpIHtcblx0U1RZTEVfUkVHRVgubGFzdEluZGV4ID0gMDtcblxuXHRjb25zdCByZXN1bHRzID0gW107XG5cdGxldCBtYXRjaGVzO1xuXG5cdHdoaWxlICgobWF0Y2hlcyA9IFNUWUxFX1JFR0VYLmV4ZWMoc3R5bGUpKSAhPT0gbnVsbCkge1xuXHRcdGNvbnN0IG5hbWUgPSBtYXRjaGVzWzFdO1xuXG5cdFx0aWYgKG1hdGNoZXNbMl0pIHtcblx0XHRcdGNvbnN0IGFyZ3MgPSBwYXJzZUFyZ3VtZW50cyhuYW1lLCBtYXRjaGVzWzJdKTtcblx0XHRcdHJlc3VsdHMucHVzaChbbmFtZV0uY29uY2F0KGFyZ3MpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0cy5wdXNoKFtuYW1lXSk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU3R5bGUoY2hhbGssIHN0eWxlcykge1xuXHRjb25zdCBlbmFibGVkID0ge307XG5cblx0Zm9yIChjb25zdCBsYXllciBvZiBzdHlsZXMpIHtcblx0XHRmb3IgKGNvbnN0IHN0eWxlIG9mIGxheWVyLnN0eWxlcykge1xuXHRcdFx0ZW5hYmxlZFtzdHlsZVswXV0gPSBsYXllci5pbnZlcnNlID8gbnVsbCA6IHN0eWxlLnNsaWNlKDEpO1xuXHRcdH1cblx0fVxuXG5cdGxldCBjdXJyZW50ID0gY2hhbGs7XG5cdGZvciAoY29uc3QgW3N0eWxlTmFtZSwgc3R5bGVzXSBvZiBPYmplY3QuZW50cmllcyhlbmFibGVkKSkge1xuXHRcdGlmICghQXJyYXkuaXNBcnJheShzdHlsZXMpKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoIShzdHlsZU5hbWUgaW4gY3VycmVudCkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgVW5rbm93biBDaGFsayBzdHlsZTogJHtzdHlsZU5hbWV9YCk7XG5cdFx0fVxuXG5cdFx0Y3VycmVudCA9IHN0eWxlcy5sZW5ndGggPiAwID8gY3VycmVudFtzdHlsZU5hbWVdKC4uLnN0eWxlcykgOiBjdXJyZW50W3N0eWxlTmFtZV07XG5cdH1cblxuXHRyZXR1cm4gY3VycmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSAoY2hhbGssIHRlbXBvcmFyeSkgPT4ge1xuXHRjb25zdCBzdHlsZXMgPSBbXTtcblx0Y29uc3QgY2h1bmtzID0gW107XG5cdGxldCBjaHVuayA9IFtdO1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtcGFyYW1zXG5cdHRlbXBvcmFyeS5yZXBsYWNlKFRFTVBMQVRFX1JFR0VYLCAobSwgZXNjYXBlQ2hhcmFjdGVyLCBpbnZlcnNlLCBzdHlsZSwgY2xvc2UsIGNoYXJhY3RlcikgPT4ge1xuXHRcdGlmIChlc2NhcGVDaGFyYWN0ZXIpIHtcblx0XHRcdGNodW5rLnB1c2godW5lc2NhcGUoZXNjYXBlQ2hhcmFjdGVyKSk7XG5cdFx0fSBlbHNlIGlmIChzdHlsZSkge1xuXHRcdFx0Y29uc3Qgc3RyaW5nID0gY2h1bmsuam9pbignJyk7XG5cdFx0XHRjaHVuayA9IFtdO1xuXHRcdFx0Y2h1bmtzLnB1c2goc3R5bGVzLmxlbmd0aCA9PT0gMCA/IHN0cmluZyA6IGJ1aWxkU3R5bGUoY2hhbGssIHN0eWxlcykoc3RyaW5nKSk7XG5cdFx0XHRzdHlsZXMucHVzaCh7aW52ZXJzZSwgc3R5bGVzOiBwYXJzZVN0eWxlKHN0eWxlKX0pO1xuXHRcdH0gZWxzZSBpZiAoY2xvc2UpIHtcblx0XHRcdGlmIChzdHlsZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignRm91bmQgZXh0cmFuZW91cyB9IGluIENoYWxrIHRlbXBsYXRlIGxpdGVyYWwnKTtcblx0XHRcdH1cblxuXHRcdFx0Y2h1bmtzLnB1c2goYnVpbGRTdHlsZShjaGFsaywgc3R5bGVzKShjaHVuay5qb2luKCcnKSkpO1xuXHRcdFx0Y2h1bmsgPSBbXTtcblx0XHRcdHN0eWxlcy5wb3AoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2h1bmsucHVzaChjaGFyYWN0ZXIpO1xuXHRcdH1cblx0fSk7XG5cblx0Y2h1bmtzLnB1c2goY2h1bmsuam9pbignJykpO1xuXG5cdGlmIChzdHlsZXMubGVuZ3RoID4gMCkge1xuXHRcdGNvbnN0IGVyck1lc3NhZ2UgPSBgQ2hhbGsgdGVtcGxhdGUgbGl0ZXJhbCBpcyBtaXNzaW5nICR7c3R5bGVzLmxlbmd0aH0gY2xvc2luZyBicmFja2V0JHtzdHlsZXMubGVuZ3RoID09PSAxID8gJycgOiAncyd9IChcXGB9XFxgKWA7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGVyck1lc3NhZ2UpO1xuXHR9XG5cblx0cmV0dXJuIGNodW5rcy5qb2luKCcnKTtcbn07XG4iXSwibmFtZXMiOlsiVEVNUExBVEVfUkVHRVgiLCJTVFlMRV9SRUdFWCIsIlNUUklOR19SRUdFWCIsIkVTQ0FQRV9SRUdFWCIsIkVTQ0FQRVMiLCJNYXAiLCJ1bmVzY2FwZSIsImMiLCJ1IiwiYnJhY2tldCIsImxlbmd0aCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInBhcnNlSW50Iiwic2xpY2UiLCJmcm9tQ29kZVBvaW50IiwiZ2V0IiwicGFyc2VBcmd1bWVudHMiLCJuYW1lIiwiYXJndW1lbnRzXyIsInJlc3VsdHMiLCJjaHVua3MiLCJ0cmltIiwic3BsaXQiLCJtYXRjaGVzIiwiY2h1bmsiLCJudW1iZXIiLCJOdW1iZXIiLCJpc05hTiIsInB1c2giLCJtYXRjaCIsInJlcGxhY2UiLCJtIiwiZXNjYXBlIiwiY2hhcmFjdGVyIiwiRXJyb3IiLCJwYXJzZVN0eWxlIiwic3R5bGUiLCJsYXN0SW5kZXgiLCJleGVjIiwiYXJncyIsImNvbmNhdCIsImJ1aWxkU3R5bGUiLCJjaGFsayIsInN0eWxlcyIsImVuYWJsZWQiLCJsYXllciIsImludmVyc2UiLCJjdXJyZW50Iiwic3R5bGVOYW1lIiwiT2JqZWN0IiwiZW50cmllcyIsIkFycmF5IiwiaXNBcnJheSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ0ZW1wb3JhcnkiLCJlc2NhcGVDaGFyYWN0ZXIiLCJjbG9zZSIsInN0cmluZyIsImpvaW4iLCJwb3AiLCJlcnJNZXNzYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/chalk/source/templates.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/chalk/source/util.js":
/*!*******************************************!*\
  !*** ./node_modules/chalk/source/util.js ***!
  \*******************************************/
/***/ ((module) => {

eval("\nconst stringReplaceAll = (string, substring, replacer)=>{\n    let index = string.indexOf(substring);\n    if (index === -1) {\n        return string;\n    }\n    const substringLength = substring.length;\n    let endIndex = 0;\n    let returnValue = \"\";\n    do {\n        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;\n        endIndex = index + substringLength;\n        index = string.indexOf(substring, endIndex);\n    }while (index !== -1);\n    returnValue += string.substr(endIndex);\n    return returnValue;\n};\nconst stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index)=>{\n    let endIndex = 0;\n    let returnValue = \"\";\n    do {\n        const gotCR = string[index - 1] === \"\\r\";\n        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? \"\\r\\n\" : \"\\n\") + postfix;\n        endIndex = index + 1;\n        index = string.indexOf(\"\\n\", endIndex);\n    }while (index !== -1);\n    returnValue += string.substr(endIndex);\n    return returnValue;\n};\nmodule.exports = {\n    stringReplaceAll,\n    stringEncaseCRLFWithFirstIndex\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY2hhbGsvc291cmNlL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxtQkFBbUIsQ0FBQ0MsUUFBUUMsV0FBV0M7SUFDNUMsSUFBSUMsUUFBUUgsT0FBT0ksT0FBTyxDQUFDSDtJQUMzQixJQUFJRSxVQUFVLENBQUMsR0FBRztRQUNqQixPQUFPSDtJQUNSO0lBRUEsTUFBTUssa0JBQWtCSixVQUFVSyxNQUFNO0lBQ3hDLElBQUlDLFdBQVc7SUFDZixJQUFJQyxjQUFjO0lBQ2xCLEdBQUc7UUFDRkEsZUFBZVIsT0FBT1MsTUFBTSxDQUFDRixVQUFVSixRQUFRSSxZQUFZTixZQUFZQztRQUN2RUssV0FBV0osUUFBUUU7UUFDbkJGLFFBQVFILE9BQU9JLE9BQU8sQ0FBQ0gsV0FBV007SUFDbkMsUUFBU0osVUFBVSxDQUFDLEdBQUc7SUFFdkJLLGVBQWVSLE9BQU9TLE1BQU0sQ0FBQ0Y7SUFDN0IsT0FBT0M7QUFDUjtBQUVBLE1BQU1FLGlDQUFpQyxDQUFDVixRQUFRVyxRQUFRQyxTQUFTVDtJQUNoRSxJQUFJSSxXQUFXO0lBQ2YsSUFBSUMsY0FBYztJQUNsQixHQUFHO1FBQ0YsTUFBTUssUUFBUWIsTUFBTSxDQUFDRyxRQUFRLEVBQUUsS0FBSztRQUNwQ0ssZUFBZVIsT0FBT1MsTUFBTSxDQUFDRixVQUFVLENBQUNNLFFBQVFWLFFBQVEsSUFBSUEsS0FBSSxJQUFLSSxZQUFZSSxTQUFVRSxDQUFBQSxRQUFRLFNBQVMsSUFBRyxJQUFLRDtRQUNwSEwsV0FBV0osUUFBUTtRQUNuQkEsUUFBUUgsT0FBT0ksT0FBTyxDQUFDLE1BQU1HO0lBQzlCLFFBQVNKLFVBQVUsQ0FBQyxHQUFHO0lBRXZCSyxlQUFlUixPQUFPUyxNQUFNLENBQUNGO0lBQzdCLE9BQU9DO0FBQ1I7QUFFQU0sT0FBT0MsT0FBTyxHQUFHO0lBQ2hCaEI7SUFDQVc7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL215LWFwcC8uL25vZGVfbW9kdWxlcy9jaGFsay9zb3VyY2UvdXRpbC5qcz9iNTRiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgc3RyaW5nUmVwbGFjZUFsbCA9IChzdHJpbmcsIHN1YnN0cmluZywgcmVwbGFjZXIpID0+IHtcblx0bGV0IGluZGV4ID0gc3RyaW5nLmluZGV4T2Yoc3Vic3RyaW5nKTtcblx0aWYgKGluZGV4ID09PSAtMSkge1xuXHRcdHJldHVybiBzdHJpbmc7XG5cdH1cblxuXHRjb25zdCBzdWJzdHJpbmdMZW5ndGggPSBzdWJzdHJpbmcubGVuZ3RoO1xuXHRsZXQgZW5kSW5kZXggPSAwO1xuXHRsZXQgcmV0dXJuVmFsdWUgPSAnJztcblx0ZG8ge1xuXHRcdHJldHVyblZhbHVlICs9IHN0cmluZy5zdWJzdHIoZW5kSW5kZXgsIGluZGV4IC0gZW5kSW5kZXgpICsgc3Vic3RyaW5nICsgcmVwbGFjZXI7XG5cdFx0ZW5kSW5kZXggPSBpbmRleCArIHN1YnN0cmluZ0xlbmd0aDtcblx0XHRpbmRleCA9IHN0cmluZy5pbmRleE9mKHN1YnN0cmluZywgZW5kSW5kZXgpO1xuXHR9IHdoaWxlIChpbmRleCAhPT0gLTEpO1xuXG5cdHJldHVyblZhbHVlICs9IHN0cmluZy5zdWJzdHIoZW5kSW5kZXgpO1xuXHRyZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xuXG5jb25zdCBzdHJpbmdFbmNhc2VDUkxGV2l0aEZpcnN0SW5kZXggPSAoc3RyaW5nLCBwcmVmaXgsIHBvc3RmaXgsIGluZGV4KSA9PiB7XG5cdGxldCBlbmRJbmRleCA9IDA7XG5cdGxldCByZXR1cm5WYWx1ZSA9ICcnO1xuXHRkbyB7XG5cdFx0Y29uc3QgZ290Q1IgPSBzdHJpbmdbaW5kZXggLSAxXSA9PT0gJ1xccic7XG5cdFx0cmV0dXJuVmFsdWUgKz0gc3RyaW5nLnN1YnN0cihlbmRJbmRleCwgKGdvdENSID8gaW5kZXggLSAxIDogaW5kZXgpIC0gZW5kSW5kZXgpICsgcHJlZml4ICsgKGdvdENSID8gJ1xcclxcbicgOiAnXFxuJykgKyBwb3N0Zml4O1xuXHRcdGVuZEluZGV4ID0gaW5kZXggKyAxO1xuXHRcdGluZGV4ID0gc3RyaW5nLmluZGV4T2YoJ1xcbicsIGVuZEluZGV4KTtcblx0fSB3aGlsZSAoaW5kZXggIT09IC0xKTtcblxuXHRyZXR1cm5WYWx1ZSArPSBzdHJpbmcuc3Vic3RyKGVuZEluZGV4KTtcblx0cmV0dXJuIHJldHVyblZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdHN0cmluZ1JlcGxhY2VBbGwsXG5cdHN0cmluZ0VuY2FzZUNSTEZXaXRoRmlyc3RJbmRleFxufTtcbiJdLCJuYW1lcyI6WyJzdHJpbmdSZXBsYWNlQWxsIiwic3RyaW5nIiwic3Vic3RyaW5nIiwicmVwbGFjZXIiLCJpbmRleCIsImluZGV4T2YiLCJzdWJzdHJpbmdMZW5ndGgiLCJsZW5ndGgiLCJlbmRJbmRleCIsInJldHVyblZhbHVlIiwic3Vic3RyIiwic3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4IiwicHJlZml4IiwicG9zdGZpeCIsImdvdENSIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/chalk/source/util.js\n");

/***/ })

};
;