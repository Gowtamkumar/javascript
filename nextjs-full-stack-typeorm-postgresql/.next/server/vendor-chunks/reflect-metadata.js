/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/reflect-metadata";
exports.ids = ["vendor-chunks/reflect-metadata"];
exports.modules = {

/***/ "(rsc)/./node_modules/reflect-metadata/Reflect.js":
/*!**************************************************!*\
  !*** ./node_modules/reflect-metadata/Reflect.js ***!
  \**************************************************/
/***/ (() => {

eval("/*! *****************************************************************************\nCopyright (C) Microsoft. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */ var Reflect;\n(function(Reflect) {\n    // Metadata Proposal\n    // https://rbuckton.github.io/reflect-metadata/\n    (function(factory) {\n        var root = typeof globalThis === \"object\" ? globalThis : typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : sloppyModeThis();\n        var exporter = makeExporter(Reflect);\n        if (typeof root.Reflect !== \"undefined\") {\n            exporter = makeExporter(root.Reflect, exporter);\n        }\n        factory(exporter, root);\n        if (typeof root.Reflect === \"undefined\") {\n            root.Reflect = Reflect;\n        }\n        function makeExporter(target, previous) {\n            return function(key, value) {\n                Object.defineProperty(target, key, {\n                    configurable: true,\n                    writable: true,\n                    value: value\n                });\n                if (previous) previous(key, value);\n            };\n        }\n        function functionThis() {\n            try {\n                return Function(\"return this;\")();\n            } catch (_) {}\n        }\n        function indirectEvalThis() {\n            try {\n                return (0, eval)(\"(function() { return this; })()\");\n            } catch (_) {}\n        }\n        function sloppyModeThis() {\n            return functionThis() || indirectEvalThis();\n        }\n    })(function(exporter, root) {\n        var hasOwn = Object.prototype.hasOwnProperty;\n        // feature test for Symbol support\n        var supportsSymbol = typeof Symbol === \"function\";\n        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== \"undefined\" ? Symbol.toPrimitive : \"@@toPrimitive\";\n        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== \"undefined\" ? Symbol.iterator : \"@@iterator\";\n        var supportsCreate = typeof Object.create === \"function\"; // feature test for Object.create support\n        var supportsProto = ({\n            __proto__: []\n        }) instanceof Array; // feature test for __proto__ support\n        var downLevel = !supportsCreate && !supportsProto;\n        var HashMap = {\n            // create an object in dictionary mode (a.k.a. \"slow\" mode in v8)\n            create: supportsCreate ? function() {\n                return MakeDictionary(Object.create(null));\n            } : supportsProto ? function() {\n                return MakeDictionary({\n                    __proto__: null\n                });\n            } : function() {\n                return MakeDictionary({});\n            },\n            has: downLevel ? function(map, key) {\n                return hasOwn.call(map, key);\n            } : function(map, key) {\n                return key in map;\n            },\n            get: downLevel ? function(map, key) {\n                return hasOwn.call(map, key) ? map[key] : undefined;\n            } : function(map, key) {\n                return map[key];\n            }\n        };\n        // Load global or shim versions of Map, Set, and WeakMap\n        var functionPrototype = Object.getPrototypeOf(Function);\n        var _Map = typeof Map === \"function\" && typeof Map.prototype.entries === \"function\" ? Map : CreateMapPolyfill();\n        var _Set = typeof Set === \"function\" && typeof Set.prototype.entries === \"function\" ? Set : CreateSetPolyfill();\n        var _WeakMap = typeof WeakMap === \"function\" ? WeakMap : CreateWeakMapPolyfill();\n        var registrySymbol = supportsSymbol ? Symbol.for(\"@reflect-metadata:registry\") : undefined;\n        var metadataRegistry = GetOrCreateMetadataRegistry();\n        var metadataProvider = CreateMetadataProvider(metadataRegistry);\n        /**\n         * Applies a set of decorators to a property of a target object.\n         * @param decorators An array of decorators.\n         * @param target The target object.\n         * @param propertyKey (Optional) The property key to decorate.\n         * @param attributes (Optional) The property descriptor for the target key.\n         * @remarks Decorators are applied in reverse order.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     Example = Reflect.decorate(decoratorsArray, Example);\n         *\n         *     // property (on constructor)\n         *     Reflect.decorate(decoratorsArray, Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     Reflect.decorate(decoratorsArray, Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     Object.defineProperty(Example, \"staticMethod\",\n         *         Reflect.decorate(decoratorsArray, Example, \"staticMethod\",\n         *             Object.getOwnPropertyDescriptor(Example, \"staticMethod\")));\n         *\n         *     // method (on prototype)\n         *     Object.defineProperty(Example.prototype, \"method\",\n         *         Reflect.decorate(decoratorsArray, Example.prototype, \"method\",\n         *             Object.getOwnPropertyDescriptor(Example.prototype, \"method\")));\n         *\n         */ function decorate(decorators, target, propertyKey, attributes) {\n            if (!IsUndefined(propertyKey)) {\n                if (!IsArray(decorators)) throw new TypeError();\n                if (!IsObject(target)) throw new TypeError();\n                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes)) throw new TypeError();\n                if (IsNull(attributes)) attributes = undefined;\n                propertyKey = ToPropertyKey(propertyKey);\n                return DecorateProperty(decorators, target, propertyKey, attributes);\n            } else {\n                if (!IsArray(decorators)) throw new TypeError();\n                if (!IsConstructor(target)) throw new TypeError();\n                return DecorateConstructor(decorators, target);\n            }\n        }\n        exporter(\"decorate\", decorate);\n        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)\n        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata\n        /**\n         * A default metadata decorator factory that can be used on a class, class member, or parameter.\n         * @param metadataKey The key for the metadata entry.\n         * @param metadataValue The value for the metadata entry.\n         * @returns A decorator function.\n         * @remarks\n         * If `metadataKey` is already defined for the target and target key, the\n         * metadataValue for that key will be overwritten.\n         * @example\n         *\n         *     // constructor\n         *     @Reflect.metadata(key, value)\n         *     class Example {\n         *     }\n         *\n         *     // property (on constructor, TypeScript only)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         static staticProperty;\n         *     }\n         *\n         *     // property (on prototype, TypeScript only)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         property;\n         *     }\n         *\n         *     // method (on constructor)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         static staticMethod() { }\n         *     }\n         *\n         *     // method (on prototype)\n         *     class Example {\n         *         @Reflect.metadata(key, value)\n         *         method() { }\n         *     }\n         *\n         */ function metadata(metadataKey, metadataValue) {\n            function decorator(target, propertyKey) {\n                if (!IsObject(target)) throw new TypeError();\n                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey)) throw new TypeError();\n                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\n            }\n            return decorator;\n        }\n        exporter(\"metadata\", metadata);\n        /**\n         * Define a unique metadata entry on the target.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param metadataValue A value that contains attached metadata.\n         * @param target The target object on which to define metadata.\n         * @param propertyKey (Optional) The property key for the target.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example);\n         *\n         *     // property (on constructor)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     Reflect.defineMetadata(\"custom:annotation\", options, Example.prototype, \"method\");\n         *\n         *     // decorator factory as metadata-producing annotation.\n         *     function MyAnnotation(options): Decorator {\n         *         return (target, key?) => Reflect.defineMetadata(\"custom:annotation\", options, target, key);\n         *     }\n         *\n         */ function defineMetadata(metadataKey, metadataValue, target, propertyKey) {\n            if (!IsObject(target)) throw new TypeError();\n            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);\n        }\n        exporter(\"defineMetadata\", defineMetadata);\n        /**\n         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.hasMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */ function hasMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target)) throw new TypeError();\n            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryHasMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"hasMetadata\", hasMetadata);\n        /**\n         * Gets a value indicating whether the target object has the provided metadata key defined.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.hasOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */ function hasOwnMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target)) throw new TypeError();\n            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"hasOwnMetadata\", hasOwnMetadata);\n        /**\n         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */ function getMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target)) throw new TypeError();\n            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryGetMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"getMetadata\", getMetadata);\n        /**\n         * Gets the metadata value for the provided metadata key on the target object.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getOwnMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */ function getOwnMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target)) throw new TypeError();\n            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"getOwnMetadata\", getOwnMetadata);\n        /**\n         * Gets the metadata keys defined on the target object or its prototype chain.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns An array of unique metadata keys.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getMetadataKeys(Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getMetadataKeys(Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getMetadataKeys(Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getMetadataKeys(Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getMetadataKeys(Example.prototype, \"method\");\n         *\n         */ function getMetadataKeys(target, propertyKey) {\n            if (!IsObject(target)) throw new TypeError();\n            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryMetadataKeys(target, propertyKey);\n        }\n        exporter(\"getMetadataKeys\", getMetadataKeys);\n        /**\n         * Gets the unique metadata keys defined on the target object.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns An array of unique metadata keys.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.getOwnMetadataKeys(Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.getOwnMetadataKeys(Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.getOwnMetadataKeys(Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.getOwnMetadataKeys(Example.prototype, \"method\");\n         *\n         */ function getOwnMetadataKeys(target, propertyKey) {\n            if (!IsObject(target)) throw new TypeError();\n            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\n            return OrdinaryOwnMetadataKeys(target, propertyKey);\n        }\n        exporter(\"getOwnMetadataKeys\", getOwnMetadataKeys);\n        /**\n         * Deletes the metadata entry from the target object with the provided key.\n         * @param metadataKey A key used to store and retrieve metadata.\n         * @param target The target object on which the metadata is defined.\n         * @param propertyKey (Optional) The property key for the target.\n         * @returns `true` if the metadata entry was found and deleted; otherwise, false.\n         * @example\n         *\n         *     class Example {\n         *         // property declarations are not part of ES6, though they are valid in TypeScript:\n         *         // static staticProperty;\n         *         // property;\n         *\n         *         constructor(p) { }\n         *         static staticMethod(p) { }\n         *         method(p) { }\n         *     }\n         *\n         *     // constructor\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example);\n         *\n         *     // property (on constructor)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticProperty\");\n         *\n         *     // property (on prototype)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"property\");\n         *\n         *     // method (on constructor)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example, \"staticMethod\");\n         *\n         *     // method (on prototype)\n         *     result = Reflect.deleteMetadata(\"custom:annotation\", Example.prototype, \"method\");\n         *\n         */ function deleteMetadata(metadataKey, target, propertyKey) {\n            if (!IsObject(target)) throw new TypeError();\n            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\n            if (!IsObject(target)) throw new TypeError();\n            if (!IsUndefined(propertyKey)) propertyKey = ToPropertyKey(propertyKey);\n            var provider = GetMetadataProvider(target, propertyKey, /*Create*/ false);\n            if (IsUndefined(provider)) return false;\n            return provider.OrdinaryDeleteMetadata(metadataKey, target, propertyKey);\n        }\n        exporter(\"deleteMetadata\", deleteMetadata);\n        function DecorateConstructor(decorators, target) {\n            for(var i = decorators.length - 1; i >= 0; --i){\n                var decorator = decorators[i];\n                var decorated = decorator(target);\n                if (!IsUndefined(decorated) && !IsNull(decorated)) {\n                    if (!IsConstructor(decorated)) throw new TypeError();\n                    target = decorated;\n                }\n            }\n            return target;\n        }\n        function DecorateProperty(decorators, target, propertyKey, descriptor) {\n            for(var i = decorators.length - 1; i >= 0; --i){\n                var decorator = decorators[i];\n                var decorated = decorator(target, propertyKey, descriptor);\n                if (!IsUndefined(decorated) && !IsNull(decorated)) {\n                    if (!IsObject(decorated)) throw new TypeError();\n                    descriptor = decorated;\n                }\n            }\n            return descriptor;\n        }\n        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata\n        function OrdinaryHasMetadata(MetadataKey, O, P) {\n            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\n            if (hasOwn) return true;\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (!IsNull(parent)) return OrdinaryHasMetadata(MetadataKey, parent, P);\n            return false;\n        }\n        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata\n        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {\n            var provider = GetMetadataProvider(O, P, /*Create*/ false);\n            if (IsUndefined(provider)) return false;\n            return ToBoolean(provider.OrdinaryHasOwnMetadata(MetadataKey, O, P));\n        }\n        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata\n        function OrdinaryGetMetadata(MetadataKey, O, P) {\n            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);\n            if (hasOwn) return OrdinaryGetOwnMetadata(MetadataKey, O, P);\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (!IsNull(parent)) return OrdinaryGetMetadata(MetadataKey, parent, P);\n            return undefined;\n        }\n        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata\n        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {\n            var provider = GetMetadataProvider(O, P, /*Create*/ false);\n            if (IsUndefined(provider)) return;\n            return provider.OrdinaryGetOwnMetadata(MetadataKey, O, P);\n        }\n        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata\n        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {\n            var provider = GetMetadataProvider(O, P, /*Create*/ true);\n            provider.OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P);\n        }\n        // 3.1.6.1 OrdinaryMetadataKeys(O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys\n        function OrdinaryMetadataKeys(O, P) {\n            var ownKeys = OrdinaryOwnMetadataKeys(O, P);\n            var parent = OrdinaryGetPrototypeOf(O);\n            if (parent === null) return ownKeys;\n            var parentKeys = OrdinaryMetadataKeys(parent, P);\n            if (parentKeys.length <= 0) return ownKeys;\n            if (ownKeys.length <= 0) return parentKeys;\n            var set = new _Set();\n            var keys = [];\n            for(var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++){\n                var key = ownKeys_1[_i];\n                var hasKey = set.has(key);\n                if (!hasKey) {\n                    set.add(key);\n                    keys.push(key);\n                }\n            }\n            for(var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++){\n                var key = parentKeys_1[_a];\n                var hasKey = set.has(key);\n                if (!hasKey) {\n                    set.add(key);\n                    keys.push(key);\n                }\n            }\n            return keys;\n        }\n        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)\n        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys\n        function OrdinaryOwnMetadataKeys(O, P) {\n            var provider = GetMetadataProvider(O, P, /*create*/ false);\n            if (!provider) {\n                return [];\n            }\n            return provider.OrdinaryOwnMetadataKeys(O, P);\n        }\n        // 6 ECMAScript Data Typ0es and Values\n        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values\n        function Type(x) {\n            if (x === null) return 1 /* Null */ ;\n            switch(typeof x){\n                case \"undefined\":\n                    return 0 /* Undefined */ ;\n                case \"boolean\":\n                    return 2 /* Boolean */ ;\n                case \"string\":\n                    return 3 /* String */ ;\n                case \"symbol\":\n                    return 4 /* Symbol */ ;\n                case \"number\":\n                    return 5 /* Number */ ;\n                case \"object\":\n                    return x === null ? 1 /* Null */  : 6 /* Object */ ;\n                default:\n                    return 6 /* Object */ ;\n            }\n        }\n        // 6.1.1 The Undefined Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type\n        function IsUndefined(x) {\n            return x === undefined;\n        }\n        // 6.1.2 The Null Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type\n        function IsNull(x) {\n            return x === null;\n        }\n        // 6.1.5 The Symbol Type\n        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type\n        function IsSymbol(x) {\n            return typeof x === \"symbol\";\n        }\n        // 6.1.7 The Object Type\n        // https://tc39.github.io/ecma262/#sec-object-type\n        function IsObject(x) {\n            return typeof x === \"object\" ? x !== null : typeof x === \"function\";\n        }\n        // 7.1 Type Conversion\n        // https://tc39.github.io/ecma262/#sec-type-conversion\n        // 7.1.1 ToPrimitive(input [, PreferredType])\n        // https://tc39.github.io/ecma262/#sec-toprimitive\n        function ToPrimitive(input, PreferredType) {\n            switch(Type(input)){\n                case 0 /* Undefined */ :\n                    return input;\n                case 1 /* Null */ :\n                    return input;\n                case 2 /* Boolean */ :\n                    return input;\n                case 3 /* String */ :\n                    return input;\n                case 4 /* Symbol */ :\n                    return input;\n                case 5 /* Number */ :\n                    return input;\n            }\n            var hint = PreferredType === 3 /* String */  ? \"string\" : PreferredType === 5 /* Number */  ? \"number\" : \"default\";\n            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);\n            if (exoticToPrim !== undefined) {\n                var result = exoticToPrim.call(input, hint);\n                if (IsObject(result)) throw new TypeError();\n                return result;\n            }\n            return OrdinaryToPrimitive(input, hint === \"default\" ? \"number\" : hint);\n        }\n        // 7.1.1.1 OrdinaryToPrimitive(O, hint)\n        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive\n        function OrdinaryToPrimitive(O, hint) {\n            if (hint === \"string\") {\n                var toString_1 = O.toString;\n                if (IsCallable(toString_1)) {\n                    var result = toString_1.call(O);\n                    if (!IsObject(result)) return result;\n                }\n                var valueOf = O.valueOf;\n                if (IsCallable(valueOf)) {\n                    var result = valueOf.call(O);\n                    if (!IsObject(result)) return result;\n                }\n            } else {\n                var valueOf = O.valueOf;\n                if (IsCallable(valueOf)) {\n                    var result = valueOf.call(O);\n                    if (!IsObject(result)) return result;\n                }\n                var toString_2 = O.toString;\n                if (IsCallable(toString_2)) {\n                    var result = toString_2.call(O);\n                    if (!IsObject(result)) return result;\n                }\n            }\n            throw new TypeError();\n        }\n        // 7.1.2 ToBoolean(argument)\n        // https://tc39.github.io/ecma262/2016/#sec-toboolean\n        function ToBoolean(argument) {\n            return !!argument;\n        }\n        // 7.1.12 ToString(argument)\n        // https://tc39.github.io/ecma262/#sec-tostring\n        function ToString(argument) {\n            return \"\" + argument;\n        }\n        // 7.1.14 ToPropertyKey(argument)\n        // https://tc39.github.io/ecma262/#sec-topropertykey\n        function ToPropertyKey(argument) {\n            var key = ToPrimitive(argument, 3 /* String */ );\n            if (IsSymbol(key)) return key;\n            return ToString(key);\n        }\n        // 7.2 Testing and Comparison Operations\n        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations\n        // 7.2.2 IsArray(argument)\n        // https://tc39.github.io/ecma262/#sec-isarray\n        function IsArray(argument) {\n            return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === \"[object Array]\";\n        }\n        // 7.2.3 IsCallable(argument)\n        // https://tc39.github.io/ecma262/#sec-iscallable\n        function IsCallable(argument) {\n            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.\n            return typeof argument === \"function\";\n        }\n        // 7.2.4 IsConstructor(argument)\n        // https://tc39.github.io/ecma262/#sec-isconstructor\n        function IsConstructor(argument) {\n            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.\n            return typeof argument === \"function\";\n        }\n        // 7.2.7 IsPropertyKey(argument)\n        // https://tc39.github.io/ecma262/#sec-ispropertykey\n        function IsPropertyKey(argument) {\n            switch(Type(argument)){\n                case 3 /* String */ :\n                    return true;\n                case 4 /* Symbol */ :\n                    return true;\n                default:\n                    return false;\n            }\n        }\n        function SameValueZero(x, y) {\n            return x === y || x !== x && y !== y;\n        }\n        // 7.3 Operations on Objects\n        // https://tc39.github.io/ecma262/#sec-operations-on-objects\n        // 7.3.9 GetMethod(V, P)\n        // https://tc39.github.io/ecma262/#sec-getmethod\n        function GetMethod(V, P) {\n            var func = V[P];\n            if (func === undefined || func === null) return undefined;\n            if (!IsCallable(func)) throw new TypeError();\n            return func;\n        }\n        // 7.4 Operations on Iterator Objects\n        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects\n        function GetIterator(obj) {\n            var method = GetMethod(obj, iteratorSymbol);\n            if (!IsCallable(method)) throw new TypeError(); // from Call\n            var iterator = method.call(obj);\n            if (!IsObject(iterator)) throw new TypeError();\n            return iterator;\n        }\n        // 7.4.4 IteratorValue(iterResult)\n        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue\n        function IteratorValue(iterResult) {\n            return iterResult.value;\n        }\n        // 7.4.5 IteratorStep(iterator)\n        // https://tc39.github.io/ecma262/#sec-iteratorstep\n        function IteratorStep(iterator) {\n            var result = iterator.next();\n            return result.done ? false : result;\n        }\n        // 7.4.6 IteratorClose(iterator, completion)\n        // https://tc39.github.io/ecma262/#sec-iteratorclose\n        function IteratorClose(iterator) {\n            var f = iterator[\"return\"];\n            if (f) f.call(iterator);\n        }\n        // 9.1 Ordinary Object Internal Methods and Internal Slots\n        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots\n        // 9.1.1.1 OrdinaryGetPrototypeOf(O)\n        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof\n        function OrdinaryGetPrototypeOf(O) {\n            var proto = Object.getPrototypeOf(O);\n            if (typeof O !== \"function\" || O === functionPrototype) return proto;\n            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.\n            // Try to determine the superclass constructor. Compatible implementations\n            // must either set __proto__ on a subclass constructor to the superclass constructor,\n            // or ensure each class has a valid `constructor` property on its prototype that\n            // points back to the constructor.\n            // If this is not the same as Function.[[Prototype]], then this is definately inherited.\n            // This is the case when in ES6 or when using __proto__ in a compatible browser.\n            if (proto !== functionPrototype) return proto;\n            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.\n            var prototype = O.prototype;\n            var prototypeProto = prototype && Object.getPrototypeOf(prototype);\n            if (prototypeProto == null || prototypeProto === Object.prototype) return proto;\n            // If the constructor was not a function, then we cannot determine the heritage.\n            var constructor = prototypeProto.constructor;\n            if (typeof constructor !== \"function\") return proto;\n            // If we have some kind of self-reference, then we cannot determine the heritage.\n            if (constructor === O) return proto;\n            // we have a pretty good guess at the heritage.\n            return constructor;\n        }\n        // Global metadata registry\n        // - Allows `import \"reflect-metadata\"` and `import \"reflect-metadata/no-conflict\"` to interoperate.\n        // - Uses isolated metadata if `Reflect` is frozen before the registry can be installed.\n        /**\n         * Creates a registry used to allow multiple `reflect-metadata` providers.\n         */ function CreateMetadataRegistry() {\n            var fallback;\n            if (!IsUndefined(registrySymbol) && typeof root.Reflect !== \"undefined\" && !(registrySymbol in root.Reflect) && typeof root.Reflect.defineMetadata === \"function\") {\n                // interoperate with older version of `reflect-metadata` that did not support a registry.\n                fallback = CreateFallbackProvider(root.Reflect);\n            }\n            var first;\n            var second;\n            var rest;\n            var targetProviderMap = new _WeakMap();\n            var registry = {\n                registerProvider: registerProvider,\n                getProvider: getProvider,\n                setProvider: setProvider\n            };\n            return registry;\n            function registerProvider(provider) {\n                if (!Object.isExtensible(registry)) {\n                    throw new Error(\"Cannot add provider to a frozen registry.\");\n                }\n                switch(true){\n                    case fallback === provider:\n                        break;\n                    case IsUndefined(first):\n                        first = provider;\n                        break;\n                    case first === provider:\n                        break;\n                    case IsUndefined(second):\n                        second = provider;\n                        break;\n                    case second === provider:\n                        break;\n                    default:\n                        if (rest === undefined) rest = new _Set();\n                        rest.add(provider);\n                        break;\n                }\n            }\n            function getProviderNoCache(O, P) {\n                if (!IsUndefined(first)) {\n                    if (first.isProviderFor(O, P)) return first;\n                    if (!IsUndefined(second)) {\n                        if (second.isProviderFor(O, P)) return first;\n                        if (!IsUndefined(rest)) {\n                            var iterator = GetIterator(rest);\n                            while(true){\n                                var next = IteratorStep(iterator);\n                                if (!next) {\n                                    return undefined;\n                                }\n                                var provider = IteratorValue(next);\n                                if (provider.isProviderFor(O, P)) {\n                                    IteratorClose(iterator);\n                                    return provider;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!IsUndefined(fallback) && fallback.isProviderFor(O, P)) {\n                    return fallback;\n                }\n                return undefined;\n            }\n            function getProvider(O, P) {\n                var providerMap = targetProviderMap.get(O);\n                var provider;\n                if (!IsUndefined(providerMap)) {\n                    provider = providerMap.get(P);\n                }\n                if (!IsUndefined(provider)) {\n                    return provider;\n                }\n                provider = getProviderNoCache(O, P);\n                if (!IsUndefined(provider)) {\n                    if (IsUndefined(providerMap)) {\n                        providerMap = new _Map();\n                        targetProviderMap.set(O, providerMap);\n                    }\n                    providerMap.set(P, provider);\n                }\n                return provider;\n            }\n            function hasProvider(provider) {\n                if (IsUndefined(provider)) throw new TypeError();\n                return first === provider || second === provider || !IsUndefined(rest) && rest.has(provider);\n            }\n            function setProvider(O, P, provider) {\n                if (!hasProvider(provider)) {\n                    throw new Error(\"Metadata provider not registered.\");\n                }\n                var existingProvider = getProvider(O, P);\n                if (existingProvider !== provider) {\n                    if (!IsUndefined(existingProvider)) {\n                        return false;\n                    }\n                    var providerMap = targetProviderMap.get(O);\n                    if (IsUndefined(providerMap)) {\n                        providerMap = new _Map();\n                        targetProviderMap.set(O, providerMap);\n                    }\n                    providerMap.set(P, provider);\n                }\n                return true;\n            }\n        }\n        /**\n         * Gets or creates the shared registry of metadata providers.\n         */ function GetOrCreateMetadataRegistry() {\n            var metadataRegistry;\n            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {\n                metadataRegistry = root.Reflect[registrySymbol];\n            }\n            if (IsUndefined(metadataRegistry)) {\n                metadataRegistry = CreateMetadataRegistry();\n            }\n            if (!IsUndefined(registrySymbol) && IsObject(root.Reflect) && Object.isExtensible(root.Reflect)) {\n                Object.defineProperty(root.Reflect, registrySymbol, {\n                    enumerable: false,\n                    configurable: false,\n                    writable: false,\n                    value: metadataRegistry\n                });\n            }\n            return metadataRegistry;\n        }\n        function CreateMetadataProvider(registry) {\n            // [[Metadata]] internal slot\n            // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots\n            var metadata = new _WeakMap();\n            var provider = {\n                isProviderFor: function(O, P) {\n                    var targetMetadata = metadata.get(O);\n                    if (IsUndefined(targetMetadata)) return false;\n                    return targetMetadata.has(P);\n                },\n                OrdinaryDefineOwnMetadata: OrdinaryDefineOwnMetadata,\n                OrdinaryHasOwnMetadata: OrdinaryHasOwnMetadata,\n                OrdinaryGetOwnMetadata: OrdinaryGetOwnMetadata,\n                OrdinaryOwnMetadataKeys: OrdinaryOwnMetadataKeys,\n                OrdinaryDeleteMetadata: OrdinaryDeleteMetadata\n            };\n            metadataRegistry.registerProvider(provider);\n            return provider;\n            function GetOrCreateMetadataMap(O, P, Create) {\n                var targetMetadata = metadata.get(O);\n                var createdTargetMetadata = false;\n                if (IsUndefined(targetMetadata)) {\n                    if (!Create) return undefined;\n                    targetMetadata = new _Map();\n                    metadata.set(O, targetMetadata);\n                    createdTargetMetadata = true;\n                }\n                var metadataMap = targetMetadata.get(P);\n                if (IsUndefined(metadataMap)) {\n                    if (!Create) return undefined;\n                    metadataMap = new _Map();\n                    targetMetadata.set(P, metadataMap);\n                    if (!registry.setProvider(O, P, provider)) {\n                        targetMetadata.delete(P);\n                        if (createdTargetMetadata) {\n                            metadata.delete(O);\n                        }\n                        throw new Error(\"Wrong provider for target.\");\n                    }\n                }\n                return metadataMap;\n            }\n            // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)\n            // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata\n            function OrdinaryHasOwnMetadata(MetadataKey, O, P) {\n                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n                if (IsUndefined(metadataMap)) return false;\n                return ToBoolean(metadataMap.has(MetadataKey));\n            }\n            // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)\n            // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata\n            function OrdinaryGetOwnMetadata(MetadataKey, O, P) {\n                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n                if (IsUndefined(metadataMap)) return undefined;\n                return metadataMap.get(MetadataKey);\n            }\n            // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)\n            // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata\n            function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {\n                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);\n                metadataMap.set(MetadataKey, MetadataValue);\n            }\n            // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)\n            // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys\n            function OrdinaryOwnMetadataKeys(O, P) {\n                var keys = [];\n                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n                if (IsUndefined(metadataMap)) return keys;\n                var keysObj = metadataMap.keys();\n                var iterator = GetIterator(keysObj);\n                var k = 0;\n                while(true){\n                    var next = IteratorStep(iterator);\n                    if (!next) {\n                        keys.length = k;\n                        return keys;\n                    }\n                    var nextValue = IteratorValue(next);\n                    try {\n                        keys[k] = nextValue;\n                    } catch (e) {\n                        try {\n                            IteratorClose(iterator);\n                        } finally{\n                            throw e;\n                        }\n                    }\n                    k++;\n                }\n            }\n            function OrdinaryDeleteMetadata(MetadataKey, O, P) {\n                var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);\n                if (IsUndefined(metadataMap)) return false;\n                if (!metadataMap.delete(MetadataKey)) return false;\n                if (metadataMap.size === 0) {\n                    var targetMetadata = metadata.get(O);\n                    if (!IsUndefined(targetMetadata)) {\n                        targetMetadata.delete(P);\n                        if (targetMetadata.size === 0) {\n                            metadata.delete(targetMetadata);\n                        }\n                    }\n                }\n                return true;\n            }\n        }\n        function CreateFallbackProvider(reflect) {\n            var defineMetadata = reflect.defineMetadata, hasOwnMetadata = reflect.hasOwnMetadata, getOwnMetadata = reflect.getOwnMetadata, getOwnMetadataKeys = reflect.getOwnMetadataKeys, deleteMetadata = reflect.deleteMetadata;\n            var metadataOwner = new _WeakMap();\n            var provider = {\n                isProviderFor: function(O, P) {\n                    var metadataPropertySet = metadataOwner.get(O);\n                    if (!IsUndefined(metadataPropertySet)) {\n                        return metadataPropertySet.has(P);\n                    }\n                    if (getOwnMetadataKeys(O, P).length) {\n                        if (IsUndefined(metadataPropertySet)) {\n                            metadataPropertySet = new _Set();\n                            metadataOwner.set(O, metadataPropertySet);\n                        }\n                        metadataPropertySet.add(P);\n                        return true;\n                    }\n                    return false;\n                },\n                OrdinaryDefineOwnMetadata: defineMetadata,\n                OrdinaryHasOwnMetadata: hasOwnMetadata,\n                OrdinaryGetOwnMetadata: getOwnMetadata,\n                OrdinaryOwnMetadataKeys: getOwnMetadataKeys,\n                OrdinaryDeleteMetadata: deleteMetadata\n            };\n            return provider;\n        }\n        /**\n         * Gets the metadata provider for an object. If the object has no metadata provider and this is for a create operation,\n         * then this module's metadata provider is assigned to the object.\n         */ function GetMetadataProvider(O, P, Create) {\n            var registeredProvider = metadataRegistry.getProvider(O, P);\n            if (!IsUndefined(registeredProvider)) {\n                return registeredProvider;\n            }\n            if (Create) {\n                if (metadataRegistry.setProvider(O, P, metadataProvider)) {\n                    return metadataProvider;\n                }\n                throw new Error(\"Illegal state.\");\n            }\n            return undefined;\n        }\n        // naive Map shim\n        function CreateMapPolyfill() {\n            var cacheSentinel = {};\n            var arraySentinel = [];\n            var MapIterator = /** @class */ function() {\n                function MapIterator(keys, values, selector) {\n                    this._index = 0;\n                    this._keys = keys;\n                    this._values = values;\n                    this._selector = selector;\n                }\n                MapIterator.prototype[\"@@iterator\"] = function() {\n                    return this;\n                };\n                MapIterator.prototype[iteratorSymbol] = function() {\n                    return this;\n                };\n                MapIterator.prototype.next = function() {\n                    var index = this._index;\n                    if (index >= 0 && index < this._keys.length) {\n                        var result = this._selector(this._keys[index], this._values[index]);\n                        if (index + 1 >= this._keys.length) {\n                            this._index = -1;\n                            this._keys = arraySentinel;\n                            this._values = arraySentinel;\n                        } else {\n                            this._index++;\n                        }\n                        return {\n                            value: result,\n                            done: false\n                        };\n                    }\n                    return {\n                        value: undefined,\n                        done: true\n                    };\n                };\n                MapIterator.prototype.throw = function(error) {\n                    if (this._index >= 0) {\n                        this._index = -1;\n                        this._keys = arraySentinel;\n                        this._values = arraySentinel;\n                    }\n                    throw error;\n                };\n                MapIterator.prototype.return = function(value) {\n                    if (this._index >= 0) {\n                        this._index = -1;\n                        this._keys = arraySentinel;\n                        this._values = arraySentinel;\n                    }\n                    return {\n                        value: value,\n                        done: true\n                    };\n                };\n                return MapIterator;\n            }();\n            var Map1 = /** @class */ function() {\n                function Map1() {\n                    this._keys = [];\n                    this._values = [];\n                    this._cacheKey = cacheSentinel;\n                    this._cacheIndex = -2;\n                }\n                Object.defineProperty(Map1.prototype, \"size\", {\n                    get: function() {\n                        return this._keys.length;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Map1.prototype.has = function(key) {\n                    return this._find(key, /*insert*/ false) >= 0;\n                };\n                Map1.prototype.get = function(key) {\n                    var index = this._find(key, /*insert*/ false);\n                    return index >= 0 ? this._values[index] : undefined;\n                };\n                Map1.prototype.set = function(key, value) {\n                    var index = this._find(key, /*insert*/ true);\n                    this._values[index] = value;\n                    return this;\n                };\n                Map1.prototype.delete = function(key) {\n                    var index = this._find(key, /*insert*/ false);\n                    if (index >= 0) {\n                        var size = this._keys.length;\n                        for(var i = index + 1; i < size; i++){\n                            this._keys[i - 1] = this._keys[i];\n                            this._values[i - 1] = this._values[i];\n                        }\n                        this._keys.length--;\n                        this._values.length--;\n                        if (SameValueZero(key, this._cacheKey)) {\n                            this._cacheKey = cacheSentinel;\n                            this._cacheIndex = -2;\n                        }\n                        return true;\n                    }\n                    return false;\n                };\n                Map1.prototype.clear = function() {\n                    this._keys.length = 0;\n                    this._values.length = 0;\n                    this._cacheKey = cacheSentinel;\n                    this._cacheIndex = -2;\n                };\n                Map1.prototype.keys = function() {\n                    return new MapIterator(this._keys, this._values, getKey);\n                };\n                Map1.prototype.values = function() {\n                    return new MapIterator(this._keys, this._values, getValue);\n                };\n                Map1.prototype.entries = function() {\n                    return new MapIterator(this._keys, this._values, getEntry);\n                };\n                Map1.prototype[\"@@iterator\"] = function() {\n                    return this.entries();\n                };\n                Map1.prototype[iteratorSymbol] = function() {\n                    return this.entries();\n                };\n                Map1.prototype._find = function(key, insert) {\n                    if (!SameValueZero(this._cacheKey, key)) {\n                        this._cacheIndex = -1;\n                        for(var i = 0; i < this._keys.length; i++){\n                            if (SameValueZero(this._keys[i], key)) {\n                                this._cacheIndex = i;\n                                break;\n                            }\n                        }\n                    }\n                    if (this._cacheIndex < 0 && insert) {\n                        this._cacheIndex = this._keys.length;\n                        this._keys.push(key);\n                        this._values.push(undefined);\n                    }\n                    return this._cacheIndex;\n                };\n                return Map1;\n            }();\n            return Map1;\n            function getKey(key, _) {\n                return key;\n            }\n            function getValue(_, value) {\n                return value;\n            }\n            function getEntry(key, value) {\n                return [\n                    key,\n                    value\n                ];\n            }\n        }\n        // naive Set shim\n        function CreateSetPolyfill() {\n            var Set1 = /** @class */ function() {\n                function Set1() {\n                    this._map = new _Map();\n                }\n                Object.defineProperty(Set1.prototype, \"size\", {\n                    get: function() {\n                        return this._map.size;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Set1.prototype.has = function(value) {\n                    return this._map.has(value);\n                };\n                Set1.prototype.add = function(value) {\n                    return this._map.set(value, value), this;\n                };\n                Set1.prototype.delete = function(value) {\n                    return this._map.delete(value);\n                };\n                Set1.prototype.clear = function() {\n                    this._map.clear();\n                };\n                Set1.prototype.keys = function() {\n                    return this._map.keys();\n                };\n                Set1.prototype.values = function() {\n                    return this._map.keys();\n                };\n                Set1.prototype.entries = function() {\n                    return this._map.entries();\n                };\n                Set1.prototype[\"@@iterator\"] = function() {\n                    return this.keys();\n                };\n                Set1.prototype[iteratorSymbol] = function() {\n                    return this.keys();\n                };\n                return Set1;\n            }();\n            return Set1;\n        }\n        // naive WeakMap shim\n        function CreateWeakMapPolyfill() {\n            var UUID_SIZE = 16;\n            var keys = HashMap.create();\n            var rootKey = CreateUniqueKey();\n            return /** @class */ function() {\n                function WeakMap1() {\n                    this._key = CreateUniqueKey();\n                }\n                WeakMap1.prototype.has = function(target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? HashMap.has(table, this._key) : false;\n                };\n                WeakMap1.prototype.get = function(target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? HashMap.get(table, this._key) : undefined;\n                };\n                WeakMap1.prototype.set = function(target, value) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);\n                    table[this._key] = value;\n                    return this;\n                };\n                WeakMap1.prototype.delete = function(target) {\n                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);\n                    return table !== undefined ? delete table[this._key] : false;\n                };\n                WeakMap1.prototype.clear = function() {\n                    // NOTE: not a real clear, just makes the previous data unreachable\n                    this._key = CreateUniqueKey();\n                };\n                return WeakMap1;\n            }();\n            function CreateUniqueKey() {\n                var key;\n                do key = \"@@WeakMap@@\" + CreateUUID();\n                while (HashMap.has(keys, key));\n                keys[key] = true;\n                return key;\n            }\n            function GetOrCreateWeakMapTable(target, create) {\n                if (!hasOwn.call(target, rootKey)) {\n                    if (!create) return undefined;\n                    Object.defineProperty(target, rootKey, {\n                        value: HashMap.create()\n                    });\n                }\n                return target[rootKey];\n            }\n            function FillRandomBytes(buffer, size) {\n                for(var i = 0; i < size; ++i)buffer[i] = Math.random() * 0xff | 0;\n                return buffer;\n            }\n            function GenRandomBytes(size) {\n                if (typeof Uint8Array === \"function\") {\n                    if (typeof crypto !== \"undefined\") return crypto.getRandomValues(new Uint8Array(size));\n                    if (typeof msCrypto !== \"undefined\") return msCrypto.getRandomValues(new Uint8Array(size));\n                    return FillRandomBytes(new Uint8Array(size), size);\n                }\n                return FillRandomBytes(new Array(size), size);\n            }\n            function CreateUUID() {\n                var data = GenRandomBytes(UUID_SIZE);\n                // mark as random - RFC 4122 § 4.4\n                data[6] = data[6] & 0x4f | 0x40;\n                data[8] = data[8] & 0xbf | 0x80;\n                var result = \"\";\n                for(var offset = 0; offset < UUID_SIZE; ++offset){\n                    var byte = data[offset];\n                    if (offset === 4 || offset === 6 || offset === 8) result += \"-\";\n                    if (byte < 16) result += \"0\";\n                    result += byte.toString(16).toLowerCase();\n                }\n                return result;\n            }\n        }\n        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.\n        function MakeDictionary(obj) {\n            obj.__ = undefined;\n            delete obj.__;\n            return obj;\n        }\n    });\n})(Reflect || (Reflect = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9teS1hcHAvLi9ub2RlX21vZHVsZXMvcmVmbGVjdC1tZXRhZGF0YS9SZWZsZWN0LmpzPzYwNzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5Db3B5cmlnaHQgKEMpIE1pY3Jvc29mdC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxuXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG52YXIgUmVmbGVjdDtcbihmdW5jdGlvbiAoUmVmbGVjdCkge1xuICAgIC8vIE1ldGFkYXRhIFByb3Bvc2FsXG4gICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS9cbiAgICAoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICAgICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbFRoaXMgOlxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6XG4gICAgICAgICAgICAgICAgdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDpcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3BweU1vZGVUaGlzKCk7XG4gICAgICAgIHZhciBleHBvcnRlciA9IG1ha2VFeHBvcnRlcihSZWZsZWN0KTtcbiAgICAgICAgaWYgKHR5cGVvZiByb290LlJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGV4cG9ydGVyID0gbWFrZUV4cG9ydGVyKHJvb3QuUmVmbGVjdCwgZXhwb3J0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZhY3RvcnkoZXhwb3J0ZXIsIHJvb3QpO1xuICAgICAgICBpZiAodHlwZW9mIHJvb3QuUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcm9vdC5SZWZsZWN0ID0gUmVmbGVjdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlRXhwb3J0ZXIodGFyZ2V0LCBwcmV2aW91cykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXMpXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmdW5jdGlvblRoaXMoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbihcInJldHVybiB0aGlzO1wiKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGluZGlyZWN0RXZhbFRoaXMoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodm9pZCAwLCBldmFsKShcIihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pKClcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2xvcHB5TW9kZVRoaXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25UaGlzKCkgfHwgaW5kaXJlY3RFdmFsVGhpcygpO1xuICAgICAgICB9XG4gICAgfSkoZnVuY3Rpb24gKGV4cG9ydGVyLCByb290KSB7XG4gICAgICAgIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICAgICAgICAvLyBmZWF0dXJlIHRlc3QgZm9yIFN5bWJvbCBzdXBwb3J0XG4gICAgICAgIHZhciBzdXBwb3J0c1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgdmFyIHRvUHJpbWl0aXZlU3ltYm9sID0gc3VwcG9ydHNTeW1ib2wgJiYgdHlwZW9mIFN5bWJvbC50b1ByaW1pdGl2ZSAhPT0gXCJ1bmRlZmluZWRcIiA/IFN5bWJvbC50b1ByaW1pdGl2ZSA6IFwiQEB0b1ByaW1pdGl2ZVwiO1xuICAgICAgICB2YXIgaXRlcmF0b3JTeW1ib2wgPSBzdXBwb3J0c1N5bWJvbCAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yICE9PSBcInVuZGVmaW5lZFwiID8gU3ltYm9sLml0ZXJhdG9yIDogXCJAQGl0ZXJhdG9yXCI7XG4gICAgICAgIHZhciBzdXBwb3J0c0NyZWF0ZSA9IHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCI7IC8vIGZlYXR1cmUgdGVzdCBmb3IgT2JqZWN0LmNyZWF0ZSBzdXBwb3J0XG4gICAgICAgIHZhciBzdXBwb3J0c1Byb3RvID0geyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheTsgLy8gZmVhdHVyZSB0ZXN0IGZvciBfX3Byb3RvX18gc3VwcG9ydFxuICAgICAgICB2YXIgZG93bkxldmVsID0gIXN1cHBvcnRzQ3JlYXRlICYmICFzdXBwb3J0c1Byb3RvO1xuICAgICAgICB2YXIgSGFzaE1hcCA9IHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhbiBvYmplY3QgaW4gZGljdGlvbmFyeSBtb2RlIChhLmsuYS4gXCJzbG93XCIgbW9kZSBpbiB2OClcbiAgICAgICAgICAgIGNyZWF0ZTogc3VwcG9ydHNDcmVhdGVcbiAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1ha2VEaWN0aW9uYXJ5KE9iamVjdC5jcmVhdGUobnVsbCkpOyB9XG4gICAgICAgICAgICAgICAgOiBzdXBwb3J0c1Byb3RvXG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWFrZURpY3Rpb25hcnkoeyBfX3Byb3RvX186IG51bGwgfSk7IH1cbiAgICAgICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNYWtlRGljdGlvbmFyeSh7fSk7IH0sXG4gICAgICAgICAgICBoYXM6IGRvd25MZXZlbFxuICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKG1hcCwga2V5KSB7IHJldHVybiBoYXNPd24uY2FsbChtYXAsIGtleSk7IH1cbiAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uIChtYXAsIGtleSkgeyByZXR1cm4ga2V5IGluIG1hcDsgfSxcbiAgICAgICAgICAgIGdldDogZG93bkxldmVsXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIGhhc093bi5jYWxsKG1hcCwga2V5KSA/IG1hcFtrZXldIDogdW5kZWZpbmVkOyB9XG4gICAgICAgICAgICAgICAgOiBmdW5jdGlvbiAobWFwLCBrZXkpIHsgcmV0dXJuIG1hcFtrZXldOyB9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBMb2FkIGdsb2JhbCBvciBzaGltIHZlcnNpb25zIG9mIE1hcCwgU2V0LCBhbmQgV2Vha01hcFxuICAgICAgICB2YXIgZnVuY3Rpb25Qcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRnVuY3Rpb24pO1xuICAgICAgICB2YXIgX01hcCA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgTWFwLnByb3RvdHlwZS5lbnRyaWVzID09PSBcImZ1bmN0aW9uXCIgPyBNYXAgOiBDcmVhdGVNYXBQb2x5ZmlsbCgpO1xuICAgICAgICB2YXIgX1NldCA9IHR5cGVvZiBTZXQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5lbnRyaWVzID09PSBcImZ1bmN0aW9uXCIgPyBTZXQgOiBDcmVhdGVTZXRQb2x5ZmlsbCgpO1xuICAgICAgICB2YXIgX1dlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gXCJmdW5jdGlvblwiID8gV2Vha01hcCA6IENyZWF0ZVdlYWtNYXBQb2x5ZmlsbCgpO1xuICAgICAgICB2YXIgcmVnaXN0cnlTeW1ib2wgPSBzdXBwb3J0c1N5bWJvbCA/IFN5bWJvbC5mb3IoXCJAcmVmbGVjdC1tZXRhZGF0YTpyZWdpc3RyeVwiKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIG1ldGFkYXRhUmVnaXN0cnkgPSBHZXRPckNyZWF0ZU1ldGFkYXRhUmVnaXN0cnkoKTtcbiAgICAgICAgdmFyIG1ldGFkYXRhUHJvdmlkZXIgPSBDcmVhdGVNZXRhZGF0YVByb3ZpZGVyKG1ldGFkYXRhUmVnaXN0cnkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbGllcyBhIHNldCBvZiBkZWNvcmF0b3JzIHRvIGEgcHJvcGVydHkgb2YgYSB0YXJnZXQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0gZGVjb3JhdG9ycyBBbiBhcnJheSBvZiBkZWNvcmF0b3JzLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IHRvIGRlY29yYXRlLlxuICAgICAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGZvciB0aGUgdGFyZ2V0IGtleS5cbiAgICAgICAgICogQHJlbWFya3MgRGVjb3JhdG9ycyBhcmUgYXBwbGllZCBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICBFeGFtcGxlID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzQXJyYXksIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiLFxuICAgICAgICAgKiAgICAgICAgIFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9yc0FycmF5LCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiLFxuICAgICAgICAgKiAgICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpKSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIixcbiAgICAgICAgICogICAgICAgICBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnNBcnJheSwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIsXG4gICAgICAgICAqICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpKSk7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIHByb3BlcnR5S2V5LCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSkge1xuICAgICAgICAgICAgICAgIGlmICghSXNBcnJheShkZWNvcmF0b3JzKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QoYXR0cmlidXRlcykgJiYgIUlzVW5kZWZpbmVkKGF0dHJpYnV0ZXMpICYmICFJc051bGwoYXR0cmlidXRlcykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoSXNOdWxsKGF0dHJpYnV0ZXMpKVxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRlUHJvcGVydHkoZGVjb3JhdG9ycywgdGFyZ2V0LCBwcm9wZXJ0eUtleSwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIUlzQXJyYXkoZGVjb3JhdG9ycykpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICBpZiAoIUlzQ29uc3RydWN0b3IodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0ZUNvbnN0cnVjdG9yKGRlY29yYXRvcnMsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJkZWNvcmF0ZVwiLCBkZWNvcmF0ZSk7XG4gICAgICAgIC8vIDQuMS4yIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI3JlZmxlY3QubWV0YWRhdGFcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZGVmYXVsdCBtZXRhZGF0YSBkZWNvcmF0b3IgZmFjdG9yeSB0aGF0IGNhbiBiZSB1c2VkIG9uIGEgY2xhc3MsIGNsYXNzIG1lbWJlciwgb3IgcGFyYW1ldGVyLlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgVGhlIGtleSBmb3IgdGhlIG1ldGFkYXRhIGVudHJ5LlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFWYWx1ZSBUaGUgdmFsdWUgZm9yIHRoZSBtZXRhZGF0YSBlbnRyeS5cbiAgICAgICAgICogQHJldHVybnMgQSBkZWNvcmF0b3IgZnVuY3Rpb24uXG4gICAgICAgICAqIEByZW1hcmtzXG4gICAgICAgICAqIElmIGBtZXRhZGF0YUtleWAgaXMgYWxyZWFkeSBkZWZpbmVkIGZvciB0aGUgdGFyZ2V0IGFuZCB0YXJnZXQga2V5LCB0aGVcbiAgICAgICAgICogbWV0YWRhdGFWYWx1ZSBmb3IgdGhhdCBrZXkgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IsIFR5cGVTY3JpcHQgb25seSlcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIEBSZWZsZWN0Lm1ldGFkYXRhKGtleSwgdmFsdWUpXG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSwgVHlwZVNjcmlwdCBvbmx5KVxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcbiAgICAgICAgICogICAgICAgICBwcm9wZXJ0eTtcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICBAUmVmbGVjdC5tZXRhZGF0YShrZXksIHZhbHVlKVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QoKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgQFJlZmxlY3QubWV0YWRhdGEoa2V5LCB2YWx1ZSlcbiAgICAgICAgICogICAgICAgICBtZXRob2QoKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIG1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBkZWNvcmF0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpICYmICFJc1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUsIHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlY29yYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcIm1ldGFkYXRhXCIsIG1ldGFkYXRhKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZSBhIHVuaXF1ZSBtZXRhZGF0YSBlbnRyeSBvbiB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSBtZXRhZGF0YVZhbHVlIEEgdmFsdWUgdGhhdCBjb250YWlucyBhdHRhY2hlZCBtZXRhZGF0YS5cbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0byBkZWZpbmUgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICBSZWZsZWN0LmRlZmluZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgb3B0aW9ucywgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIFJlZmxlY3QuZGVmaW5lTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBvcHRpb25zLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBkZWNvcmF0b3IgZmFjdG9yeSBhcyBtZXRhZGF0YS1wcm9kdWNpbmcgYW5ub3RhdGlvbi5cbiAgICAgICAgICogICAgIGZ1bmN0aW9uIE15QW5ub3RhdGlvbihvcHRpb25zKTogRGVjb3JhdG9yIHtcbiAgICAgICAgICogICAgICAgICByZXR1cm4gKHRhcmdldCwga2V5PykgPT4gUmVmbGVjdC5kZWZpbmVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIG9wdGlvbnMsIHRhcmdldCwga2V5KTtcbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGRlZmluZU1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlLCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImRlZmluZU1ldGFkYXRhXCIsIGRlZmluZU1ldGFkYXRhKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbiBoYXMgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWV0YWRhdGEga2V5IHdhcyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0IG9yIGl0cyBwcm90b3R5cGUgY2hhaW47IG90aGVyd2lzZSwgYGZhbHNlYC5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljUHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuaGFzTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUucHJvdG90eXBlLCBcIm1ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KSB7XG4gICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHRhcmdldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChwcm9wZXJ0eUtleSkpXG4gICAgICAgICAgICAgICAgcHJvcGVydHlLZXkgPSBUb1Byb3BlcnR5S2V5KHByb3BlcnR5S2V5KTtcbiAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUhhc01ldGFkYXRhKG1ldGFkYXRhS2V5LCB0YXJnZXQsIHByb3BlcnR5S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBleHBvcnRlcihcImhhc01ldGFkYXRhXCIsIGhhc01ldGFkYXRhKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHRhcmdldCBvYmplY3QgaGFzIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgZGVmaW5lZC5cbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG1ldGFkYXRhIGtleSB3YXMgZGVmaW5lZCBvbiB0aGUgdGFyZ2V0IG9iamVjdDsgb3RoZXJ3aXNlLCBgZmFsc2VgLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5oYXNPd25NZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0Lmhhc093bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gaGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5SGFzT3duTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwiaGFzT3duTWV0YWRhdGFcIiwgaGFzT3duTWV0YWRhdGEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyB0aGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBtZXRhZGF0YSBrZXkgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcmV0dXJucyBUaGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBtZXRhZGF0YSBrZXkgaWYgZm91bmQ7IG90aGVyd2lzZSwgYHVuZGVmaW5lZGAuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJnZXRNZXRhZGF0YVwiLCBnZXRNZXRhZGF0YSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSB2YWx1ZSBmb3IgdGhlIHByb3ZpZGVkIG1ldGFkYXRhIGtleSBvbiB0aGUgdGFyZ2V0IG9iamVjdC5cbiAgICAgICAgICogQHBhcmFtIG1ldGFkYXRhS2V5IEEga2V5IHVzZWQgdG8gc3RvcmUgYW5kIHJldHJpZXZlIG1ldGFkYXRhLlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcmV0dXJucyBUaGUgbWV0YWRhdGEgdmFsdWUgZm9yIHRoZSBtZXRhZGF0YSBrZXkgaWYgZm91bmQ7IG90aGVyd2lzZSwgYHVuZGVmaW5lZGAuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNNZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGEoXCJjdXN0b206YW5ub3RhdGlvblwiLCBFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJnZXRPd25NZXRhZGF0YVwiLCBnZXRPd25NZXRhZGF0YSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSBrZXlzIGRlZmluZWQgb24gdGhlIHRhcmdldCBvYmplY3Qgb3IgaXRzIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9iamVjdCBvbiB3aGljaCB0aGUgbWV0YWRhdGEgaXMgZGVmaW5lZC5cbiAgICAgICAgICogQHBhcmFtIHByb3BlcnR5S2V5IChPcHRpb25hbCkgVGhlIHByb3BlcnR5IGtleSBmb3IgdGhlIHRhcmdldC5cbiAgICAgICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdW5pcXVlIG1ldGFkYXRhIGtleXMuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqXG4gICAgICAgICAqICAgICBjbGFzcyBFeGFtcGxlIHtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIEVTNiwgdGhvdWdoIHRoZXkgYXJlIHZhbGlkIGluIFR5cGVTY3JpcHQ6XG4gICAgICAgICAqICAgICAgICAgLy8gc3RhdGljIHN0YXRpY1Byb3BlcnR5O1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5O1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgICAgIGNvbnN0cnVjdG9yKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIHN0YXRpYyBzdGF0aWNNZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gY29uc3RydWN0b3JcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0TWV0YWRhdGFLZXlzKEV4YW1wbGUpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLnByb3RvdHlwZSwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE1ldGFkYXRhS2V5cyhFeGFtcGxlLCBcInN0YXRpY01ldGhvZFwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIG1ldGhvZCAob24gcHJvdG90eXBlKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRNZXRhZGF0YUtleXMoRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0TWV0YWRhdGFLZXlzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5TWV0YWRhdGFLZXlzKHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydGVyKFwiZ2V0TWV0YWRhdGFLZXlzXCIsIGdldE1ldGFkYXRhS2V5cyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSB1bmlxdWUgbWV0YWRhdGEga2V5cyBkZWZpbmVkIG9uIHRoZSB0YXJnZXQgb2JqZWN0LlxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2JqZWN0IG9uIHdoaWNoIHRoZSBtZXRhZGF0YSBpcyBkZWZpbmVkLlxuICAgICAgICAgKiBAcGFyYW0gcHJvcGVydHlLZXkgKE9wdGlvbmFsKSBUaGUgcHJvcGVydHkga2V5IGZvciB0aGUgdGFyZ2V0LlxuICAgICAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB1bmlxdWUgbWV0YWRhdGEga2V5cy5cbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIGNsYXNzIEV4YW1wbGUge1xuICAgICAgICAgKiAgICAgICAgIC8vIHByb3BlcnR5IGRlY2xhcmF0aW9ucyBhcmUgbm90IHBhcnQgb2YgRVM2LCB0aG91Z2ggdGhleSBhcmUgdmFsaWQgaW4gVHlwZVNjcmlwdDpcbiAgICAgICAgICogICAgICAgICAvLyBzdGF0aWMgc3RhdGljUHJvcGVydHk7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAgICAgY29uc3RydWN0b3IocCkgeyB9XG4gICAgICAgICAqICAgICAgICAgc3RhdGljIHN0YXRpY01ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgICAgICBtZXRob2QocCkgeyB9XG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBjb25zdHJ1Y3RvclxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5nZXRPd25NZXRhZGF0YUtleXMoRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlLCBcInN0YXRpY1Byb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gcHJvcGVydHkgKG9uIHByb3RvdHlwZSlcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUucHJvdG90eXBlLCBcInByb3BlcnR5XCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBjb25zdHJ1Y3RvcilcbiAgICAgICAgICogICAgIHJlc3VsdCA9IFJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzKEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmdldE93bk1ldGFkYXRhS2V5cyhFeGFtcGxlLnByb3RvdHlwZSwgXCJtZXRob2RcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRPd25NZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlPd25NZXRhZGF0YUtleXModGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJnZXRPd25NZXRhZGF0YUtleXNcIiwgZ2V0T3duTWV0YWRhdGFLZXlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZXMgdGhlIG1ldGFkYXRhIGVudHJ5IGZyb20gdGhlIHRhcmdldCBvYmplY3Qgd2l0aCB0aGUgcHJvdmlkZWQga2V5LlxuICAgICAgICAgKiBAcGFyYW0gbWV0YWRhdGFLZXkgQSBrZXkgdXNlZCB0byBzdG9yZSBhbmQgcmV0cmlldmUgbWV0YWRhdGEuXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvYmplY3Qgb24gd2hpY2ggdGhlIG1ldGFkYXRhIGlzIGRlZmluZWQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9wZXJ0eUtleSAoT3B0aW9uYWwpIFRoZSBwcm9wZXJ0eSBrZXkgZm9yIHRoZSB0YXJnZXQuXG4gICAgICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbWV0YWRhdGEgZW50cnkgd2FzIGZvdW5kIGFuZCBkZWxldGVkOyBvdGhlcndpc2UsIGZhbHNlLlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgY2xhc3MgRXhhbXBsZSB7XG4gICAgICAgICAqICAgICAgICAgLy8gcHJvcGVydHkgZGVjbGFyYXRpb25zIGFyZSBub3QgcGFydCBvZiBFUzYsIHRob3VnaCB0aGV5IGFyZSB2YWxpZCBpbiBUeXBlU2NyaXB0OlxuICAgICAgICAgKiAgICAgICAgIC8vIHN0YXRpYyBzdGF0aWNQcm9wZXJ0eTtcbiAgICAgICAgICogICAgICAgICAvLyBwcm9wZXJ0eTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgICAgICBjb25zdHJ1Y3RvcihwKSB7IH1cbiAgICAgICAgICogICAgICAgICBzdGF0aWMgc3RhdGljTWV0aG9kKHApIHsgfVxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZChwKSB7IH1cbiAgICAgICAgICogICAgIH1cbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBwcm9wZXJ0eSAob24gY29uc3RydWN0b3IpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZSwgXCJzdGF0aWNQcm9wZXJ0eVwiKTtcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIHByb3BlcnR5IChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwicHJvcGVydHlcIik7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBtZXRob2QgKG9uIGNvbnN0cnVjdG9yKVxuICAgICAgICAgKiAgICAgcmVzdWx0ID0gUmVmbGVjdC5kZWxldGVNZXRhZGF0YShcImN1c3RvbTphbm5vdGF0aW9uXCIsIEV4YW1wbGUsIFwic3RhdGljTWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgLy8gbWV0aG9kIChvbiBwcm90b3R5cGUpXG4gICAgICAgICAqICAgICByZXN1bHQgPSBSZWZsZWN0LmRlbGV0ZU1ldGFkYXRhKFwiY3VzdG9tOmFubm90YXRpb25cIiwgRXhhbXBsZS5wcm90b3R5cGUsIFwibWV0aG9kXCIpO1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGVsZXRlTWV0YWRhdGEobWV0YWRhdGFLZXksIHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QodGFyZ2V0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3BlcnR5S2V5KSlcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eUtleSA9IFRvUHJvcGVydHlLZXkocHJvcGVydHlLZXkpO1xuICAgICAgICAgICAgaWYgKCFJc09iamVjdCh0YXJnZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvcGVydHlLZXkpKVxuICAgICAgICAgICAgICAgIHByb3BlcnR5S2V5ID0gVG9Qcm9wZXJ0eUtleShwcm9wZXJ0eUtleSk7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBHZXRNZXRhZGF0YVByb3ZpZGVyKHRhcmdldCwgcHJvcGVydHlLZXksIC8qQ3JlYXRlKi8gZmFsc2UpO1xuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKHByb3ZpZGVyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuT3JkaW5hcnlEZWxldGVNZXRhZGF0YShtZXRhZGF0YUtleSwgdGFyZ2V0LCBwcm9wZXJ0eUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0ZXIoXCJkZWxldGVNZXRhZGF0YVwiLCBkZWxldGVNZXRhZGF0YSk7XG4gICAgICAgIGZ1bmN0aW9uIERlY29yYXRlQ29uc3RydWN0b3IoZGVjb3JhdG9ycywgdGFyZ2V0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0b3IgPSBkZWNvcmF0b3JzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBkZWNvcmF0ZWQgPSBkZWNvcmF0b3IodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKGRlY29yYXRlZCkgJiYgIUlzTnVsbChkZWNvcmF0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNDb25zdHJ1Y3RvcihkZWNvcmF0ZWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBkZWNvcmF0ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBEZWNvcmF0ZVByb3BlcnR5KGRlY29yYXRvcnMsIHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRvciA9IGRlY29yYXRvcnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGRlY29yYXRlZCA9IGRlY29yYXRvcih0YXJnZXQsIHByb3BlcnR5S2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKGRlY29yYXRlZCkgJiYgIUlzTnVsbChkZWNvcmF0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNPYmplY3QoZGVjb3JhdGVkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IGRlY29yYXRlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuMS4xIE9yZGluYXJ5SGFzTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5aGFzbWV0YWRhdGFcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xuICAgICAgICAgICAgdmFyIGhhc093biA9IE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICAgICAgICAgICAgaWYgKGhhc093bilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pO1xuICAgICAgICAgICAgaWYgKCFJc051bGwocGFyZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gT3JkaW5hcnlIYXNNZXRhZGF0YShNZXRhZGF0YUtleSwgcGFyZW50LCBQKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuMi4xIE9yZGluYXJ5SGFzT3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5aGFzb3dubWV0YWRhdGFcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gR2V0TWV0YWRhdGFQcm92aWRlcihPLCBQLCAvKkNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChwcm92aWRlcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIFRvQm9vbGVhbihwcm92aWRlci5PcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4xLjMuMSBPcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWdldG1ldGFkYXRhXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5R2V0TWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApIHtcbiAgICAgICAgICAgIHZhciBoYXNPd24gPSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKTtcbiAgICAgICAgICAgIGlmIChoYXNPd24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IE9yZGluYXJ5R2V0UHJvdG90eXBlT2YoTyk7XG4gICAgICAgICAgICBpZiAoIUlzTnVsbChwYXJlbnQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBPcmRpbmFyeUdldE1ldGFkYXRhKE1ldGFkYXRhS2V5LCBwYXJlbnQsIFApO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuNC4xIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5Z2V0b3dubWV0YWRhdGFcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gR2V0TWV0YWRhdGFQcm92aWRlcihPLCBQLCAvKkNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChwcm92aWRlcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLk9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuMS41LjEgT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUClcbiAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnlkZWZpbmVvd25tZXRhZGF0YVxuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBHZXRNZXRhZGF0YVByb3ZpZGVyKE8sIFAsIC8qQ3JlYXRlKi8gdHJ1ZSk7XG4gICAgICAgICAgICBwcm92aWRlci5PcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLjEuNi4xIE9yZGluYXJ5TWV0YWRhdGFLZXlzKE8sIFApXG4gICAgICAgIC8vIGh0dHBzOi8vcmJ1Y2t0b24uZ2l0aHViLmlvL3JlZmxlY3QtbWV0YWRhdGEvI29yZGluYXJ5bWV0YWRhdGFrZXlzXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5TWV0YWRhdGFLZXlzKE8sIFApIHtcbiAgICAgICAgICAgIHZhciBvd25LZXlzID0gT3JkaW5hcnlPd25NZXRhZGF0YUtleXMoTywgUCk7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gT3JkaW5hcnlHZXRQcm90b3R5cGVPZihPKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG93bktleXM7XG4gICAgICAgICAgICB2YXIgcGFyZW50S2V5cyA9IE9yZGluYXJ5TWV0YWRhdGFLZXlzKHBhcmVudCwgUCk7XG4gICAgICAgICAgICBpZiAocGFyZW50S2V5cy5sZW5ndGggPD0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duS2V5cztcbiAgICAgICAgICAgIGlmIChvd25LZXlzLmxlbmd0aCA8PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRLZXlzO1xuICAgICAgICAgICAgdmFyIHNldCA9IG5ldyBfU2V0KCk7XG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBvd25LZXlzXzEgPSBvd25LZXlzOyBfaSA8IG93bktleXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gb3duS2V5c18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzS2V5ID0gc2V0LmhhcyhrZXkpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldC5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBwYXJlbnRLZXlzXzEgPSBwYXJlbnRLZXlzOyBfYSA8IHBhcmVudEtleXNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gcGFyZW50S2V5c18xW19hXTtcbiAgICAgICAgICAgICAgICB2YXIgaGFzS2V5ID0gc2V0LmhhcyhrZXkpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldC5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4xLjcuMSBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKVxuICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeW93bm1ldGFkYXRha2V5c1xuICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBHZXRNZXRhZGF0YVByb3ZpZGVyKE8sIFAsIC8qY3JlYXRlKi8gZmFsc2UpO1xuICAgICAgICAgICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5PcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKTtcbiAgICAgICAgfVxuICAgICAgICAvLyA2IEVDTUFTY3JpcHQgRGF0YSBUeXAwZXMgYW5kIFZhbHVlc1xuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWRhdGEtdHlwZXMtYW5kLXZhbHVlc1xuICAgICAgICBmdW5jdGlvbiBUeXBlKHgpIHtcbiAgICAgICAgICAgIGlmICh4ID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiAxIC8qIE51bGwgKi87XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOiByZXR1cm4gMCAvKiBVbmRlZmluZWQgKi87XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjogcmV0dXJuIDIgLyogQm9vbGVhbiAqLztcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiAzIC8qIFN0cmluZyAqLztcbiAgICAgICAgICAgICAgICBjYXNlIFwic3ltYm9sXCI6IHJldHVybiA0IC8qIFN5bWJvbCAqLztcbiAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6IHJldHVybiA1IC8qIE51bWJlciAqLztcbiAgICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHJldHVybiB4ID09PSBudWxsID8gMSAvKiBOdWxsICovIDogNiAvKiBPYmplY3QgKi87XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIDYgLyogT2JqZWN0ICovO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIDYuMS4xIFRoZSBVbmRlZmluZWQgVHlwZVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLXVuZGVmaW5lZC10eXBlXG4gICAgICAgIGZ1bmN0aW9uIElzVW5kZWZpbmVkKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4ID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNi4xLjIgVGhlIE51bGwgVHlwZVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzLW51bGwtdHlwZVxuICAgICAgICBmdW5jdGlvbiBJc051bGwoeCkge1xuICAgICAgICAgICAgcmV0dXJuIHggPT09IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNi4xLjUgVGhlIFN5bWJvbCBUeXBlXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMtc3ltYm9sLXR5cGVcbiAgICAgICAgZnVuY3Rpb24gSXNTeW1ib2woeCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIDYuMS43IFRoZSBPYmplY3QgVHlwZVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QtdHlwZVxuICAgICAgICBmdW5jdGlvbiBJc09iamVjdCh4KSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgPyB4ICE9PSBudWxsIDogdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjEgVHlwZSBDb252ZXJzaW9uXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGUtY29udmVyc2lvblxuICAgICAgICAvLyA3LjEuMSBUb1ByaW1pdGl2ZShpbnB1dCBbLCBQcmVmZXJyZWRUeXBlXSlcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbiAgICAgICAgZnVuY3Rpb24gVG9QcmltaXRpdmUoaW5wdXQsIFByZWZlcnJlZFR5cGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoVHlwZShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogVW5kZWZpbmVkICovOiByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIE51bGwgKi86IHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogQm9vbGVhbiAqLzogcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBTdHJpbmcgKi86IHJldHVybiBpbnB1dDtcbiAgICAgICAgICAgICAgICBjYXNlIDQgLyogU3ltYm9sICovOiByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICAgICAgY2FzZSA1IC8qIE51bWJlciAqLzogcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhpbnQgPSBQcmVmZXJyZWRUeXBlID09PSAzIC8qIFN0cmluZyAqLyA/IFwic3RyaW5nXCIgOiBQcmVmZXJyZWRUeXBlID09PSA1IC8qIE51bWJlciAqLyA/IFwibnVtYmVyXCIgOiBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgIHZhciBleG90aWNUb1ByaW0gPSBHZXRNZXRob2QoaW5wdXQsIHRvUHJpbWl0aXZlU3ltYm9sKTtcbiAgICAgICAgICAgIGlmIChleG90aWNUb1ByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBleG90aWNUb1ByaW0uY2FsbChpbnB1dCwgaGludCk7XG4gICAgICAgICAgICAgICAgaWYgKElzT2JqZWN0KHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIGhpbnQgPT09IFwiZGVmYXVsdFwiID8gXCJudW1iZXJcIiA6IGhpbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMS4xLjEgT3JkaW5hcnlUb1ByaW1pdGl2ZShPLCBoaW50KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG4gICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5VG9QcmltaXRpdmUoTywgaGludCkge1xuICAgICAgICAgICAgaWYgKGhpbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9TdHJpbmdfMSA9IE8udG9TdHJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKElzQ2FsbGFibGUodG9TdHJpbmdfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRvU3RyaW5nXzEuY2FsbChPKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlT2YgPSBPLnZhbHVlT2Y7XG4gICAgICAgICAgICAgICAgaWYgKElzQ2FsbGFibGUodmFsdWVPZikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlT2YuY2FsbChPKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVPZiA9IE8udmFsdWVPZjtcbiAgICAgICAgICAgICAgICBpZiAoSXNDYWxsYWJsZSh2YWx1ZU9mKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdmFsdWVPZi5jYWxsKE8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzT2JqZWN0KHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdG9TdHJpbmdfMiA9IE8udG9TdHJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKElzQ2FsbGFibGUodG9TdHJpbmdfMikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRvU3RyaW5nXzIuY2FsbChPKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc09iamVjdChyZXN1bHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4xLjIgVG9Cb29sZWFuKGFyZ3VtZW50KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvMjAxNi8jc2VjLXRvYm9vbGVhblxuICAgICAgICBmdW5jdGlvbiBUb0Jvb2xlYW4oYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWFyZ3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMS4xMiBUb1N0cmluZyhhcmd1bWVudClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9zdHJpbmdcbiAgICAgICAgZnVuY3Rpb24gVG9TdHJpbmcoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgYXJndW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4xLjE0IFRvUHJvcGVydHlLZXkoYXJndW1lbnQpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbiAgICAgICAgZnVuY3Rpb24gVG9Qcm9wZXJ0eUtleShhcmd1bWVudCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IFRvUHJpbWl0aXZlKGFyZ3VtZW50LCAzIC8qIFN0cmluZyAqLyk7XG4gICAgICAgICAgICBpZiAoSXNTeW1ib2woa2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgcmV0dXJuIFRvU3RyaW5nKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNy4yIFRlc3RpbmcgYW5kIENvbXBhcmlzb24gT3BlcmF0aW9uc1xuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10ZXN0aW5nLWFuZC1jb21wYXJpc29uLW9wZXJhdGlvbnNcbiAgICAgICAgLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXNhcnJheVxuICAgICAgICBmdW5jdGlvbiBJc0FycmF5KGFyZ3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheVxuICAgICAgICAgICAgICAgID8gQXJyYXkuaXNBcnJheShhcmd1bWVudClcbiAgICAgICAgICAgICAgICA6IGFyZ3VtZW50IGluc3RhbmNlb2YgT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgID8gYXJndW1lbnQgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICAgICAgICA6IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjIuMyBJc0NhbGxhYmxlKGFyZ3VtZW50KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG4gICAgICAgIGZ1bmN0aW9uIElzQ2FsbGFibGUoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgYW4gYXBwcm94aW1hdGlvbiBhcyB3ZSBjYW5ub3QgY2hlY2sgZm9yIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZC5cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjIuNCBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KVxuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXG4gICAgICAgIGZ1bmN0aW9uIElzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IFRoaXMgaXMgYW4gYXBwcm94aW1hdGlvbiBhcyB3ZSBjYW5ub3QgY2hlY2sgZm9yIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kLlxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuMi43IElzUHJvcGVydHlLZXkoYXJndW1lbnQpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzcHJvcGVydHlrZXlcbiAgICAgICAgZnVuY3Rpb24gSXNQcm9wZXJ0eUtleShhcmd1bWVudCkge1xuICAgICAgICAgICAgc3dpdGNoIChUeXBlKGFyZ3VtZW50KSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMyAvKiBTdHJpbmcgKi86IHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNCAvKiBTeW1ib2wgKi86IHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBTYW1lVmFsdWVaZXJvKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4ID09PSB5IHx8IHggIT09IHggJiYgeSAhPT0geTtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjMgT3BlcmF0aW9ucyBvbiBPYmplY3RzXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9wZXJhdGlvbnMtb24tb2JqZWN0c1xuICAgICAgICAvLyA3LjMuOSBHZXRNZXRob2QoViwgUClcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXG4gICAgICAgIGZ1bmN0aW9uIEdldE1ldGhvZChWLCBQKSB7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IFZbUF07XG4gICAgICAgICAgICBpZiAoZnVuYyA9PT0gdW5kZWZpbmVkIHx8IGZ1bmMgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICghSXNDYWxsYWJsZShmdW5jKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjQgT3BlcmF0aW9ucyBvbiBJdGVyYXRvciBPYmplY3RzXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9wZXJhdGlvbnMtb24taXRlcmF0b3Itb2JqZWN0c1xuICAgICAgICBmdW5jdGlvbiBHZXRJdGVyYXRvcihvYmopIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBHZXRNZXRob2Qob2JqLCBpdGVyYXRvclN5bWJvbCk7XG4gICAgICAgICAgICBpZiAoIUlzQ2FsbGFibGUobWV0aG9kKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IC8vIGZyb20gQ2FsbFxuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gbWV0aG9kLmNhbGwob2JqKTtcbiAgICAgICAgICAgIGlmICghSXNPYmplY3QoaXRlcmF0b3IpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyA3LjQuNCBJdGVyYXRvclZhbHVlKGl0ZXJSZXN1bHQpXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8yMDE2LyNzZWMtaXRlcmF0b3J2YWx1ZVxuICAgICAgICBmdW5jdGlvbiBJdGVyYXRvclZhbHVlKGl0ZXJSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyUmVzdWx0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuNC41IEl0ZXJhdG9yU3RlcChpdGVyYXRvcilcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtaXRlcmF0b3JzdGVwXG4gICAgICAgIGZ1bmN0aW9uIEl0ZXJhdG9yU3RlcChpdGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IGZhbHNlIDogcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWl0ZXJhdG9yY2xvc2VcbiAgICAgICAgZnVuY3Rpb24gSXRlcmF0b3JDbG9zZShpdGVyYXRvcikge1xuICAgICAgICAgICAgdmFyIGYgPSBpdGVyYXRvcltcInJldHVyblwiXTtcbiAgICAgICAgICAgIGlmIChmKVxuICAgICAgICAgICAgICAgIGYuY2FsbChpdGVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gOS4xIE9yZGluYXJ5IE9iamVjdCBJbnRlcm5hbCBNZXRob2RzIGFuZCBJbnRlcm5hbCBTbG90c1xuICAgICAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vcmRpbmFyeS1vYmplY3QtaW50ZXJuYWwtbWV0aG9kcy1hbmQtaW50ZXJuYWwtc2xvdHNcbiAgICAgICAgLy8gOS4xLjEuMSBPcmRpbmFyeUdldFByb3RvdHlwZU9mKE8pXG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9yZGluYXJ5Z2V0cHJvdG90eXBlb2ZcbiAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlHZXRQcm90b3R5cGVPZihPKSB7XG4gICAgICAgICAgICB2YXIgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIE8gIT09IFwiZnVuY3Rpb25cIiB8fCBPID09PSBmdW5jdGlvblByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3Qgc2V0IF9fcHJvdG9fXyBpbiBFUzUsIGFzIGl0J3Mgbm9uLXN0YW5kYXJkLlxuICAgICAgICAgICAgLy8gVHJ5IHRvIGRldGVybWluZSB0aGUgc3VwZXJjbGFzcyBjb25zdHJ1Y3Rvci4gQ29tcGF0aWJsZSBpbXBsZW1lbnRhdGlvbnNcbiAgICAgICAgICAgIC8vIG11c3QgZWl0aGVyIHNldCBfX3Byb3RvX18gb24gYSBzdWJjbGFzcyBjb25zdHJ1Y3RvciB0byB0aGUgc3VwZXJjbGFzcyBjb25zdHJ1Y3RvcixcbiAgICAgICAgICAgIC8vIG9yIGVuc3VyZSBlYWNoIGNsYXNzIGhhcyBhIHZhbGlkIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgb24gaXRzIHByb3RvdHlwZSB0aGF0XG4gICAgICAgICAgICAvLyBwb2ludHMgYmFjayB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBGdW5jdGlvbi5bW1Byb3RvdHlwZV1dLCB0aGVuIHRoaXMgaXMgZGVmaW5hdGVseSBpbmhlcml0ZWQuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZW4gaW4gRVM2IG9yIHdoZW4gdXNpbmcgX19wcm90b19fIGluIGEgY29tcGF0aWJsZSBicm93c2VyLlxuICAgICAgICAgICAgaWYgKHByb3RvICE9PSBmdW5jdGlvblByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgICAgICAvLyBJZiB0aGUgc3VwZXIgcHJvdG90eXBlIGlzIE9iamVjdC5wcm90b3R5cGUsIG51bGwsIG9yIHVuZGVmaW5lZCwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cbiAgICAgICAgICAgIHZhciBwcm90b3R5cGUgPSBPLnByb3RvdHlwZTtcbiAgICAgICAgICAgIHZhciBwcm90b3R5cGVQcm90byA9IHByb3RvdHlwZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKTtcbiAgICAgICAgICAgIGlmIChwcm90b3R5cGVQcm90byA9PSBudWxsIHx8IHByb3RvdHlwZVByb3RvID09PSBPYmplY3QucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm90bztcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb25zdHJ1Y3RvciB3YXMgbm90IGEgZnVuY3Rpb24sIHRoZW4gd2UgY2Fubm90IGRldGVybWluZSB0aGUgaGVyaXRhZ2UuXG4gICAgICAgICAgICB2YXIgY29uc3RydWN0b3IgPSBwcm90b3R5cGVQcm90by5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc3RydWN0b3IgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIHNvbWUga2luZCBvZiBzZWxmLXJlZmVyZW5jZSwgdGhlbiB3ZSBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBoZXJpdGFnZS5cbiAgICAgICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gTylcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdG87XG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGEgcHJldHR5IGdvb2QgZ3Vlc3MgYXQgdGhlIGhlcml0YWdlLlxuICAgICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdsb2JhbCBtZXRhZGF0YSByZWdpc3RyeVxuICAgICAgICAvLyAtIEFsbG93cyBgaW1wb3J0IFwicmVmbGVjdC1tZXRhZGF0YVwiYCBhbmQgYGltcG9ydCBcInJlZmxlY3QtbWV0YWRhdGEvbm8tY29uZmxpY3RcImAgdG8gaW50ZXJvcGVyYXRlLlxuICAgICAgICAvLyAtIFVzZXMgaXNvbGF0ZWQgbWV0YWRhdGEgaWYgYFJlZmxlY3RgIGlzIGZyb3plbiBiZWZvcmUgdGhlIHJlZ2lzdHJ5IGNhbiBiZSBpbnN0YWxsZWQuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcmVnaXN0cnkgdXNlZCB0byBhbGxvdyBtdWx0aXBsZSBgcmVmbGVjdC1tZXRhZGF0YWAgcHJvdmlkZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ3JlYXRlTWV0YWRhdGFSZWdpc3RyeSgpIHtcbiAgICAgICAgICAgIHZhciBmYWxsYmFjaztcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocmVnaXN0cnlTeW1ib2wpICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHJvb3QuUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgICEocmVnaXN0cnlTeW1ib2wgaW4gcm9vdC5SZWZsZWN0KSAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiByb290LlJlZmxlY3QuZGVmaW5lTWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIGludGVyb3BlcmF0ZSB3aXRoIG9sZGVyIHZlcnNpb24gb2YgYHJlZmxlY3QtbWV0YWRhdGFgIHRoYXQgZGlkIG5vdCBzdXBwb3J0IGEgcmVnaXN0cnkuXG4gICAgICAgICAgICAgICAgZmFsbGJhY2sgPSBDcmVhdGVGYWxsYmFja1Byb3ZpZGVyKHJvb3QuUmVmbGVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmlyc3Q7XG4gICAgICAgICAgICB2YXIgc2Vjb25kO1xuICAgICAgICAgICAgdmFyIHJlc3Q7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0UHJvdmlkZXJNYXAgPSBuZXcgX1dlYWtNYXAoKTtcbiAgICAgICAgICAgIHZhciByZWdpc3RyeSA9IHtcbiAgICAgICAgICAgICAgICByZWdpc3RlclByb3ZpZGVyOiByZWdpc3RlclByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIGdldFByb3ZpZGVyOiBnZXRQcm92aWRlcixcbiAgICAgICAgICAgICAgICBzZXRQcm92aWRlcjogc2V0UHJvdmlkZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdHJ5O1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJQcm92aWRlcihwcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LmlzRXh0ZW5zaWJsZShyZWdpc3RyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBwcm92aWRlciB0byBhIGZyb3plbiByZWdpc3RyeS5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGZhbGxiYWNrID09PSBwcm92aWRlcjogYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSXNVbmRlZmluZWQoZmlyc3QpOlxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBwcm92aWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGZpcnN0ID09PSBwcm92aWRlcjogYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSXNVbmRlZmluZWQoc2Vjb25kKTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZCA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2Ugc2Vjb25kID09PSBwcm92aWRlcjogYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QgPSBuZXcgX1NldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdC5hZGQocHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UHJvdmlkZXJOb0NhY2hlKE8sIFApIHtcbiAgICAgICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKGZpcnN0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QuaXNQcm92aWRlckZvcihPLCBQKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaXJzdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChzZWNvbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2Vjb25kLmlzUHJvdmlkZXJGb3IoTywgUCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChyZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IEdldEl0ZXJhdG9yKHJlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gSXRlcmF0b3JTdGVwKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm92aWRlciA9IEl0ZXJhdG9yVmFsdWUobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5pc1Byb3ZpZGVyRm9yKE8sIFApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKGZhbGxiYWNrKSAmJiBmYWxsYmFjay5pc1Byb3ZpZGVyRm9yKE8sIFApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFByb3ZpZGVyKE8sIFApIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXJNYXAgPSB0YXJnZXRQcm92aWRlck1hcC5nZXQoTyk7XG4gICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvdmlkZXJNYXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gcHJvdmlkZXJNYXAuZ2V0KFApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gZ2V0UHJvdmlkZXJOb0NhY2hlKE8sIFApO1xuICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChwcm92aWRlck1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWFwID0gbmV3IF9NYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFByb3ZpZGVyTWFwLnNldChPLCBwcm92aWRlck1hcCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNYXAuc2V0KFAsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gaGFzUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQocHJvdmlkZXIpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0ID09PSBwcm92aWRlciB8fCBzZWNvbmQgPT09IHByb3ZpZGVyIHx8ICFJc1VuZGVmaW5lZChyZXN0KSAmJiByZXN0Lmhhcyhwcm92aWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzZXRQcm92aWRlcihPLCBQLCBwcm92aWRlcikge1xuICAgICAgICAgICAgICAgIGlmICghaGFzUHJvdmlkZXIocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGFkYXRhIHByb3ZpZGVyIG5vdCByZWdpc3RlcmVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nUHJvdmlkZXIgPSBnZXRQcm92aWRlcihPLCBQKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQcm92aWRlciAhPT0gcHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFJc1VuZGVmaW5lZChleGlzdGluZ1Byb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm92aWRlck1hcCA9IHRhcmdldFByb3ZpZGVyTWFwLmdldChPKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKHByb3ZpZGVyTWFwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNYXAgPSBuZXcgX01hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UHJvdmlkZXJNYXAuc2V0KE8sIHByb3ZpZGVyTWFwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1hcC5zZXQoUCwgcHJvdmlkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0cyBvciBjcmVhdGVzIHRoZSBzaGFyZWQgcmVnaXN0cnkgb2YgbWV0YWRhdGEgcHJvdmlkZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gR2V0T3JDcmVhdGVNZXRhZGF0YVJlZ2lzdHJ5KCkge1xuICAgICAgICAgICAgdmFyIG1ldGFkYXRhUmVnaXN0cnk7XG4gICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHJlZ2lzdHJ5U3ltYm9sKSAmJiBJc09iamVjdChyb290LlJlZmxlY3QpICYmIE9iamVjdC5pc0V4dGVuc2libGUocm9vdC5SZWZsZWN0KSkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhUmVnaXN0cnkgPSByb290LlJlZmxlY3RbcmVnaXN0cnlTeW1ib2xdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhUmVnaXN0cnkpKSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGFSZWdpc3RyeSA9IENyZWF0ZU1ldGFkYXRhUmVnaXN0cnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocmVnaXN0cnlTeW1ib2wpICYmIElzT2JqZWN0KHJvb3QuUmVmbGVjdCkgJiYgT2JqZWN0LmlzRXh0ZW5zaWJsZShyb290LlJlZmxlY3QpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJvb3QuUmVmbGVjdCwgcmVnaXN0cnlTeW1ib2wsIHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG1ldGFkYXRhUmVnaXN0cnlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YVJlZ2lzdHJ5O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIENyZWF0ZU1ldGFkYXRhUHJvdmlkZXIocmVnaXN0cnkpIHtcbiAgICAgICAgICAgIC8vIFtbTWV0YWRhdGFdXSBpbnRlcm5hbCBzbG90XG4gICAgICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeS1vYmplY3QtaW50ZXJuYWwtbWV0aG9kcy1hbmQtaW50ZXJuYWwtc2xvdHNcbiAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IG5ldyBfV2Vha01hcCgpO1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0ge1xuICAgICAgICAgICAgICAgIGlzUHJvdmlkZXJGb3I6IGZ1bmN0aW9uIChPLCBQKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRNZXRhZGF0YSA9IG1ldGFkYXRhLmdldChPKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKHRhcmdldE1ldGFkYXRhKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldE1ldGFkYXRhLmhhcyhQKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGE6IE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgT3JkaW5hcnlIYXNPd25NZXRhZGF0YTogT3JkaW5hcnlIYXNPd25NZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBPcmRpbmFyeUdldE93bk1ldGFkYXRhOiBPcmRpbmFyeUdldE93bk1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzOiBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyxcbiAgICAgICAgICAgICAgICBPcmRpbmFyeURlbGV0ZU1ldGFkYXRhOiBPcmRpbmFyeURlbGV0ZU1ldGFkYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1ldGFkYXRhUmVnaXN0cnkucmVnaXN0ZXJQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgICAgICAgICBmdW5jdGlvbiBHZXRPckNyZWF0ZU1ldGFkYXRhTWFwKE8sIFAsIENyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRNZXRhZGF0YSA9IG1ldGFkYXRhLmdldChPKTtcbiAgICAgICAgICAgICAgICB2YXIgY3JlYXRlZFRhcmdldE1ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKHRhcmdldE1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUNyZWF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhID0gbmV3IF9NYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEuc2V0KE8sIHRhcmdldE1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlZFRhcmdldE1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gdGFyZ2V0TWV0YWRhdGEuZ2V0KFApO1xuICAgICAgICAgICAgICAgIGlmIChJc1VuZGVmaW5lZChtZXRhZGF0YU1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFDcmVhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YU1hcCA9IG5ldyBfTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE1ldGFkYXRhLnNldChQLCBtZXRhZGF0YU1hcCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVnaXN0cnkuc2V0UHJvdmlkZXIoTywgUCwgcHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRNZXRhZGF0YS5kZWxldGUoUCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3JlYXRlZFRhcmdldE1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEuZGVsZXRlKE8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgcHJvdmlkZXIgZm9yIHRhcmdldC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhTWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMy4xLjIuMSBPcmRpbmFyeUhhc093bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnloYXNvd25tZXRhZGF0YVxuICAgICAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlIYXNPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTywgUCkge1xuICAgICAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBUb0Jvb2xlYW4obWV0YWRhdGFNYXAuaGFzKE1ldGFkYXRhS2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAzLjEuNC4xIE9yZGluYXJ5R2V0T3duTWV0YWRhdGEoTWV0YWRhdGFLZXksIE8sIFApXG4gICAgICAgICAgICAvLyBodHRwczovL3JidWNrdG9uLmdpdGh1Yi5pby9yZWZsZWN0LW1ldGFkYXRhLyNvcmRpbmFyeWdldG93bm1ldGFkYXRhXG4gICAgICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeUdldE93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKkNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YU1hcC5nZXQoTWV0YWRhdGFLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMy4xLjUuMSBPcmRpbmFyeURlZmluZU93bk1ldGFkYXRhKE1ldGFkYXRhS2V5LCBNZXRhZGF0YVZhbHVlLCBPLCBQKVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnlkZWZpbmVvd25tZXRhZGF0YVxuICAgICAgICAgICAgZnVuY3Rpb24gT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YShNZXRhZGF0YUtleSwgTWV0YWRhdGFWYWx1ZSwgTywgUCkge1xuICAgICAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YU1hcC5zZXQoTWV0YWRhdGFLZXksIE1ldGFkYXRhVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMy4xLjcuMSBPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyhPLCBQKVxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9yYnVja3Rvbi5naXRodWIuaW8vcmVmbGVjdC1tZXRhZGF0YS8jb3JkaW5hcnlvd25tZXRhZGF0YWtleXNcbiAgICAgICAgICAgIGZ1bmN0aW9uIE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzKE8sIFApIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBtZXRhZGF0YU1hcCA9IEdldE9yQ3JlYXRlTWV0YWRhdGFNYXAoTywgUCwgLypDcmVhdGUqLyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhTWFwKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgICAgICAgICAgdmFyIGtleXNPYmogPSBtZXRhZGF0YU1hcC5rZXlzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gR2V0SXRlcmF0b3Ioa2V5c09iaik7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gSXRlcmF0b3JTdGVwKGl0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzLmxlbmd0aCA9IGs7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFZhbHVlID0gSXRlcmF0b3JWYWx1ZShuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXNba10gPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSXRlcmF0b3JDbG9zZShpdGVyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBPcmRpbmFyeURlbGV0ZU1ldGFkYXRhKE1ldGFkYXRhS2V5LCBPLCBQKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1ldGFkYXRhTWFwID0gR2V0T3JDcmVhdGVNZXRhZGF0YU1hcChPLCBQLCAvKkNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoSXNVbmRlZmluZWQobWV0YWRhdGFNYXApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFtZXRhZGF0YU1hcC5kZWxldGUoTWV0YWRhdGFLZXkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhTWFwLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldE1ldGFkYXRhID0gbWV0YWRhdGEuZ2V0KE8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUlzVW5kZWZpbmVkKHRhcmdldE1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0TWV0YWRhdGEuZGVsZXRlKFApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldE1ldGFkYXRhLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YS5kZWxldGUodGFyZ2V0TWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIENyZWF0ZUZhbGxiYWNrUHJvdmlkZXIocmVmbGVjdCkge1xuICAgICAgICAgICAgdmFyIGRlZmluZU1ldGFkYXRhID0gcmVmbGVjdC5kZWZpbmVNZXRhZGF0YSwgaGFzT3duTWV0YWRhdGEgPSByZWZsZWN0Lmhhc093bk1ldGFkYXRhLCBnZXRPd25NZXRhZGF0YSA9IHJlZmxlY3QuZ2V0T3duTWV0YWRhdGEsIGdldE93bk1ldGFkYXRhS2V5cyA9IHJlZmxlY3QuZ2V0T3duTWV0YWRhdGFLZXlzLCBkZWxldGVNZXRhZGF0YSA9IHJlZmxlY3QuZGVsZXRlTWV0YWRhdGE7XG4gICAgICAgICAgICB2YXIgbWV0YWRhdGFPd25lciA9IG5ldyBfV2Vha01hcCgpO1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0ge1xuICAgICAgICAgICAgICAgIGlzUHJvdmlkZXJGb3I6IGZ1bmN0aW9uIChPLCBQKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRhZGF0YVByb3BlcnR5U2V0ID0gbWV0YWRhdGFPd25lci5nZXQoTyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQobWV0YWRhdGFQcm9wZXJ0eVNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YVByb3BlcnR5U2V0LmhhcyhQKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0T3duTWV0YWRhdGFLZXlzKE8sIFApLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKElzVW5kZWZpbmVkKG1ldGFkYXRhUHJvcGVydHlTZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFQcm9wZXJ0eVNldCA9IG5ldyBfU2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFPd25lci5zZXQoTywgbWV0YWRhdGFQcm9wZXJ0eVNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YVByb3BlcnR5U2V0LmFkZChQKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIE9yZGluYXJ5RGVmaW5lT3duTWV0YWRhdGE6IGRlZmluZU1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIE9yZGluYXJ5SGFzT3duTWV0YWRhdGE6IGhhc093bk1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIE9yZGluYXJ5R2V0T3duTWV0YWRhdGE6IGdldE93bk1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIE9yZGluYXJ5T3duTWV0YWRhdGFLZXlzOiBnZXRPd25NZXRhZGF0YUtleXMsXG4gICAgICAgICAgICAgICAgT3JkaW5hcnlEZWxldGVNZXRhZGF0YTogZGVsZXRlTWV0YWRhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBtZXRhZGF0YSBwcm92aWRlciBmb3IgYW4gb2JqZWN0LiBJZiB0aGUgb2JqZWN0IGhhcyBubyBtZXRhZGF0YSBwcm92aWRlciBhbmQgdGhpcyBpcyBmb3IgYSBjcmVhdGUgb3BlcmF0aW9uLFxuICAgICAgICAgKiB0aGVuIHRoaXMgbW9kdWxlJ3MgbWV0YWRhdGEgcHJvdmlkZXIgaXMgYXNzaWduZWQgdG8gdGhlIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEdldE1ldGFkYXRhUHJvdmlkZXIoTywgUCwgQ3JlYXRlKSB7XG4gICAgICAgICAgICB2YXIgcmVnaXN0ZXJlZFByb3ZpZGVyID0gbWV0YWRhdGFSZWdpc3RyeS5nZXRQcm92aWRlcihPLCBQKTtcbiAgICAgICAgICAgIGlmICghSXNVbmRlZmluZWQocmVnaXN0ZXJlZFByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWdpc3RlcmVkUHJvdmlkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQ3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhUmVnaXN0cnkuc2V0UHJvdmlkZXIoTywgUCwgbWV0YWRhdGFQcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhUHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBuYWl2ZSBNYXAgc2hpbVxuICAgICAgICBmdW5jdGlvbiBDcmVhdGVNYXBQb2x5ZmlsbCgpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZVNlbnRpbmVsID0ge307XG4gICAgICAgICAgICB2YXIgYXJyYXlTZW50aW5lbCA9IFtdO1xuICAgICAgICAgICAgdmFyIE1hcEl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE1hcEl0ZXJhdG9yKGtleXMsIHZhbHVlcywgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGVbXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbiAgICAgICAgICAgICAgICBNYXBJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5faW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9zZWxlY3Rvcih0aGlzLl9rZXlzW2luZGV4XSwgdGhpcy5fdmFsdWVzW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggKyAxID49IHRoaXMuX2tleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gYXJyYXlTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IGFycmF5U2VudGluZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgTWFwSXRlcmF0b3IucHJvdG90eXBlLnJldHVybiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBhcnJheVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzID0gYXJyYXlTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXBJdGVyYXRvcjtcbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICB2YXIgTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIE1hcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXkgPSBjYWNoZVNlbnRpbmVsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gLTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXAucHJvdG90eXBlLCBcInNpemVcIiwge1xuICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2tleXMubGVuZ3RoOyB9LFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHRoaXMuX2ZpbmQoa2V5LCAvKmluc2VydCovIGZhbHNlKSA+PSAwOyB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9maW5kKGtleSwgLyppbnNlcnQqLyBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA+PSAwID8gdGhpcy5fdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZChrZXksIC8qaW5zZXJ0Ki8gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLl9rZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpbmRleCArIDE7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzW2kgLSAxXSA9IHRoaXMuX2tleXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzW2kgLSAxXSA9IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMubGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoU2FtZVZhbHVlWmVybyhrZXksIHRoaXMuX2NhY2hlS2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5ID0gY2FjaGVTZW50aW5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gLTI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUtleSA9IGNhY2hlU2VudGluZWw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSAtMjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcih0aGlzLl9rZXlzLCB0aGlzLl92YWx1ZXMsIGdldEtleSk7IH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWFwSXRlcmF0b3IodGhpcy5fa2V5cywgdGhpcy5fdmFsdWVzLCBnZXRWYWx1ZSk7IH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IE1hcEl0ZXJhdG9yKHRoaXMuX2tleXMsIHRoaXMuX3ZhbHVlcywgZ2V0RW50cnkpOyB9O1xuICAgICAgICAgICAgICAgIE1hcC5wcm90b3R5cGVbXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5lbnRyaWVzKCk7IH07XG4gICAgICAgICAgICAgICAgTWFwLnByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmVudHJpZXMoKTsgfTtcbiAgICAgICAgICAgICAgICBNYXAucHJvdG90eXBlLl9maW5kID0gZnVuY3Rpb24gKGtleSwgaW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghU2FtZVZhbHVlWmVybyh0aGlzLl9jYWNoZUtleSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9rZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFNhbWVWYWx1ZVplcm8odGhpcy5fa2V5c1tpXSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZUluZGV4IDwgMCAmJiBpbnNlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlSW5kZXggPSB0aGlzLl9rZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVJbmRleDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXA7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgcmV0dXJuIE1hcDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldEtleShrZXksIF8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUoXywgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRFbnRyeShrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBuYWl2ZSBTZXQgc2hpbVxuICAgICAgICBmdW5jdGlvbiBDcmVhdGVTZXRQb2x5ZmlsbCgpIHtcbiAgICAgICAgICAgIHZhciBTZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gU2V0KCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAgPSBuZXcgX01hcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2V0LnByb3RvdHlwZSwgXCJzaXplXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAuc2l6ZTsgfSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuX21hcC5oYXModmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0aGlzLl9tYXAuc2V0KHZhbHVlLCB2YWx1ZSksIHRoaXM7IH07XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHRoaXMuX21hcC5kZWxldGUodmFsdWUpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX21hcC5jbGVhcigpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcC5rZXlzKCk7IH07XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXAua2V5cygpOyB9O1xuICAgICAgICAgICAgICAgIFNldC5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21hcC5lbnRyaWVzKCk7IH07XG4gICAgICAgICAgICAgICAgU2V0LnByb3RvdHlwZVtcIkBAaXRlcmF0b3JcIl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmtleXMoKTsgfTtcbiAgICAgICAgICAgICAgICBTZXQucHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5cygpOyB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBTZXQ7XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgcmV0dXJuIFNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBuYWl2ZSBXZWFrTWFwIHNoaW1cbiAgICAgICAgZnVuY3Rpb24gQ3JlYXRlV2Vha01hcFBvbHlmaWxsKCkge1xuICAgICAgICAgICAgdmFyIFVVSURfU0laRSA9IDE2O1xuICAgICAgICAgICAgdmFyIGtleXMgPSBIYXNoTWFwLmNyZWF0ZSgpO1xuICAgICAgICAgICAgdmFyIHJvb3RLZXkgPSBDcmVhdGVVbmlxdWVLZXkoKTtcbiAgICAgICAgICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5ID0gQ3JlYXRlVW5pcXVlS2V5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFdlYWtNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlICE9PSB1bmRlZmluZWQgPyBIYXNoTWFwLmhhcyh0YWJsZSwgdGhpcy5fa2V5KSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIC8qY3JlYXRlKi8gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUgIT09IHVuZGVmaW5lZCA/IEhhc2hNYXAuZ2V0KHRhYmxlLCB0aGlzLl9rZXkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCAvKmNyZWF0ZSovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0YWJsZVt0aGlzLl9rZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgV2Vha01hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBHZXRPckNyZWF0ZVdlYWtNYXBUYWJsZSh0YXJnZXQsIC8qY3JlYXRlKi8gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGUgIT09IHVuZGVmaW5lZCA/IGRlbGV0ZSB0YWJsZVt0aGlzLl9rZXldIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBXZWFrTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogbm90IGEgcmVhbCBjbGVhciwganVzdCBtYWtlcyB0aGUgcHJldmlvdXMgZGF0YSB1bnJlYWNoYWJsZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9rZXkgPSBDcmVhdGVVbmlxdWVLZXkoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBXZWFrTWFwO1xuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIENyZWF0ZVVuaXF1ZUtleSgpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgICAgICAgIGtleSA9IFwiQEBXZWFrTWFwQEBcIiArIENyZWF0ZVVVSUQoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoSGFzaE1hcC5oYXMoa2V5cywga2V5KSk7XG4gICAgICAgICAgICAgICAga2V5c1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gR2V0T3JDcmVhdGVXZWFrTWFwVGFibGUodGFyZ2V0LCBjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc093bi5jYWxsKHRhcmdldCwgcm9vdEtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjcmVhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCByb290S2V5LCB7IHZhbHVlOiBIYXNoTWFwLmNyZWF0ZSgpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Jvb3RLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gRmlsbFJhbmRvbUJ5dGVzKGJ1ZmZlciwgc2l6ZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKVxuICAgICAgICAgICAgICAgICAgICBidWZmZXJbaV0gPSBNYXRoLnJhbmRvbSgpICogMHhmZiB8IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIEdlblJhbmRvbUJ5dGVzKHNpemUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtc0NyeXB0byAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmlsbFJhbmRvbUJ5dGVzKG5ldyBVaW50OEFycmF5KHNpemUpLCBzaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZpbGxSYW5kb21CeXRlcyhuZXcgQXJyYXkoc2l6ZSksIHNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gQ3JlYXRlVVVJRCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IEdlblJhbmRvbUJ5dGVzKFVVSURfU0laRSk7XG4gICAgICAgICAgICAgICAgLy8gbWFyayBhcyByYW5kb20gLSBSRkMgNDEyMiDCpyA0LjRcbiAgICAgICAgICAgICAgICBkYXRhWzZdID0gZGF0YVs2XSAmIDB4NGYgfCAweDQwO1xuICAgICAgICAgICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdICYgMHhiZiB8IDB4ODA7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgVVVJRF9TSVpFOyArK29mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYnl0ZSA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gNCB8fCBvZmZzZXQgPT09IDYgfHwgb2Zmc2V0ID09PSA4KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiLVwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZSA8IDE2KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gYnl0ZS50b1N0cmluZygxNikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB1c2VzIGEgaGV1cmlzdGljIHVzZWQgYnkgdjggYW5kIGNoYWtyYSB0byBmb3JjZSBhbiBvYmplY3QgaW50byBkaWN0aW9uYXJ5IG1vZGUuXG4gICAgICAgIGZ1bmN0aW9uIE1ha2VEaWN0aW9uYXJ5KG9iaikge1xuICAgICAgICAgICAgb2JqLl9fID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZGVsZXRlIG9iai5fXztcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pKFJlZmxlY3QgfHwgKFJlZmxlY3QgPSB7fSkpO1xuIl0sIm5hbWVzIjpbIlJlZmxlY3QiLCJmYWN0b3J5Iiwicm9vdCIsImdsb2JhbFRoaXMiLCJnbG9iYWwiLCJzZWxmIiwic2xvcHB5TW9kZVRoaXMiLCJleHBvcnRlciIsIm1ha2VFeHBvcnRlciIsInRhcmdldCIsInByZXZpb3VzIiwia2V5IiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZnVuY3Rpb25UaGlzIiwiRnVuY3Rpb24iLCJfIiwiaW5kaXJlY3RFdmFsVGhpcyIsImV2YWwiLCJoYXNPd24iLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsInN1cHBvcnRzU3ltYm9sIiwiU3ltYm9sIiwidG9QcmltaXRpdmVTeW1ib2wiLCJ0b1ByaW1pdGl2ZSIsIml0ZXJhdG9yU3ltYm9sIiwiaXRlcmF0b3IiLCJzdXBwb3J0c0NyZWF0ZSIsImNyZWF0ZSIsInN1cHBvcnRzUHJvdG8iLCJfX3Byb3RvX18iLCJBcnJheSIsImRvd25MZXZlbCIsIkhhc2hNYXAiLCJNYWtlRGljdGlvbmFyeSIsImhhcyIsIm1hcCIsImNhbGwiLCJnZXQiLCJ1bmRlZmluZWQiLCJmdW5jdGlvblByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwiX01hcCIsIk1hcCIsImVudHJpZXMiLCJDcmVhdGVNYXBQb2x5ZmlsbCIsIl9TZXQiLCJTZXQiLCJDcmVhdGVTZXRQb2x5ZmlsbCIsIl9XZWFrTWFwIiwiV2Vha01hcCIsIkNyZWF0ZVdlYWtNYXBQb2x5ZmlsbCIsInJlZ2lzdHJ5U3ltYm9sIiwiZm9yIiwibWV0YWRhdGFSZWdpc3RyeSIsIkdldE9yQ3JlYXRlTWV0YWRhdGFSZWdpc3RyeSIsIm1ldGFkYXRhUHJvdmlkZXIiLCJDcmVhdGVNZXRhZGF0YVByb3ZpZGVyIiwiZGVjb3JhdGUiLCJkZWNvcmF0b3JzIiwicHJvcGVydHlLZXkiLCJhdHRyaWJ1dGVzIiwiSXNVbmRlZmluZWQiLCJJc0FycmF5IiwiVHlwZUVycm9yIiwiSXNPYmplY3QiLCJJc051bGwiLCJUb1Byb3BlcnR5S2V5IiwiRGVjb3JhdGVQcm9wZXJ0eSIsIklzQ29uc3RydWN0b3IiLCJEZWNvcmF0ZUNvbnN0cnVjdG9yIiwibWV0YWRhdGEiLCJtZXRhZGF0YUtleSIsIm1ldGFkYXRhVmFsdWUiLCJkZWNvcmF0b3IiLCJJc1Byb3BlcnR5S2V5IiwiT3JkaW5hcnlEZWZpbmVPd25NZXRhZGF0YSIsImRlZmluZU1ldGFkYXRhIiwiaGFzTWV0YWRhdGEiLCJPcmRpbmFyeUhhc01ldGFkYXRhIiwiaGFzT3duTWV0YWRhdGEiLCJPcmRpbmFyeUhhc093bk1ldGFkYXRhIiwiZ2V0TWV0YWRhdGEiLCJPcmRpbmFyeUdldE1ldGFkYXRhIiwiZ2V0T3duTWV0YWRhdGEiLCJPcmRpbmFyeUdldE93bk1ldGFkYXRhIiwiZ2V0TWV0YWRhdGFLZXlzIiwiT3JkaW5hcnlNZXRhZGF0YUtleXMiLCJnZXRPd25NZXRhZGF0YUtleXMiLCJPcmRpbmFyeU93bk1ldGFkYXRhS2V5cyIsImRlbGV0ZU1ldGFkYXRhIiwicHJvdmlkZXIiLCJHZXRNZXRhZGF0YVByb3ZpZGVyIiwiT3JkaW5hcnlEZWxldGVNZXRhZGF0YSIsImkiLCJsZW5ndGgiLCJkZWNvcmF0ZWQiLCJkZXNjcmlwdG9yIiwiTWV0YWRhdGFLZXkiLCJPIiwiUCIsInBhcmVudCIsIk9yZGluYXJ5R2V0UHJvdG90eXBlT2YiLCJUb0Jvb2xlYW4iLCJNZXRhZGF0YVZhbHVlIiwib3duS2V5cyIsInBhcmVudEtleXMiLCJzZXQiLCJrZXlzIiwiX2kiLCJvd25LZXlzXzEiLCJoYXNLZXkiLCJhZGQiLCJwdXNoIiwiX2EiLCJwYXJlbnRLZXlzXzEiLCJUeXBlIiwieCIsIklzU3ltYm9sIiwiVG9QcmltaXRpdmUiLCJpbnB1dCIsIlByZWZlcnJlZFR5cGUiLCJoaW50IiwiZXhvdGljVG9QcmltIiwiR2V0TWV0aG9kIiwicmVzdWx0IiwiT3JkaW5hcnlUb1ByaW1pdGl2ZSIsInRvU3RyaW5nXzEiLCJ0b1N0cmluZyIsIklzQ2FsbGFibGUiLCJ2YWx1ZU9mIiwidG9TdHJpbmdfMiIsImFyZ3VtZW50IiwiVG9TdHJpbmciLCJpc0FycmF5IiwiU2FtZVZhbHVlWmVybyIsInkiLCJWIiwiZnVuYyIsIkdldEl0ZXJhdG9yIiwib2JqIiwibWV0aG9kIiwiSXRlcmF0b3JWYWx1ZSIsIml0ZXJSZXN1bHQiLCJJdGVyYXRvclN0ZXAiLCJuZXh0IiwiZG9uZSIsIkl0ZXJhdG9yQ2xvc2UiLCJmIiwicHJvdG8iLCJwcm90b3R5cGVQcm90byIsImNvbnN0cnVjdG9yIiwiQ3JlYXRlTWV0YWRhdGFSZWdpc3RyeSIsImZhbGxiYWNrIiwiQ3JlYXRlRmFsbGJhY2tQcm92aWRlciIsImZpcnN0Iiwic2Vjb25kIiwicmVzdCIsInRhcmdldFByb3ZpZGVyTWFwIiwicmVnaXN0cnkiLCJyZWdpc3RlclByb3ZpZGVyIiwiZ2V0UHJvdmlkZXIiLCJzZXRQcm92aWRlciIsImlzRXh0ZW5zaWJsZSIsIkVycm9yIiwiZ2V0UHJvdmlkZXJOb0NhY2hlIiwiaXNQcm92aWRlckZvciIsInByb3ZpZGVyTWFwIiwiaGFzUHJvdmlkZXIiLCJleGlzdGluZ1Byb3ZpZGVyIiwiZW51bWVyYWJsZSIsInRhcmdldE1ldGFkYXRhIiwiR2V0T3JDcmVhdGVNZXRhZGF0YU1hcCIsIkNyZWF0ZSIsImNyZWF0ZWRUYXJnZXRNZXRhZGF0YSIsIm1ldGFkYXRhTWFwIiwiZGVsZXRlIiwia2V5c09iaiIsImsiLCJuZXh0VmFsdWUiLCJlIiwic2l6ZSIsInJlZmxlY3QiLCJtZXRhZGF0YU93bmVyIiwibWV0YWRhdGFQcm9wZXJ0eVNldCIsInJlZ2lzdGVyZWRQcm92aWRlciIsImNhY2hlU2VudGluZWwiLCJhcnJheVNlbnRpbmVsIiwiTWFwSXRlcmF0b3IiLCJ2YWx1ZXMiLCJzZWxlY3RvciIsIl9pbmRleCIsIl9rZXlzIiwiX3ZhbHVlcyIsIl9zZWxlY3RvciIsImluZGV4IiwidGhyb3ciLCJlcnJvciIsInJldHVybiIsIl9jYWNoZUtleSIsIl9jYWNoZUluZGV4IiwiX2ZpbmQiLCJjbGVhciIsImdldEtleSIsImdldFZhbHVlIiwiZ2V0RW50cnkiLCJpbnNlcnQiLCJfbWFwIiwiVVVJRF9TSVpFIiwicm9vdEtleSIsIkNyZWF0ZVVuaXF1ZUtleSIsIl9rZXkiLCJ0YWJsZSIsIkdldE9yQ3JlYXRlV2Vha01hcFRhYmxlIiwiQ3JlYXRlVVVJRCIsIkZpbGxSYW5kb21CeXRlcyIsImJ1ZmZlciIsIk1hdGgiLCJyYW5kb20iLCJHZW5SYW5kb21CeXRlcyIsIlVpbnQ4QXJyYXkiLCJjcnlwdG8iLCJnZXRSYW5kb21WYWx1ZXMiLCJtc0NyeXB0byIsImRhdGEiLCJvZmZzZXQiLCJieXRlIiwidG9Mb3dlckNhc2UiLCJfXyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBQzlFLElBQUlBO0FBQ0gsQ0FBQSxTQUFVQSxPQUFPO0lBQ2Qsb0JBQW9CO0lBQ3BCLCtDQUErQztJQUM5QyxDQUFBLFNBQVVDLE9BQU87UUFDZCxJQUFJQyxPQUFPLE9BQU9DLGVBQWUsV0FBV0EsYUFDeEMsT0FBT0MsV0FBVyxXQUFXQSxTQUN6QixPQUFPQyxTQUFTLFdBQVdBLE9BQ3ZCLE9BQU8sSUFBSSxLQUFLLFdBQVcsSUFBSSxHQUMzQkM7UUFDaEIsSUFBSUMsV0FBV0MsYUFBYVI7UUFDNUIsSUFBSSxPQUFPRSxLQUFLRixPQUFPLEtBQUssYUFBYTtZQUNyQ08sV0FBV0MsYUFBYU4sS0FBS0YsT0FBTyxFQUFFTztRQUMxQztRQUNBTixRQUFRTSxVQUFVTDtRQUNsQixJQUFJLE9BQU9BLEtBQUtGLE9BQU8sS0FBSyxhQUFhO1lBQ3JDRSxLQUFLRixPQUFPLEdBQUdBO1FBQ25CO1FBQ0EsU0FBU1EsYUFBYUMsTUFBTSxF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\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/reflect-metadata/Reflect.js\n");

/***/ })

};
;